<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     瑟兰迪尔
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">瑟兰迪尔</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['竹杖芒鞋轻胜马', '谁怕？', '一蓑烟雨任平生'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: false
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Docker官方手册学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/04/Docker%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >Docker官方手册学习笔记</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/05/04/Docker%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-05-04T08:56:03.000Z" itemprop="datePublished">2022-05-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker官方手册学习笔记"><a href="#Docker官方手册学习笔记" class="headerlink" title="Docker官方手册学习笔记"></a>Docker官方手册学习笔记</h1><blockquote>
<p>官方学习手册：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/introduction/what">https://yeasy.gitbook.io/docker_practice/introduction/what</a></p>
</blockquote>
<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><p>Docker使用Google公司推出的Go语言进行开发实现，基于linux内核的cgroup、namespace、以及Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术(将操作系统内核虚拟化，可以允许用户空间软件实例被分割成几个独立的单元)。</br><br><img src="/images/docker.png"></br></p>
<blockquote>
<p>runc是一个Linux命令行工具，用于根据OCI容器运行时规范创建和运行容器。</br><br>containerd是一个守护程序，它管理容器生命周期，提供了一个在节点上执行容器和管理镜像的最小功能集。</p>
</blockquote>
<p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。</br></p>
<h5 id="Docker与传统虚拟化方式的不同之处"><a href="#Docker与传统虚拟化方式的不同之处" class="headerlink" title="Docker与传统虚拟化方式的不同之处"></a>Docker与传统虚拟化方式的不同之处</h5><p>传统虚拟机技术是模拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上再运行所需应用进程。<b>而容器内的应用进程则直接运行于宿主的内核。容器内没有自己的内核，而且也没有进行硬件模拟，因此容器要比传统虚拟机更为轻便</b>。</br></p>
<h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><h5 id="1-更高效的利用系统资源"><a href="#1-更高效的利用系统资源" class="headerlink" title="1.更高效的利用系统资源"></a>1.更高效的利用系统资源</h5><p>容器不需要进行硬件虚拟以及完整操作系统等额外开销。Docker对系统资源的利用率更高。在<b>应用执行速度、内存损耗、文件存储速度</b>等方面都比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<h5 id="2-更快速的启动时间"><a href="#2-更快速的启动时间" class="headerlink" title="2.更快速的启动时间"></a>2.更快速的启动时间</h5><p>Docker容器应用，直接运行于宿主内核，无需启动完整的操作系统。因此可以做到秒级、毫秒级的启动时间。<b>大大的节约了开发、测试、部署的时间。</b></p>
<h5 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h5><p>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。</p>
<h5 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h5><p>开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试。而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</p>
<h5 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h5><p>Docker确保了执行环境的一致性，使得应用的迁移更加容易。用户可以轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h5 id="更轻松的维护和拓展"><a href="#更轻松的维护和拓展" class="headerlink" title="更轻松的维护和拓展"></a>更轻松的维护和拓展</h5><blockquote>
<p>1.Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易。</br><br>2.Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可用于专门定制，大大降低了应用服务的镜像制作成本。</p>
</blockquote>
<h1 id="基础概念区分"><a href="#基础概念区分" class="headerlink" title="基础概念区分"></a>基础概念区分</h1><h5 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1.镜像"></a>1.镜像</h5><p>操作系统分为内核和用户空间。相对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像，就相当于是一个root文件系统。比如官方镜像ubuntu:18.04就包含了完整的一套Ubuntu 18.04最小系统的root文件系统。</br><br>&emsp;&emsp;<b>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。</b></br></p>
<h5 id="分层存储机制"><a href="#分层存储机制" class="headerlink" title="分层存储机制"></a>分层存储机制</h5><p>Docker被设计为分层存储的架构。所以严格来说，镜像并非是像一个ISO那样的打包文件爱，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</br><br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生变化，后一层上的任何改变只发生在自己这一层</p>
<h5 id="2-容器"><a href="#2-容器" class="headerlink" title="2.容器"></a>2.容器</h5><p>&emsp;&emsp;容器(container)与镜像(image)的关系，就像是面对对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</br><br>&emsp;&emsp;容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此，<b>容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间</b>。容器内的进程，运行在一个隔离的环境中，使用起来像是在一个独立与宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主机运行更加安全。</br><br>&emsp;&emsp;镜像使用的是分层存储，容器亦是如此，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层。</br><br>&emsp;&emsp;容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</br><br>&emsp;&emsp;按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(volume)或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</br><br>&emsp;&emsp;数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷之后，容器删除或者重新运行之后，数据不会丢失。</br></p>
<h5 id="3。仓库"><a href="#3。仓库" class="headerlink" title="3。仓库"></a>3。仓库</h5><p>仓库提供一个集中的存储、分发镜像的服务</p>
<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从Docker镜像仓库获取镜像的命令是docker pull。其命令格式是：<br><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code><br>镜像名称的格式：</p>
<blockquote>
<p>1.Docker镜像仓库地址：地址格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub</br><br>2.仓库名：采用两段式名称。即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名，则默认为library，也就是官方镜像</p>
</blockquote>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>&emsp;&emsp;有了镜像后，我们就能以这个镜像为基础启动并运行一个容器。</br></p>
<figure class="highlight docker"><figcaption><span>run```就是运行容器的命令。以以下命令为例，简要说明一下上面用到的参数:</br></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```docker <span class="keyword">run</span><span class="bash"> -it --rm ubuntu:18.04 bash```</span></span><br><span class="line">&gt; 1.```-it```：这是两个参数，一个是-i:交互式操作，一个是-t终端。这里打算进入bash执行一些命令并查看返回结果，因此我们需要交互式终端。&lt;/br&gt;</span><br><span class="line">&gt; 2.```--rm```：这个参数是说容器退出后随之将其删除。&lt;/br&gt;</span><br><span class="line">&gt; 3.```ubuntu:18.04```：这是指用ubuntu:18.04镜像为基础来启动容器。&lt;/br&gt;</span><br><span class="line">&gt; <span class="number">4</span>.```bash```放在镜像名称后的是命令，这里我们希望有个交互式<span class="keyword">shell</span><span class="bash">，因此用的是bash</span></span><br><span class="line"></span><br><span class="line">可以通过```exit```命令退出容器</span><br><span class="line"><span class="comment">## 删除本地镜像</span></span><br><span class="line">```docker image rm [选项] &lt;镜像<span class="number">1</span>&gt; [&lt;镜像<span class="number">2</span>&gt;...]```</span><br><span class="line">其中，```镜像```可以是```镜像短ID、镜像长ID、镜像名或者镜像摘要```&lt;/br&gt;</span><br><span class="line">```短ID```一般取<span class="number">3</span>个字符以上，只要足够区分于别的镜像就可以了</span><br><span class="line"><span class="comment">## docker commit</span></span><br><span class="line">当我们运行一个容器的时候(如果不使用卷的话)，我们做的任何文件修改都会被记录于容器存储层内。而Docker提供了一个```docker commit```命令，可以将容器的存储层保存下来作为新的镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后运行这个新镜像的时候，就会拥有原有容器最后的文件变化。&lt;/br&gt;</span><br><span class="line">其语法格式为：&lt;/br&gt;</span><br><span class="line">```docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]```</span><br><span class="line">然而，由于命令的执行，还有很多文件被改动或添加了。如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。&lt;/br&gt;</span><br><span class="line">此外，使用```docker commit```意味着对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像。黑箱镜像的维护工作是非常痛苦的。&lt;/br&gt;</span><br><span class="line">如果使用```docker commit```制作镜像，以及后期修改的话，每次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直跟随着这个镜像，即使根本无法访问到，这会让镜像更加臃肿。</span><br><span class="line"><span class="comment">## 使用Dockerfile来定制镜像</span></span><br><span class="line">&gt; 原理介绍：镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。这个脚本就是Dockerfile</span><br><span class="line"><span class="comment">### FROM指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span>就是指定基础镜像，一个Dockerfile中<span class="keyword">FROM</span>是必备的指令，而且必须是第一条指令</span><br><span class="line"><span class="comment">### RUN执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">指令是在定制镜像时最常用的指令之一，其格式有如下两种：</span></span><br><span class="line">&gt; <span class="number">1</span>.shell格式：```<span class="keyword">RUN</span><span class="bash"> &lt;命令&gt;```，就像直接在命令行中输入的命令一样</span></span><br><span class="line">&gt; <span class="number">2</span>.exec格式</span><br><span class="line">```<span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]```</span></span><br><span class="line">Dockerfile中每一个指令都会建立一层，<span class="keyword">RUN</span><span class="bash">也不例外。每一个RUN的行为，就和刚才手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit这一层的修改，构成新镜像</span></span><br><span class="line"><span class="comment">### COPY复制文件</span></span><br></pre></td></tr></table></figure>
<p>COPY [–chown=<user>:<group>] &lt;源路径&gt;…&lt;目标路径&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COPY指令将从构建上下文目录中&#96;&#96;&#96;&lt;源路径&gt;&#96;&#96;&#96;的文件&#x2F;目录复制到新的一层镜像内的&#96;&#96;&#96;&lt;目标路径&gt;&#96;&#96;&#96;位置</span><br><span class="line">&#96;&#96;&#96;COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;&#96;&#96;&#96;</span><br><span class="line">值得注意的是，使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用Git进行管理的时候。&lt;&#x2F;br&gt;</span><br><span class="line">在使用该指令的时候还可以加上&#96;&#96;&#96;--chown&#x3D;&lt;user&gt;:&lt;group&gt;&#96;&#96;&#96;选项来改变文件的所属用户及所属组。</span><br><span class="line">### ENTRYPOINT入口点</span><br><span class="line">&#96;&#96;&#96;ENTRYPOINT&#96;&#96;&#96;的目的和&#96;&#96;&#96;CMD&#96;&#96;&#96;一样，都是在指定容器启动程序及参数，指令格式为：&lt;&#x2F;br&gt;</span><br><span class="line">&#96;&#96;&#96;&lt;ENTRYPOINT&gt; &quot;CMD&quot;&#96;&#96;&#96;</span><br><span class="line">##### 场景一：让镜像变成命令一样被使用</span><br></pre></td></tr></table></figure>
<p>FROM ubuntu:18.04<br>RUN apt-get update <br>    &amp;&amp; apt-get install -y curl <br>    &amp;&amp; rm -rf /var/lib/apt/lists*<br>ENTRYPOINT [“curl”, “-s”, “<a href="http://myip.ipip.net&quot;]">http://myip.ipip.net&quot;]</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用：</span><br></pre></td></tr></table></figure>
<p>docker run myip -i</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当存在ENTRYPOINT后，CMD的内容将会作为参数传递给ENTRYPOINT，-i就是这里新的CMD，会作为参数传递给curl</span><br><span class="line">##### 场景二：应用运行前的准备工作</span><br><span class="line">启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。&lt;&#x2F;br&gt;</span><br><span class="line">比如mysql类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的mysql服务器运行之前解决。&lt;&#x2F;br&gt;</span><br><span class="line">此外，要避免使用root用户去启动服务，从而提高安全性，在启动服务之前需要以root身份执行一些必要的准备工作。&lt;&#x2F;br&gt;</span><br><span class="line">官方镜像redis就是这么做的：</span><br></pre></td></tr></table></figure>
<p>FROM alpine:3.4<br>…<br>RUN　addgroup -S redis &amp;&amp; adduser -S -G redis redis<br>…<br>ENTRYPOINT [“docker-entrypoint.sh”]</p>
<p>EXPOSE 6379<br>CMD [“redis-server”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### ENV设置环境变量</span><br><span class="line">这个指令就是设置环境变量，以官方&#96;&#96;&#96;node&#96;&#96;&#96;镜像的Dockerfile为例</span><br></pre></td></tr></table></figure>
<p>ENV NODE_VERSION 7.2.0</p>
<p>RUN curl -SLO “<a target="_blank" rel="noopener" href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;</a> <br>  &amp;&amp; curl -SLO “<a target="_blank" rel="noopener" href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</a> <br>  &amp;&amp; gpg –batch –decrypt –output SHASUMS256.txt SHASUMS256.txt.asc <br>  &amp;&amp; grep “ node-v$NODE_VERSION-linux-x64.tar.xz$“ SHASUMS256.txt | sha256sum -c - <br>  &amp;&amp; tar -xJf “node-v$NODE_VERSION-linux-x64.tar.xz” -C /usr/local –strip-components=1 <br>  &amp;&amp; rm “node-v$NODE_VERSION-linux-x64.tar.xz” SHASUMS256.txt.asc SHASUMS256.txt <br>  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里先定义了环境变量&#96;&#96;&#96;NODE_VERSION&#96;&#96;&#96;，其后的&#96;&#96;&#96;RUN&#96;&#96;&#96;这层里，多次使用&#96;&#96;&#96;$NODE_VERSION&#96;&#96;&#96;来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新&#96;&#96;&#96;7.2.0&#96;&#96;&#96;即可，&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;构建维护变得更轻松了。</span><br><span class="line">### VOLUME定义匿名卷</span><br><span class="line">格式为：</span><br></pre></td></tr></table></figure>
<p>VOLUME &lt;路径&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)之中。在Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</span><br></pre></td></tr></table></figure>
<p>VOLUME /data</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的&#96;&#96;&#96;&#x2F;data&#96;&#96;&#96;目录就会在容器运行时自动挂载为匿名卷，任何向&#96;&#96;&#96;&#x2F;data&#96;&#96;&#96;中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置，比如：</span><br></pre></td></tr></table></figure>
<p>docker run -d -v mydata:/data xxxx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在这行命令中，就使用了mydata这个命名卷挂载到了&#x2F;data这个位置，替代了&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;中的匿名卷的挂载配置。</span><br><span class="line">### EXPOSE暴露端口</span><br><span class="line">格式为：</span><br></pre></td></tr></table></figure>
<p>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在Dockerfile中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。另一个好处则是在运行时使用随机端口映射，也就是&#96;&#96;&#96;docker run -P&#96;&#96;&#96;时，会自动随机映射&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;端口。&lt;&#x2F;br&gt;</span><br><span class="line">要将&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;和在运行时使用&#96;&#96;&#96;-p &lt;宿主端口&gt;：&lt;容器端口&gt;&#96;&#96;&#96;区分开来。&#96;&#96;&#96;-p&#96;&#96;&#96;，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问。而&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;仅仅是声明容器打算使用什么端口二义，并不会自动在宿主机进行端口映射。</span><br><span class="line">### WORKDIR指定工作目录</span><br><span class="line">格式为：&lt;&#x2F;br&gt;</span><br></pre></td></tr></table></figure>
<p>WORKDIR &lt;工作目录路径&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用&#96;&#96;&#96;WORKDIR&#96;&#96;&#96;指令可以来指定工作目录。目录不存在时，WORKDIR会帮你新建目录。</span><br><span class="line">以下举一个错误的例子：</span><br></pre></td></tr></table></figure>
<p>RUN cd /app<br>RUN echo “hello” &gt; world.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将这个&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;进行构建镜像运行后，会发现找不到&#96;&#96;&#96;&#x2F;app&#x2F;world.txt&#96;&#96;&#96;文件，或者其内容不是&#96;&#96;&#96;hello&#96;&#96;&#96;。原因很简单，在Shell中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;中，这两行&#96;&#96;&#96;RUN&#96;&#96;&#96;命令的执行环境根本不同，是两个完全不同的容器，这就是对&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;构建分层存储的概念不了解所导致的错误。&lt;&#x2F;br&gt;</span><br><span class="line">之前说过，每一个&#96;&#96;&#96;RUN&#96;&#96;&#96;都是启动一个容器，执行命令、执行命令、然后提交存储层文件变更。第一层&#96;&#96;&#96;RUN cd &#x2F;app&#96;&#96;&#96;的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已。其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器。跟第一层的容器完全没关系，自然不可能继承前一层构建过程中的内存变化。&lt;&#x2F;br&gt;</span><br><span class="line">因此如果需要改变以后各层的工作目录的位置，那么应该使用WORKDIR指令。</span><br></pre></td></tr></table></figure>
<p>WORKDIR /app<br>RUN echo “hello” &gt; world.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 操作容器</span><br><span class="line">&gt; 前言：简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用</span><br><span class="line">### 启动</span><br><span class="line">&gt; 启动容器有两种方式：一种是基于镜像新建一个容器并启动，另外一个是将在终止状态(exited)的容器重新启动。Dokcer实在是太轻量级了，很多时候用户都是随时删除和新创建容器&lt;&#x2F;br&gt;</span><br><span class="line"></span><br><span class="line">下面的命令启动一个bash终端，允许用户进行交互</span><br></pre></td></tr></table></figure>
<p>docker run -t -i ubuntu:18.04 /bin/bash<br>root@af8bae53bdd3:/#</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">其中，-t选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上，-i则让容器的标准输入保持打开</span><br><span class="line">### 守护态运行</span><br><span class="line">大多数情况下，我们需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下，通过添加参数&#96;&#96;&#96;-d&#96;&#96;&#96;可以让容器在后台运行。</span><br><span class="line">### 终止</span><br><span class="line">可以使用&#96;&#96;&#96;docker container stop&#96;&#96;&#96;来终止一个运行中的容器&lt;&#x2F;br&gt;</span><br><span class="line">对于处于终止状态的容器，可以通过&#96;&#96;&#96;docker container start&#96;&#96;&#96;命令来重新启动。&lt;&#x2F;br&gt;</span><br><span class="line">此外，&#96;&#96;&#96;docker container restart&#96;&#96;&#96;命令会将一个运行态的容器终止，然后再重新启动它。</span><br><span class="line">### 进入容器</span><br><span class="line">对于需要进入容器才能进行的操作，可以使用&#96;&#96;&#96;docker attach&#96;&#96;&#96;或者&#96;&#96;&#96;docker exec&#96;&#96;&#96;命令，一般只使用&#96;&#96;&#96;docker exec&#96;&#96;&#96;命令&lt;&#x2F;br&gt;</span><br><span class="line">&#96;&#96;&#96;docker exec -it &lt;container_id&gt; bash&#96;&#96;&#96;</span><br><span class="line">如果从这个stdin中exit，不会导致容器的终止，这就是为什么推荐大家使用&#96;&#96;&#96;docker exec&#96;&#96;&#96;的原因</span><br><span class="line">### 导出和导入</span><br><span class="line">#### 导出容器</span><br><span class="line">如果想要导出本地某个容器，可以使用&#96;&#96;&#96;docker export&#96;&#96;&#96;命令</span><br></pre></td></tr></table></figure>
<p>$ docker container ls -a<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES<br>7691a814370e        ubuntu:18.04        “/bin/bash”         36 hours ago        Exited (0) 21 hours ago                       test<br>$ docker export 7691a814370e &gt; ubuntu.tar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 导入容器快照</span><br><span class="line">可以使用&#96;&#96;&#96;docker import&#96;&#96;&#96;从容器快照文件中再导入为镜像：</span><br></pre></td></tr></table></figure>
<p>$ cat ubuntu.tar | docker import - test/ubuntu:v1.0<br>$ docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE<br>test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 删除容器</span><br><span class="line">可以使用&#96;&#96;&#96;docker container rm&#96;&#96;&#96;来删除一个处于终止状态的容器</span><br></pre></td></tr></table></figure>
<p>$ docker container rm trusting_newton<br>trusting_newton</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果要删除一个运行中的容器，可以添加&#96;&#96;&#96;-f&#96;&#96;&#96;参数来强制执行。Docker会发送SIGKILL信号给容器。</span><br><span class="line">### 清理所有处于终止状态的容器</span><br></pre></td></tr></table></figure>
<p>docker container prune</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 数据管理</span><br><span class="line">### 数据卷</span><br><span class="line">数据卷是一个可供一个或多个容器使用的特殊目录，它可以提供很多有用的特性：</span><br><span class="line">&gt; 1.数据卷可以在容器之间共享和重用</span><br><span class="line">&gt; 2.对数据卷的修改会立马生效</span><br><span class="line">&gt; 3.对数据卷的更新，不会影响镜像</span><br><span class="line">&gt; 4.数据卷默认会一直存在，即使容器被删除</span><br><span class="line">注意：数据卷的使用，类似于Linux下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷当中（仅数据卷为空时会复制）。</span><br><span class="line">### 挂载主机目录</span><br><span class="line">使用&#96;&#96;&#96;--mount&#96;&#96;&#96;命令可以指定挂载一个本地主机的目录到容器中去</span><br><span class="line"># 外部访问容器</span><br></pre></td></tr></table></figure>
<p>$ docker run -d -P nginx:alpine</p>
<p>$ docker container ls -l<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES<br>fae320d08268        nginx:alpine        “/docker-entrypoint.…”   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本地主机的32768被映射到了容器的80端口。此时访问本机的32768端口即可访问容器内NGINX默认页面&lt;&#x2F;br&gt;</span><br><span class="line">使用&#96;&#96;&#96;hostPort:containerPort&#96;&#96;&#96;格式本地的80端口映射到容器的80端口，可以执行：</span><br><span class="line">&#96;&#96;&#96;docker run -d -p 80:80 nginx:airpline&#96;&#96;&#96;</span><br><span class="line">此时默认会绑定本地所有接口上的所有地址</span><br><span class="line">##### 使用&#96;&#96;&#96;docker port&#96;&#96;&#96;来查看当前映射的端口配置</span><br><span class="line">&#96;&#96;&#96;docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><figure class="highlight docker"><figcaption><span>Compose```，负责快速的部署分布式应用。</br></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Compose允许用户通过一个单独的```docker-compose.yml```模板文件(YAML格式)来定义一组相关联的应用容器为一个项目(project)。简单来说，```docker-compose.yml```可以管理多个Dockerfile</span><br><span class="line"><span class="comment">##### docker-compose up</span></span><br><span class="line">命令格式为：</span><br><span class="line">```docker-compose up [options] [SERVICE...]```</span><br><span class="line">该命令十分强大，它将尝试自动完成包括构建镜像、创建服务、启动服务，并关联服务相关容器的一系列操作。&lt;/br&gt;</span><br><span class="line">可以说，大部分时候都可以直接通过该命令来启动一个项目。&lt;/br&gt;</span><br><span class="line">如果使用```dockerc-compose up -d```，将会在后台启动并运行所有容器。一般推荐生产环境下使用该选项。&lt;/br&gt;</span><br><span class="line">默认情况，如果服务容器已经存在，```docker-compose up```将会尝试停止容器，然后重新创建，以保证新启动的服务匹配```docker-compose.yml```文件的最新内容</span><br><span class="line"><span class="comment">#### Compose模板文件</span></span><br><span class="line">默认的模板文件名称为```docker-compose.yml```，格式为YAML格式</span><br></pre></td></tr></table></figure>
<p>version: “3”</p>
<p>services:<br>  webapp:<br>    image: examples/web<br>    ports:<br>      - “80:80”<br>    volumes:<br>      - “/data”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意每个服务都必须通过image指令指定镜像或build指令等来自动构建生成镜像。&lt;&#x2F;br&gt;</span><br><span class="line">如果使用build指令，在Dockerfile中设置的选项(例如：CMD、EXPOSE、VOLUME、ENV等)将会被自动获取，无需在&#96;&#96;&#96;docker-compose.yml&#96;&#96;&#96;中重复设置</span><br><span class="line">#### 介绍几个重要的参数</span><br><span class="line">##### build</span><br><span class="line">指定Dockerfile所在文件夹的路径，Compose将会利用它自动构建这个镜像，然后使用这个镜像</span><br></pre></td></tr></table></figure>
<p>version: ‘3’<br>services:</p>
<p>  webapp:<br>    build:<br>      context: ./dir<br>      dockerfile: Dockerfile-alternate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### devices</span><br><span class="line">指定设备映射关系</span><br></pre></td></tr></table></figure>
<p>devices:</p>
<ul>
<li>“/dev/ttyUSB1:/dev/ttyUSB0”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### depends_on</span><br><span class="line">解决容器的依赖、启动先后的问题。以下例子中会先启动redis、db再启动web</span><br></pre></td></tr></table></figure>
version: ‘3’</li>
</ul>
<p>services:<br>  web:<br>    build: .<br>    depends_on:<br>      - db<br>      - redis</p>
<p>  redis:<br>    image: redis</p>
<p>  db:<br>    image: postgres</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### env_file</span><br><span class="line">从文件中获取环境变量，可以为单独的文件路径或列表</span><br></pre></td></tr></table></figure>
<p>env_file:</p>
<ul>
<li>./common.env</li>
<li>./apps/web.env</li>
<li>/opt/secrets.env<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### environment</span><br><span class="line">设置环境变量</span><br></pre></td></tr></table></figure>
environment:<br>RACK_ENV: development<br>SESSION_SECRET:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##### expose</span><br><span class="line">暴露端口，但不映射到宿主机，只被连接的服务访问</span><br><span class="line">##### ports</span><br><span class="line">暴露端口信息。&lt;&#x2F;br&gt;</span><br><span class="line">使用宿主端口：容器端口(HOST:CONTAINER)格式。若仅指定容器端口(宿主将会随机选择端口)</span><br></pre></td></tr></table></figure>
<p>ports:</p>
<ul>
<li>“3000”</li>
<li>“8000:8000”</li>
<li>“49100:22”</li>
<li>“127.0.0.1:8001:8001”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### volumes</span><br><span class="line">数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式</span><br></pre></td></tr></table></figure>
version: “3”</li>
</ul>
<p>services:<br>  my_src:<br>    image: mysql:8.0<br>    volumes:<br>      - mysql_data:/var/lib/mysql</p>
<p>volumes:<br>  mysql_data:<br>```</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Go语言基础进阶教程(一)：bufio包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/28/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B(%E4%B8%80)%EF%BC%9Abufio%E5%8C%85/"
    >Go语言基础进阶教程(一)：bufio包</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/04/28/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B(%E4%B8%80)%EF%BC%9Abufio%E5%8C%85/" class="article-date">
  <time datetime="2022-04-28T12:59:52.000Z" itemprop="datePublished">2022-04-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-bufio包原理"><a href="#1-bufio包原理" class="headerlink" title="1.bufio包原理"></a>1.bufio包原理</h2><h5 id="bufio是通过缓冲来提高效率的"><a href="#bufio是通过缓冲来提高效率的" class="headerlink" title="bufio是通过缓冲来提高效率的"></a>bufio是通过缓冲来提高效率的</h5><p>&emsp;&emsp;前言：io操作本身的效率并不低，低的是频繁访问本地磁盘的文件。所以bufio就提供了缓冲区（分配一块内存），读和写都先在缓冲区中进行，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。</br><br>&emsp;&emsp;缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。</br><br>&emsp;&emsp;bufio封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象.</br><br>&emsp;&emsp;io.Reader或io.Writer接口实现read()和write()方法，对于实现这个接口的对象都是可以使用这两个方法的。</br></p>
<h5 id="Reader对象"><a href="#Reader对象" class="headerlink" title="Reader对象"></a>Reader对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reader implements buffering for an io.Reader object</span><br><span class="line">type Reader struct&#123;</span><br><span class="line">    buf   []byte</span><br><span class="line">    rd    io.Reader &#x2F;&#x2F;reader provided by the client</span><br><span class="line">    r, w  int</span><br><span class="line">    err   error</span><br><span class="line">    lastByte int&#x2F;&#x2F;last byte read for UnreadByte; -1 means invalid</span><br><span class="line">    lastRuneSize int &#x2F;&#x2F;size of last rune read for UnreadRune; -1 means invalid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取规则如下：</br><br>bufio.Read(p []byte)相当于读取大小len(p)的内容：</p>
<blockquote>
<p>1.当缓存区有内容时，将缓存区内容全部填入p并清空缓存区。</br><br>2.若想要读取的内容比缓存区还要大，直接去文件读取即可。</br><br>3.当缓存区没有内容，且要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满(此时缓存区有剩余内容)</br></p>
</blockquote>
<p>bufio.Writer是bufio中对io.Writer的封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer</span><br><span class="line">type Writer struct&#123;</span><br><span class="line">    err error</span><br><span class="line">    buf []byte</span><br><span class="line">    n int</span><br><span class="line">    wr io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bufio.Write(p []byte)的思路如下：</p>
<blockquote>
<p>1.判断buf中可用容量是否可以放下p。</br><br>2.如果能放下，直接把p拼接在buf后面，即把内容放到缓冲区。</br><br>3.如果缓冲区的容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可。</br><br>4.如果缓冲区的容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区。</br><br>5.判断p的剩余内容大小是否能放入缓冲区，如果能放下，则把内容放到缓冲区。</br><br>6.如果p的剩余内容仍旧大于缓冲区，则把p的剩余内容直接写入文件。</p>
</blockquote>
<h5 id="b-flush-会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush-到文件"><a href="#b-flush-会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush-到文件" class="headerlink" title="b.flush()会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件"></a>b.flush()会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件</h5><h2 id="2-bufio包"><a href="#2-bufio包" class="headerlink" title="2.bufio包"></a>2.bufio包</h2><p>&emsp;&emsp;bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer对象，同时还提供了缓冲和一些文本I/O的帮助函数的对象。</br><br>&emsp;&emsp;bufio.Reader实现了如下接口：</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;NewReaderSize将rd封装成一个带缓存的bufio.Reader对象，</span><br><span class="line">&#x2F;&#x2F;缓存大小由size指定（若小于16， 会被设置为16）</span><br><span class="line">&#x2F;&#x2F;如果rd的基类型就是由足够缓存的bufio.Reader类型，则直接将rd转换为基类型返回</span><br><span class="line">func NewReaderSize(rd io.Reader, size int) *Reader</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;NewReader相当于NewReaderSize(rd, 4096)</span><br><span class="line">func NewReader(rd io.Reader) *Reader</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Peek返回缓存的一个切片，该切片引用缓存中前n个字节的数据，</span><br><span class="line">&#x2F;&#x2F;该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之前</span><br><span class="line">&#x2F;&#x2F;是有效的，如果切片的长度小于n，则返回一个错误信息并说明原因</span><br><span class="line">&#x2F;&#x2F;如果n大于缓存的总大小，则返回ErrBufferFull</span><br><span class="line">func (b *Reader) Peek(n int)([]byte error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Read从b中读出数据到p中，返回读出的字节数和遇到的错误</span><br><span class="line">&#x2F;&#x2F;如果缓存不为空，则只能读出缓存中的数据，不会从底层的io.Reader</span><br><span class="line">&#x2F;&#x2F;中读取数据，如果缓存为空，则：</span><br><span class="line">&#x2F;&#x2F;1.len(p) &gt;&#x3D;缓存大小，则跳过缓存，直接从底层io.Reader中</span><br><span class="line">&#x2F;&#x2F;读出到p中</span><br><span class="line">&#x2F;&#x2F;2.len(p)&lt;缓存大小，则先将数据从底层io.Reader中读取到缓存中，再从缓存读取到p中。</span><br><span class="line">func (b * Reader)Read(p []byte)(n int, err error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Buffered返回缓存中未读取的数据的长度</span><br><span class="line">func (b *Reader)Buffered() int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ReadBytes功能同ReadSlice，只不过返回的是缓存的考本</span><br><span class="line">func (b *Reader)ReadBytes(delim byte)(line []byte, err error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ReadString功能同ReadBytes，只不过返回的是字符串</span><br><span class="line">func (b *Reader) ReadString(delim byte) (line string, err error)</span><br></pre></td></tr></table></figure>
<p>bufio.Write实现了如下接口：</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;NewWriterSize将wr封装成一个带缓存的bufio.Writer对象，</span><br><span class="line">&#x2F;&#x2F;缓存大小由size决定（如果小于4096会被设置为4096）</span><br><span class="line">&#x2F;&#x2F;如果wr的基类型就是有足够缓存的bufio.Writer类型，则直接将</span><br><span class="line">&#x2F;&#x2F;wr转换为基类型返回</span><br><span class="line">func NewWriter(wr io.Writer, size int) *Writer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;NewWriter相当于NewWrietrSize(wr, 4096)</span><br><span class="line">func NewWriter(wr io.Writer) *Writer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;WriteString 功能同write</span><br><span class="line">func (b *Write) WriteString(s string) (int ,error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;WriteRune向b写入r的UTF-8编码，返回r的编码长度</span><br><span class="line">func (b *Write)WriteRune(r rune)(size int, err error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Flush将缓存中的数据提交到底层的io.Writer中</span><br><span class="line">func (b *Writer) Flush() error</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Available 返回缓存中未使用的空间的长度</span><br><span class="line">func (b *Writer)Available() int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Buffered返回缓存中未提交的数据的长度</span><br><span class="line">func (b *Writer)Buffered() int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Reset将b的底层Writer重新指定为w，同时丢弃缓存中的所有数据，复位</span><br><span class="line">&#x2F;&#x2F;所有标记和错误信息。相当于创建一个新的bufio.Writer</span><br><span class="line">func (b *Writer) Reset(w io.Writer)</span><br><span class="line"></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-无用之用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/17/%E6%97%A0%E7%94%A8%E4%B9%8B%E7%94%A8/"
    >无用之用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/04/17/%E6%97%A0%E7%94%A8%E4%B9%8B%E7%94%A8/" class="article-date">
  <time datetime="2022-04-17T12:36:17.000Z" itemprop="datePublished">2022-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="无用之用"><a href="#无用之用" class="headerlink" title="无用之用"></a>无用之用</h1><p>&emsp;&emsp;近日，一位好友让我把“我爱看书”这一特征在pyq进行适当展示。我回他一句：“这对我来说是日常了，展示日常让我觉得别扭”。从幼儿园的时候看《幼儿画报》，小学的时候看《儿童文学》，初中的时候看《意林·少年版》，高中在课业繁忙的同时看看《读者》。这只是杂志一类。看完《哈利波特》的全集、看东野圭吾、看村上春树、看《福尔摩斯》、看《红楼梦》，这几年偏爱毛姆、史铁生。几年前读清史，这两年开始了解唐宋。怎么样写下这些文字，能润色着文字不让所谓这些从小妈妈并未刻意培养的习惯，透露出来一种优越感呢？</br><br>&emsp;&emsp;希望我在写下这些时，没有让文字透出令人生厌的酸气。毕竟我是理工科女生，看书只能是所谓“无用之用”了。</br><br>&emsp;&emsp;其实大概是有感觉的吧，在同门说出“我讲话很愿意让人听”，在师兄说出“和我聊过一次之后发现和想象中很不一样”，在师兄所谓我“说话与沟通的能力”。近期到觉得这特征颇无用处，既不如好的外表让人一见倾心，又不如强大的逻辑思维在我学习代码的过程中让我平步青云。读过的这些文字反倒是让我的共情能力变得可怖，内心总充斥着百转千回的情绪，反倒是不能大大咧咧、肆意一生了。</br><br>&emsp;&emsp;一位朋友说9月即将远行，第一反应，脑子里充斥着的全是《红楼梦》中的“盛席必散”一词，心里给林妹妹点了一万个赞。黛玉不喜聚会，因为她觉得“天下没有不散的宴席”，聚的时候多热闹，散的时候就有多难过。此刻，反倒是分外能共情这句话了。今天又读到史铁生有关历史的车轮中，总要牺牲掉一些人的论调。不禁又共情起在疫情中殒命的人们。</br><br>&emsp;&emsp;打开这篇笔记也不知道想具体写些什么，希望不要是把自己敏感的性格推至读书这件事上。又想保持着“能一个人带着一本书去草地上坐一下午”这种有点滑稽的行为模式，一面在现实的世界里摸爬滚打，继续追求“有用之用”。</br><br>&emsp;&emsp;人这辈子，总要是有点理想主义和浪漫在身上的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" rel="tag">碎碎念</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Docker build的cache机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/17/Docker%20build%E7%9A%84cache%E6%9C%BA%E5%88%B6/"
    >Docker build的cache机制</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/04/17/Docker%20build%E7%9A%84cache%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2022-04-17T11:15:03.000Z" itemprop="datePublished">2022-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker-build的cache机制"><a href="#Docker-build的cache机制" class="headerlink" title="Docker build的cache机制"></a>Docker build的cache机制</h1><h3 id="docker-build命令简介"><a href="#docker-build命令简介" class="headerlink" title="docker build命令简介"></a>docker build命令简介</h3><p>以如下这个Dockerfile为例：</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM Ubuntu:14.04</span><br><span class="line">RUN apt-get update ADD run.sh &#x2F; VOLUME &#x2F;data CMD[&quot;.&#x2F;run.sh&quot;]</span><br></pre></td></tr></table></figure>
<p>随后执行下面一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t&#x3D;&quot;my_new_image&quot;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即可将当前目录下的Dockerfile构建成一个名为my_new_image的镜像，镜像的默认tag是latest。对于以上的docker build请求，Docker Daemon新创建了4层镜像，除了FROM命令，其余的RUN、ADD、VOLUME以及CMD命令都会创建一层新的镜像。</p>
<h3 id="镜像cache机制的介绍"><a href="#镜像cache机制的介绍" class="headerlink" title="镜像cache机制的介绍"></a>镜像cache机制的介绍</h3><p>&emsp;&emsp;Dockerfile可以通过<code>docker build</code>命令构建为一个新的镜像，Dockerfile中的每一条命令都会构建出一个新的镜像层。既然如此，构建成功后宿主机上的镜像层是否会不断增多，导致磁盘空间资源逐渐缩小？另外，一个Dockerfile如果构建多次，对于Dockerfile中的某一指定指令，是否会出现产生多个对应镜像层的情况呢？</p>
<h3 id="docker-build的cache机制"><a href="#docker-build的cache机制" class="headerlink" title="docker build的cache机制"></a>docker build的cache机制</h3><p>&emsp;&emsp;Docker Daemon通过Dockerfile构建镜像时，当发现即将新构建出的镜像与已有的某镜像重复时，可以选择放弃构建新的镜像，也就是采取本地已经cache的镜像作为结果。</p>
<h3 id="cache机制的实现原理："><a href="#cache机制的实现原理：" class="headerlink" title="cache机制的实现原理："></a>cache机制的实现原理：</h3><p>&emsp;&emsp;Docker镜像，由镜像层文件系统和镜像json文件组成，而这两者都含有一个相同的镜像ID。</br></p>
<blockquote>
<p>1.<code>FROM buntu:14.04</code>:FROM命令是Dockerfile中唯一不可缺少的命令，它为最终构建出的镜像设定了一个基础镜像(base image)。docker build命令解析Dockerfile的FROM命令时，可以立即获悉在哪一个镜像基础上完成下一条命令<code>RUN apt-get update</code>的镜像构建。此时，Docker Daemon获取Ubuntu: 14.04镜像的镜像ID，并提取该镜像json文件中的内容，以备下一条命令构建时使用。</br><br>2.<code>RUN apt-get update</code>:RUN命令是在上一层镜像(即ubuntu:14.04镜像)上运行apt-get update，所有对文件系统内容有更新的文件，都会保留于新构建的镜像层中，同时更新上一层镜像的json文件。</p>
</blockquote>
<h3 id="有关docker-build命令的事实："><a href="#有关docker-build命令的事实：" class="headerlink" title="有关docker build命令的事实："></a>有关docker build命令的事实：</h3><blockquote>
<p>1.镜像关系：对于命令<code>RUN apt-get update</code>的构建，一定会产生一个新镜像，新镜像的父镜像ID为ubuntu:14.04的镜像ID。</br><br>2.镜像json文件更新：运行命令<code>apt-get update</code>后产生新镜像，新镜像json文件仅仅更新ubuntu:14.04镜像json文件的cmd属性，其他如config属性均不会修改。</br><br>3.镜像层文件系统内容更新：运行<code>apt-get update</code>后，对于容器可读写层的内容更新，全部将被打包进新镜像的镜像层文件系统内容。</br></p>
</blockquote>
<h3 id="cache机制的核心："><a href="#cache机制的核心：" class="headerlink" title="cache机制的核心："></a>cache机制的核心：</h3><p>&emsp;&emsp;遍历本地所有镜像，发现镜像与即将构建出的镜像一致时，将找到的镜像作为cache镜像，复用cache镜像作为构建结果。</p>
<h3 id="cache机制注意事项"><a href="#cache机制注意事项" class="headerlink" title="cache机制注意事项"></a>cache机制注意事项</h3><p>&emsp;&emsp;cache机制很大程度上做到了镜像的复用，降低存储空间的同时，还大大缩短了构建时间。以下列出使用cache机制的几项注意事项：</p>
<h5 id="ADD命令与COPY命令"><a href="#ADD命令与COPY命令" class="headerlink" title="ADD命令与COPY命令"></a>ADD命令与COPY命令</h5><p>&emsp;&emsp;判断ADD命令或者COPY命令后紧接的文件是否发生变化，成为是否沿用cache的重要依据。Docker采取的策略是：获取Dockerfile下的内容，计算出一个唯一的hash值，若hash值未发生变化，则可以认为文件内容没有发生变化，可以使用cache机制；反之亦然。</p>
<h5 id="RUN命令存在外部依赖"><a href="#RUN命令存在外部依赖" class="headerlink" title="RUN命令存在外部依赖"></a>RUN命令存在外部依赖</h5><p>&emsp;&emsp;以命令<code>RUN apt-get update</code>为例，随着时间的推移，基于同一个基础镜像，一年前的<code>apt-get update</code>和一年后的<code>apt-get update</code>，由于软件源软件的更新，从而导致产生的镜像理论上应该不同。如果继续使用cache机制，将存在不满足用户需求的情况。</br><br>&emsp;&emsp;Docker采取的策略是：用户可以使用参数<code>--no-cache</code>确保获取最新的外部依赖。</br><br><code>docker build --no-cache -t=&quot;my_new_image&quot;</code></p>
<h5 id="树状镜像的关系"><a href="#树状镜像的关系" class="headerlink" title="树状镜像的关系"></a>树状镜像的关系</h5><p>&emsp;&emsp;树状的镜像关系决定了，一次新镜像的成功构建将导致后续的cache机制全部失效。</br><br>&emsp;&emsp;一旦产生一个新的镜像，意味着产生一个新的镜像ID。而当前宿主机环境中肯定不会存在一个镜像，此镜像ID的父镜像ID是新产生镜像的ID。这也是为什么，书写Dockerfile的时候，应该将更多静态的安装、配置命令尽可能地放在Dockerfile的较前位置。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;docker build的cache机制实现了镜像的复用，不仅节省了镜像的存储空间，也为镜像构建节省了大量的时间。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Git踩坑记录"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/11/Git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"
    >Git踩坑记录</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/04/11/Git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2022-04-11T02:56:03.000Z" itemprop="datePublished">2022-04-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Git踩坑记录"><a href="#Git踩坑记录" class="headerlink" title="Git踩坑记录"></a>Git踩坑记录</h1><p>前言：对git的操作使用好像一直停滞在：</p>
<blockquote>
<p>git pull</br><br>git add </br><br>git commit -m</br><br>git push</br></p>
</blockquote>
<p>这几大简单操作上，于是想着开个文档，记录一下其他学习内容，方便后续回顾。</br></p>
<h1 id="Git缓存区"><a href="#Git缓存区" class="headerlink" title="Git缓存区"></a>Git缓存区</h1><h6 id="git-add-files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事："><a href="#git-add-files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事：" class="headerlink" title="git add files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事："></a>git add files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事：</h6><blockquote>
<p>1.将本地文件的时间戳、长度，当前文档对象的id等信息保存到一个树形目录中去</br><br>2.将本地文件的内容做快照并保存到Git的对象库。</p>
</blockquote>
<p>综上所述，暂存区实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等），文件的内容并不存储其中，而是保存在Git对象库(.git/objects)中，文件索引建立了文件和对象库中对象实体之间的对应。</br><br>有关git暂存区的命令学习：</br></p>
<blockquote>
<p>1.<code>git rm --cached 文件名</code></br><br>这个命令不会删除物理文件，只是将已经add进缓存的文件删除。</br><br>2.<code>git rm --f 文件名</code></br><br>这个命令不仅将文件从缓存中删除，还会将物理文件删除，所以使用这个命令要非常谨慎。</br><br>3.若删除已经添加缓存的某一个目录下所有文件的话需要添加一个参数-r</br><br><code>git rm -r --cached 文件名</code></p>
</blockquote>
<h1 id="git-submodule用法整理"><a href="#git-submodule用法整理" class="headerlink" title="git submodule用法整理"></a>git submodule用法整理</h1><p>&emsp;&emsp;有submodule的仓库在当前目录会有个<code>.gitmodules</code>文件。记录path和url。这里表示项目引用子模块的关系</br><br>&emsp;&emsp;克隆带有子模块的项目后，需要初始化并拉取子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"># 上面两条命令的组合，一般直接使用组合命令</span><br><span class="line">git submodule update --init</span><br><span class="line">#可以加上--recursive拉取嵌套的子模块（子模块中还包含有其他子模块）</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;或者可以在clone代码时加上<code>--recurse-submodules</code>选项自动完成拉取</br><br><code>git clone --recurse-submodules &lt;main-project-repo-url&gt;</code><br>当需要更新子模块时，可以使用下面的指令，不用切目录就能进行手动更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote [submodule-path]</span><br></pre></td></tr></table></figure>
<p>上述所有命令都默认拉取的是master分支的代码，如果想拉取其他分支，则进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -f .gitmodules submodule.&lt;submodule-name&gt;.branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Linux入门学习指南"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/29/Linux%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"
    >Linux入门学习指南</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/03/29/Linux%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" class="article-date">
  <time datetime="2022-03-29T08:56:03.000Z" itemprop="datePublished">2022-03-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux入门学习"><a href="#Linux入门学习" class="headerlink" title="Linux入门学习"></a>Linux入门学习</h1><h2 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1.什么是操作系统"></a>1.什么是操作系统</h2><p>&emsp;&emsp;操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能：如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如：</br></p>
<blockquote>
<p>(1)文件系统：提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。</br><br>(2)设备驱动程序：提供连接计算机每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。（不了解硬件结构，但对如何操作底层硬件是透明的。）</br><br>(3)用户接口：操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的Windows图形界面，可以理解为一种用户与操作系统交互的方式。</br><br>(4)系统服务程序：当计算机启动时，会自启许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。</p>
</blockquote>
<h2 id="2-Linux介绍"><a href="#2-Linux介绍" class="headerlink" title="2.Linux介绍"></a>2.Linux介绍</h2><p>&emsp;&emsp;Linux系统可以抽象为三个层次：①底层是UNIX/Linux操作系统，即系统内核(Kernel)；②中间层是shell层，即命令解释层。③高层：应用层</br></p>
<blockquote>
<p>(1)内核层：内核层是UNIX/Linux系统的核心与基础，它直接附着在硬件平台上，控制和管理系统内各种资源(硬件资源和软件资源)，有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</br><br>(2)Shell层：Shell层是与用户直接交互的界面。用户可以在提示符下输入命令行，由Shell解释执行并输出相应结果或者有关信息，所以我们也把Shell称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</br><br>(3)应用层：应用层提供基于X Window协议的图形环境</p>
</blockquote>
<h2 id="3-Linux相比Windows的优点"><a href="#3-Linux相比Windows的优点" class="headerlink" title="3.Linux相比Windows的优点"></a>3.Linux相比Windows的优点</h2><blockquote>
<p>(1)大量的可用软件及免费软件</br><br>(2)良好的可移植性和灵活性</br><br>(3)优良的稳定性和安全性</br><br>(4)支持几乎所有的网络协议及开发语言</br></p>
</blockquote>
<h2 id="4-常见的Linux发行版本"><a href="#4-常见的Linux发行版本" class="headerlink" title="4.常见的Linux发行版本"></a>4.常见的Linux发行版本</h2><p>&emsp;&emsp;说明：林纳斯托瓦刺开发的Linux是一个内核版本。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件。</br><br>&emsp;&emsp;现在市面上常见的Linux系统不如说是：“以Linux为核心的操作系统软件包”。</br></p>
<blockquote>
<p>red hat</br><br>Ubuntu:桌面系统好</br><br>SuSE linux：实现了较好地与Windows的交互。</br><br>Gentoo linux：快速、设计干净且有弹性。</br></p>
</blockquote>
<h2 id="5-Linux远程管理协议"><a href="#5-Linux远程管理协议" class="headerlink" title="5.Linux远程管理协议"></a>5.Linux远程管理协议</h2><h3 id="常用的远程管理协议有以下四种："><a href="#常用的远程管理协议有以下四种：" class="headerlink" title="常用的远程管理协议有以下四种："></a>常用的远程管理协议有以下四种：</h3><blockquote>
<p>(1)RDP(remote desktop protocol)：远程桌面协议，Windows系统中的远程桌面管理就基于该协议</br><br>(2)RFB(remote framebuffer)图形化远程管理协议，VNC远程管理工具基于此协议。</br><br>(3)Telnet 命令行界面远程管理程序，几乎所有操作协同都默认支持该协议。此协议的特点是：数据传送采用明文方式，不对传输数据进行加密。</br><br>(4)SSH(Secure Shell)：命令行界面远程管理协议，几乎所有操作系统都默认支持该协议。区别于Telnet，该协议在数据传送时会对数据进行加密并压缩，因此以该协议进行数据传送既安全又快速。(其基本代替了SSH)</br></p>
</blockquote>
<h3 id="linux远程管理软件"><a href="#linux远程管理软件" class="headerlink" title="linux远程管理软件"></a>linux远程管理软件</h3><blockquote>
<p>(1)基于VNC，图形远程管理软件。</br><br>(2)基于SSH协议的命令行操作管理。</br><br>(3)类似Webmin的基于浏览器的管理，该种方式下管理功能有限。</br></p>
</blockquote>
<h2 id="6-Linux软件包"><a href="#6-Linux软件包" class="headerlink" title="6.Linux软件包"></a>6.Linux软件包</h2><p>&emsp;&emsp;Linux软件包几乎都是经GPL授权的。这意味着如果你具备修改软件源代码的能力，可以随意地修改软件源代码。</br></p>
<h4 id="Linux源码包"><a href="#Linux源码包" class="headerlink" title="Linux源码包"></a>Linux源码包</h4><p>源码包的安装需要很长时间的编译过程</br><br>例：MySQL安装包的大小只有23M，但其安装却需要30分钟左右的时间</p>
<h4 id="Linux二进制包"><a href="#Linux二进制包" class="headerlink" title="Linux二进制包"></a>Linux二进制包</h4><p>二进制包在发布之前就已经完成了编译的工作。目前主要有2大主流的二进制包管理系统：</br></p>
<blockquote>
<p>1.RPM包管理系统：功能强大，安装、升级、查询和卸载非常简单方便。因此很多Linux发行版都默认采用此机制做为软件安装包的管理方式。</br><br>2.DPKG包管理方式：由Debian Linux所开发的软件包管理方式。主要应用在Debian和Ubuntu中</p>
</blockquote>
<h4 id="源码包VSRPM二进制包"><a href="#源码包VSRPM二进制包" class="headerlink" title="源码包VSRPM二进制包"></a>源码包VSRPM二进制包</h4><p>源码包一般包含多个文件，为了方便发布，一般会对源码包做打包处理。Linux中最常用的打包格式是”tar.gz”。因此源码包也会被称为tarball。</br><br>源码包需要我们去软件官方网站进行下载，其一般包含如下内容：</br></p>
<blockquote>
<p>1.源代码文件</br><br>2.配置和检测程序（如configure或config）</br><br>3.软件安装说明和软件说明(如INSTALL或README)</br></p>
</blockquote>
<p>总得来说，使用源码包安装软件具有以下好处：</br></p>
<blockquote>
<p>1.开源，能力足够的话可以自行修改源码。</br><br>2.可以自由选择所需的功能。</br><br>3.软件采用编译安装的方式。更适合自己的系统、更加稳定、效率也更高。</br></p>
</blockquote>
<p>但同时，使用源码包安装软件也存在以下几点不足：</br></p>
<blockquote>
<p>1.安装过程步骤较多、容易出错。</br><br>2.编译时间较长导致的安装时间较长。</br><br>3.因为软件是编译安装的，编译过程一旦出错，新手很难解决。</br></p>
</blockquote>
<p>使用RPM包安装软件具有以下好处：</br></p>
<blockquote>
<p>1.包管理系统简单，只需要几个命令就可以实现包的安装、升级、查询和卸载。</br></p>
</blockquote>
<p>使用RPM包安装软件存在以下不足：</br></p>
<blockquote>
<p>1.经过编译，不能再看到源代码。</br><br>2.功能选择不如源码包灵活。</br><br>3.依赖性有可能非常强。</br></p>
</blockquote>
<h2 id="7-yum源及其配置"><a href="#7-yum源及其配置" class="headerlink" title="7.yum源及其配置"></a>7.yum源及其配置</h2><p>&emsp;&emsp;yum，全称“Yellow dog Updater, Modified”,是一个专门为了解决包的依赖关系而存在的软件包管理器。yum是改进型的RPM软件管理器，它很好地解决了RPM软件包依赖问题。</br><br>&emsp;&emsp;当管理员使用yum安装RPM包时，yum会先从服务器端下载RPM包的依赖文件</p>
<h2 id="8-Linux文件系统管理"><a href="#8-Linux文件系统管理" class="headerlink" title="8.Linux文件系统管理"></a>8.Linux文件系统管理</h2><h4 id="硬盘结构详解"><a href="#硬盘结构详解" class="headerlink" title="硬盘结构详解"></a>硬盘结构详解</h4><p>硬盘是计算机的主要外部存储设备，从存储数据的介质上来区分，硬盘可分为机械硬盘和固态硬盘，具体区别就不在此处赘述了。</br></p>
<h4 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h4><p>用于显示Linux系统中各文件系统的硬盘使用情况：包括文件系统所在硬盘分区的总容量、已使用容量、剩余容量等。采用df命令，显示出的各列信息的含义分别是：</p>
<blockquote>
<p>1.Filesystem: 表示该文件系统位于哪个分区，因此该列显示的是设备名称。</br><br>2.1K-blocks：此列表示文件系统的总大小，默认以KB为单位。</br><br>3.Used: 表示用掉的硬盘空间的大小。</br><br>4.Available：表示剩余的硬盘空间大小。</br><br>5.Use%：硬盘空间使用率。容量不足时，会严重影响系统的正常运行。</br><br>6.Mounted on：文件系统的挂载点，也就是硬盘挂载的目录位置</br></p>
</blockquote>
<h4 id="挂载Linux系统外的文件"><a href="#挂载Linux系统外的文件" class="headerlink" title="挂载Linux系统外的文件"></a>挂载Linux系统外的文件</h4><p>挂载的定义：将硬件设备的文件系统和Linux系统中的文件系统，通过指定目录（作为挂载点）进行关联。而要将文件挂载到Linux系统上，需要使用mount挂载命令。</br></p>
<h4 id="Linux物理内存与虚拟内存"><a href="#Linux物理内存与虚拟内存" class="headerlink" title="Linux物理内存与虚拟内存"></a>Linux物理内存与虚拟内存</h4><blockquote>
<p>1.物理内存就是系统硬件提供的内存的大小</br><br>2.虚拟内存：用磁盘虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间（swap空间）</br></p>
</blockquote>
<p>Linux会在物理内存不足时，使用交换分区的虚拟内存。</br><br>Linux的内存管理采取的是分页存储机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据库自动交换到虚拟内存中，而将经常使用的信息保留在物理内存。</p>
<h2 id="9-Linux进程管理"><a href="#9-Linux进程管理" class="headerlink" title="9.Linux进程管理"></a>9.Linux进程管理</h2><p>&emsp;&emsp;windows中的进程管理工具：任务管理器。</br><br>&emsp;&emsp;通常，使用任务管理器，主要有如下三个目的：</br></p>
<blockquote>
<p>(1)利用“应用程序”和“进程”标签来查看系统中到底运行了哪些程序和进程。</br><br>(2)利用“性能”和“用户”标签来判断服务器的健康状态。</br><br>(3)在“应用程序”和“进程”标签中强制终止任务和进程。</br></p>
</blockquote>
<h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>&emsp;&emsp;进程是正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源.</br><br>&emsp;&emsp;这也就是说，在操作系统中，所有可以执行的程序和命令都会产生进程。有的进程寿命很短。但还有一些进程，比如httpd进程，启动之后就会一直驻留在系统当中，我们把这样的进程称为<code>常驻内存进程</code>。</br></p>
<h3 id="进程的作用"><a href="#进程的作用" class="headerlink" title="进程的作用"></a>进程的作用</h3><p>&emsp;&emsp;杀死进程（强制终止进程）不过是进程管理工作中最不常用的手段，因为每个进程都有自己正确的结束方法，而杀死进程是在正常方法已经失效的情况下的后备手段。</br></p>
<blockquote>
<p>1.判断服务器的健康状态</br><br>如果当前服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。</br><br>2.查看系统中的所有进程。</br><br>3.杀死进程</br><br>一般情况下，当需要停止服务时，会通过正确关闭命令来停止服务(如apache服务可以通过service httpd stop命令来关闭)。如果正确终止进程的命令失效，才会考虑使用kill命令杀死进程</p>
</blockquote>
<h3 id="Linux启动进程的方式"><a href="#Linux启动进程的方式" class="headerlink" title="Linux启动进程的方式"></a>Linux启动进程的方式</h3><p>在Linux系统中，任务可以被配置在指定的时间、日期或者系统平均负载量低于指定值时自动启动。</p>
<h3 id="缓冲和缓存的区别"><a href="#缓冲和缓存的区别" class="headerlink" title="缓冲和缓存的区别"></a>缓冲和缓存的区别</h3><blockquote>
<p>缓存(cache)是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而去缓存中读取。</br><br>缓冲(buffer)是在向硬盘写入数据时，先把数据放入缓冲区，然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</br><br>简单来说，cache时用来加速数据从硬盘中“读取”的，而buffer是用来加速数据写入硬盘的。</p>
</blockquote>
<h2 id="10-一些小众命令的学习"><a href="#10-一些小众命令的学习" class="headerlink" title="10.一些小众命令的学习"></a>10.一些小众命令的学习</h2><h3 id="1-tailf"><a href="#1-tailf" class="headerlink" title="(1) tailf"></a>(1) tailf</h3><p>在屏幕上显示指定文件的末尾若干行内容，通常用于日志文件的跟踪输出</p>
<h5 id="tailf与tail-f的区别："><a href="#tailf与tail-f的区别：" class="headerlink" title="tailf与tail -f的区别："></a>tailf与tail -f的区别：</h5><blockquote>
<p>1.tailf总是从文件开头一点一点的读， 而tail -f则是从文件尾部开始读。</br><br>2.tailf check文件增长时，使用的是文件名，用stat系统调用；而tail -f则使用的是已打开的文件描述符；注：tail也可以做到类似跟踪文件名的效果；但是tail总是使用fstat系统调用，而非stat系统调用。结果就是：默认情况下，当tail的文件被偷偷删除时，tail是不知道的，而tailf是知道的。</p>
</blockquote>
<h5 id="补充说明：stat、lstat和fstat系统调用的区别"><a href="#补充说明：stat、lstat和fstat系统调用的区别" class="headerlink" title="补充说明：stat、lstat和fstat系统调用的区别"></a>补充说明：stat、lstat和fstat系统调用的区别</h5><p>&emsp;&emsp;stat系统调用系列包括了：fstat、stat和lstat，它们都是用来返回“相关文件状态信息”的，三者的不同之处在于设定源文件的方式不同；</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fstat(int fields, struct stst *buf);</span><br><span class="line">int stat(const char *path, struct stat *buf)</span><br><span class="line">int lstat(const char *path, struct stat *buf)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.fstat区别于另外两个系统调用的地方在于：fstat系统调用接受的是一个“文件描述符”， 而另外两个则直接接受“文件全路径”。</br><br>2.stat与lstat的区别在于：当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；而stat返回的是该链接指向的文件的信息。</br></p>
</blockquote>
<h5 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tailf logfile #动态跟踪日志文件logfile，最初的时候打印文件的最后十行的内容</span><br></pre></td></tr></table></figure>
<h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n, --lines NUMBER #输出最后行数</span><br><span class="line">-V, --version #输出版本信息并退出</span><br><span class="line">-h, --help #显示帮助并退出</span><br></pre></td></tr></table></figure>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tailf -n 5 logfile.log #显示文件最后五行的内容</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-用Python编写Hadoop MapReduce程序 - 副本"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/28/%E7%94%A8Python%E7%BC%96%E5%86%99Hadoop%20MapReduce%E7%A8%8B%E5%BA%8F%20-%20%E5%89%AF%E6%9C%AC/"
    >用Python编写Hadoop MapReduce程序</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/03/28/%E7%94%A8Python%E7%BC%96%E5%86%99Hadoop%20MapReduce%E7%A8%8B%E5%BA%8F%20-%20%E5%89%AF%E6%9C%AC/" class="article-date">
  <time datetime="2022-03-28T08:05:03.000Z" itemprop="datePublished">2022-03-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="用Python编写Hadoop-MapReduce程序"><a href="#用Python编写Hadoop-MapReduce程序" class="headerlink" title="用Python编写Hadoop MapReduce程序"></a>用Python编写Hadoop MapReduce程序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;尽管Hadoop框架是用Java编写的，但Hadoop程序不需要用Java编写。采用Java streaming实现用python实现mapreduce过程。</p>
<h4 id="一-安装java和hadoop集群"><a href="#一-安装java和hadoop集群" class="headerlink" title="一.安装java和hadoop集群"></a>一.安装java和hadoop集群</h4><p>1.查看安装路径</br><br>java version查看java版本</br><br>which java查看java安装路径</br><br>ls -lrt /usr/bin/java</br><br>ls -lrt /etc/alternatives/java</br><br>最后一条指令执行完，复制记录/bin/java前面的路径。</br><br>2.配置jdk环境变量</br><br>export JAVA_HOME=复制路径</br><br>export PATH=$JAVA_HOME/bin:$PATH</br><br>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</br><br>3.激活配置内容</br><br>source /etc/profile</br></p>
<h4 id="二-编写MapReduce代码"><a href="#二-编写MapReduce代码" class="headerlink" title="二.编写MapReduce代码"></a>二.编写MapReduce代码</h4><p>mapper.py文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># input comes from STDIN (standard input)</span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    # remove leading and trailing whitespace</span><br><span class="line">    line &#x3D; line.strip()</span><br><span class="line">    # split the line into words</span><br><span class="line">    words &#x3D; line.split()</span><br><span class="line">    # increase counters</span><br><span class="line">    for word in words:</span><br><span class="line">        # write the results to STDOUT (standard output);</span><br><span class="line">        # what we output here will be the input for the</span><br><span class="line">        # Reduce step, i.e. the input for reducer.py</span><br><span class="line">        #</span><br><span class="line">        # tab-delimited; the trivial word count is 1</span><br><span class="line">        print &#39;%s\t%s&#39; % (word, 1)</span><br></pre></td></tr></table></figure>
<p>reducer.py文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">&quot;&quot;&quot;reducer.py&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from operator import itemgetter</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">current_word &#x3D; None</span><br><span class="line">current_count &#x3D; 0</span><br><span class="line">word &#x3D; None</span><br><span class="line"></span><br><span class="line"># input comes from STDIN</span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    # remove leading and trailing whitespace</span><br><span class="line">    line &#x3D; line.strip()</span><br><span class="line"></span><br><span class="line">    # parse the input we got from mapper.py</span><br><span class="line">    word, count &#x3D; line.split(&#39;\t&#39;, 1)</span><br><span class="line"></span><br><span class="line">    # convert count (currently a string) to int</span><br><span class="line">    try:</span><br><span class="line">        count &#x3D; int(count)</span><br><span class="line">    except ValueError:</span><br><span class="line">        # count was not a number, so silently</span><br><span class="line">        # ignore&#x2F;discard this line</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    # this IF-switch only works because Hadoop sorts map output</span><br><span class="line">    # by key (here: word) before it is passed to the reducer</span><br><span class="line">    if current_word &#x3D;&#x3D; word:</span><br><span class="line">        current_count +&#x3D; count</span><br><span class="line">    else:</span><br><span class="line">        if current_word:</span><br><span class="line">            # write result to STDOUT</span><br><span class="line">            print &#39;%s\t%s&#39; % (current_word, current_count)</span><br><span class="line">        current_count &#x3D; count</span><br><span class="line">        current_word &#x3D; word</span><br><span class="line"></span><br><span class="line"># do not forget to output the last word if needed!</span><br><span class="line">if current_word &#x3D;&#x3D; word:</span><br><span class="line">    print &#39;%s\t%s&#39; % (current_word, current_count)</span><br></pre></td></tr></table></figure>
<p>注意应给这两个文件添加执行权限：</br><br>chmod u+x xxx.py</p>
<h4 id="运行与实践"><a href="#运行与实践" class="headerlink" title="运行与实践"></a>运行与实践</h4><h5 id="1-将本地数据复制到HDFS"><a href="#1-将本地数据复制到HDFS" class="headerlink" title="1.将本地数据复制到HDFS"></a>1.将本地数据复制到HDFS</h5><h5 id="2-运行MapReduce作业"><a href="#2-运行MapReduce作业" class="headerlink" title="2.运行MapReduce作业"></a>2.运行MapReduce作业</h5> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-jenkins自动化部署学习过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/12/jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"
    >jenkins自动化部署学习过程</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/03/12/jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2022-03-12T08:23:52.000Z" itemprop="datePublished">2022-03-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Jenkins自动化部署学习记录"><a href="#Jenkins自动化部署学习记录" class="headerlink" title="Jenkins自动化部署学习记录"></a>Jenkins自动化部署学习记录</h1><h1 id="1-安装jenkins"><a href="#1-安装jenkins" class="headerlink" title="1.安装jenkins"></a>1.安装jenkins</h1><p>&emsp;&emsp;这部分踩了不少的坑，网上的诸多方法（以使用apt-get 命令行安装方式为主），对Ubuntu20.04的适用性均一般，最佳的方法还是来自官网(<a target="_blank" rel="noopener" href="https://www.jenkins.io/zh/doc/book/installing/):%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8CJenkins%E7%9A%84WAR%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E3%80%82">https://www.jenkins.io/zh/doc/book/installing/):下载并运行Jenkins的WAR文件版本。</a></br><br>(1)将最新的稳定Jenkins WAR包下载到计算机的相应目录上。</br><br>(2)在下载的目录内打开一个终端/命令提示符窗口</br><br>(3)运行命令java -jar jenkins.war</br><br>(4)浏览<a href="http://localhost:8080并等到jenkins相关页面出现。">http://localhost:8080并等到jenkins相关页面出现。</a></br><br>(5)安装后设置向导(详情不在此处赘述了，参考官网即可)</br></p>
<h1 id="2-有关pipeline官方文档学习记录"><a href="#2-有关pipeline官方文档学习记录" class="headerlink" title="2.有关pipeline官方文档学习记录"></a>2.有关pipeline官方文档学习记录</h1><p>&emsp;&emsp;持续交付（CD）：pipeline可以将软件从版本控制直接获取到用户和客户的<code>流程的自动表达。</code>这个过程的主要工作：以可靠且可重复的方式构建软件，以及通过测试和部署的多个阶段推进构建的软件。</br><br>&emsp;&emsp;Jenkins Pipeline的定义被写入一个文本文件（称为Jenkinsfile）。JenkinsFile可以提交到项目的源代码管理存储库中。<code>管道即代码</code>。我们要将CD管道视为要像其他任何代码一样进行版本控制和审阅的应用程序的一部分。</br><br>&emsp;&emsp;使用JenkinsFile进行源代码管理的好处有以下几条：</br><br>&emsp;&emsp;(1)自动为所有分支和拉取请求创建管道生成过程。</br><br>&emsp;&emsp;(2)管道上的代码审查/迭代(已经剩余的源代码)</br><br>&emsp;&emsp;(3)管道的审核跟踪。</br><br>&emsp;&emsp;(4)单一事实来源，可由项目的多个成员查看和编辑。</br></p>
<h1 id="3-Jenkins-Pipeline自动化部署项目"><a href="#3-Jenkins-Pipeline自动化部署项目" class="headerlink" title="3.Jenkins+Pipeline自动化部署项目"></a>3.Jenkins+Pipeline自动化部署项目</h1><p>&emsp;&emsp;配置拉取代码的地址(一般选择git/github)</p>
<h3 id="1-创建JenkinsFile：包含基本的三阶段"><a href="#1-创建JenkinsFile：包含基本的三阶段" class="headerlink" title="(1)创建JenkinsFile：包含基本的三阶段"></a>(1)创建JenkinsFile：包含基本的三阶段</h3><p>点击“流水线语法”，编辑pipeline脚本</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Jenkinsfile(Declarative Pipeline)</span><br><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    </span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&#39;Build&#39;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo &#39;Building..&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#39;Test&#39;)&#123;</span><br><span class="line">            step&#123;</span><br><span class="line">                echo &#39;Testing..&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#39;Deploy&#39;)&#123;</span><br><span class="line">            step&#123;</span><br><span class="line">                echo &#39;Deploying..&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①build阶段：将源代码组装、编译、打包</br><br>linux的build阶段举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jenkinsfile(Declarative Pipeline)</span><br><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&#39;Build&#39;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &#39;make&#39;</span><br><span class="line">                archiveArtifacts artificates: &#39;**&#x2F;target&#x2F;*.jar&#39;, fingerprint:true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该sh步骤调用该make命令，只有在命令返回零退出代码时才会继续。任何非零退出代码将造成Pipeline失败。</br><br>②测试：以Junit插件提供的步骤为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jenkinsfile(Declarative Pepeline)</span><br><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&#39;Test&#39;)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &#39;make check || true&#39;</span><br><span class="line">                junit &#39;**&#x2F;target&#x2F;*.xml&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1&gt; 确保sh步骤始终看到零退出代码，使得Junit步骤有机会捕获和处理测试报告。</br><br>2&gt; junit捕获并关联与包含pattern匹配的Junit XMl文件</br><br>③部署：将代码推送到生产系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Jenkinsfile(Declarative Pipeline)</span><br><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&#39;Deploy&#39;)&#123;</span><br><span class="line">            when&#123;</span><br><span class="line">                expression&#123;</span><br><span class="line">                    currentBuild.result&#x3D;null || currentBuild.result&#x3D;&#x3D;&#39;SUCCESS&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps&#123;</span><br><span class="line">                sh &#39;make publish&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jenkins/" rel="tag">Jenkins</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Django中ImageField的使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/28/Django%E4%B8%ADImageField%E7%9A%84%E4%BD%BF%E7%94%A8/"
    >Django中ImageField的使用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/09/28/Django%E4%B8%ADImageField%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2021-09-28T02:51:52.000Z" itemprop="datePublished">2021-09-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Django-ImageField学习笔记"><a href="#Django-ImageField学习笔记" class="headerlink" title="Django ImageField学习笔记"></a>Django ImageField学习笔记</h1><h2 id="1-Django-的静态文件管理机制"><a href="#1-Django-的静态文件管理机制" class="headerlink" title="1.Django 的静态文件管理机制"></a>1.Django 的静态文件管理机制</h2><blockquote>
<p>前言：网站通常需要为用户提供类似图片、JavaScript或者CSS的额外文件服务。在Django中，统一将他们称为“静态文件”。这一章节将重点介绍如何为这些静态文件提供服务。且如果要使用ImageField，必须提前安装Pillow库</p>
</blockquote>
<h4 id="1-1配置静态文件"><a href="#1-1配置静态文件" class="headerlink" title="1.1配置静态文件"></a>1.1配置静态文件</h4><p>(1)确保INSTALLED_APPS中包含了django.contrib.staticfiles.</br><br>(2)在配置文件中，定义STATIC_URL，例子：</br><br>STATIC_URL = ‘/static/‘</br><br>(3)在前端模板中，用static模板标签，基于配置给定的相对路径构建URL。</br><br>(4)开发期间，可以用django.views.static.serve()视图为用户上传的媒体文件提供服务。</p>
<blockquote>
<p>默认情况下，Django使用MEDIA_ROOT和MEDIA_URL设置本地存储。</p>
</blockquote>
<h2 id="2-有关ImageField和FileFiled的讨论。"><a href="#2-有关ImageField和FileFiled的讨论。" class="headerlink" title="2.有关ImageField和FileFiled的讨论。"></a>2.有关ImageField和FileFiled的讨论。</h2><blockquote>
<p>当我们使用这两个字段时，Django提供了一组处理文件的API</p>
</blockquote>
<h4 id="2-1-ImageFiled拥有的方法和属性-其拥有File类型的所有属性和方法，其内容可在官方文档中阅读python的源码"><a href="#2-1-ImageFiled拥有的方法和属性-其拥有File类型的所有属性和方法，其内容可在官方文档中阅读python的源码" class="headerlink" title="2.1 ImageFiled拥有的方法和属性(其拥有File类型的所有属性和方法，其内容可在官方文档中阅读python的源码)"></a>2.1 ImageFiled拥有的方法和属性(其拥有File类型的所有属性和方法，其内容可在官方文档中阅读python的源码)</h4><blockquote>
<p>(1)对象类型：<br>&lt;ImageFieldFile: cars/chevy.jpg&gt;</br><br>(2)name属性</br><br>(3)path属性</br><br>(4)url属性</p>
</blockquote>
<h4 id="2-2-Django文件存储"><a href="#2-2-Django文件存储" class="headerlink" title="2.2 Django文件存储"></a>2.2 Django文件存储</h4><blockquote>
<p>Django的默认文件存储通过DEFAULT_FILE_STORAGE配置。如果设计者没有显式地提供存储系统，我们将使用默认配置</p>
</blockquote>
<p>upload_to=’photos’，这句设置表示上传的文件会存放在<code>$MEDIA_ROOT/photos</code>下面</p>
<h4 id="2-3-ImageFiled对象使用"><a href="#2-3-ImageFiled对象使用" class="headerlink" title="2.3 ImageFiled对象使用"></a>2.3 ImageFiled对象使用</h4><p>可以去阅读ImageFiled的源代码</br><br>在django/db/models/fields/files.py文件中</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-五月总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/05/05/%E4%BA%94%E6%9C%88%E6%80%BB%E7%BB%93/"
    >五月总结</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/05/05/%E4%BA%94%E6%9C%88%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-05-05T01:56:03.000Z" itemprop="datePublished">2021-05-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="人生不要留在22岁"><a href="#人生不要留在22岁" class="headerlink" title="人生不要留在22岁"></a>人生不要留在22岁</h1><p>&emsp;&emsp;回校后渐渐不知在忙碌些什么，读研的事也算尘埃落定，倒没什么特别的喜悦，不过是勉强没有辜负曾经蛰伏的日子罢了。听到朋友们的诸多去向，为他们感到开心的同时却又不免暗自感叹，以后相聚的日子怕是屈指可数了吧。</br><br>&emsp;&emsp;五一长假的某个午睡一直延续到了日落时分，醒来后望着窗外不算热烈的落日余晖，宿舍里空无一人，反倒是产生了一种久违的剥离感：为这留不住的青春岁月。大学四年真是人生最宝贵的一段时间，回想起来我在短暂地体验了青春后，就主动或被动地陷入了内卷之中，如今想来倒是有些蹉跎了时光，不过鱼和熊掌不可兼得，三个月换来研究生的入学资格，倒也能算是求仁得仁了。离别前夕总是令人伤感的，我怕如今宿舍之间相隔的短短几百米，未来要长久地变成无法逾越的几百里。</br><br>&emsp;&emsp;说起来虽然感慨难免，倘若让我重过一遍大学四年，我内心深处大抵是不愿意的，也许是有些日子过于黑暗痛苦，再也不想从头来过。也许是我做到了活在当下，对每个人都问心无愧。毕竟，人生这条路，总是要朝前看的。</br></p>
<blockquote>
<p>如果额头终将刻上皱纹，你只能做到不让皱纹刻在你的心上。</br><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——电影《中国合伙人》</p>
</blockquote>
<p>&emsp;&emsp;本来这篇文章的题目想起作“不要死在22岁”，斟酌下却又觉得“死”这样的字眼不该随意出现在我这个21岁的年轻人之口，实在是最近思考的太多，看着曾经好友即将实现从校园到社会的跨越，我是有些害怕了。</br><br>&emsp;&emsp;我常常说：“每个人都有自己的路要走，每条路都是很好的路。”也在说这句话时信以为真。但朋友新近带来的消息却让我大跌眼镜，曾经一起上课一起爆肝考试周，如今却仅仅是因为“没有考上研”这件事，我悲哀的预感到我们要走截然不同的的两条路。朋友打算回家找工作，哪怕我们的专业难以在那个城市有好的发展。朋友的父母想让她回家看店，哪怕她有了这么高的学历。大抵是因为妈妈从小鼓励我要往外走，去勇敢选择自己的人生。我才对这样的选择如此震惊，此时此刻又难以说哪种选择才是正确的，也许这个问题一辈子都得不到解答，我只是难以派遣心中的震撼感罢了。</br><br>&emsp;&emsp;时间差不多到了，在这里草草收尾罢，我也有自己的路要走，有自己的山岭要去翻阅。写下这篇短记是希望自己的心能永不变老，永远保持对事物的好奇心，别让我的青春永远留在22岁了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" rel="tag">碎碎念</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> twilight2017
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="瑟兰迪尔"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E8%AF%BB%E4%B9%A6">读书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/travels">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E9%9A%8F%E7%AC%94">随笔</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>