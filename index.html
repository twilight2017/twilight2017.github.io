<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     瑟兰迪尔
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">瑟兰迪尔</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['竹杖芒鞋轻胜马', '谁怕？', '一蓑烟雨任平生'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: false
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-实现Dockerfile，打包python3.9的编译过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/08/%E5%AE%9E%E7%8E%B0Dockerfile%EF%BC%8C%E6%89%93%E5%8C%85python3.9%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"
    >实现Dockerfile，打包python3.9的编译过程</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/09/08/%E5%AE%9E%E7%8E%B0Dockerfile%EF%BC%8C%E6%89%93%E5%8C%85python3.9%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2022-09-08T07:51:52.000Z" itemprop="datePublished">2022-09-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="实现Dockerfile，打包python3-9的编译过程"><a href="#实现Dockerfile，打包python3-9的编译过程" class="headerlink" title="实现Dockerfile，打包python3.9的编译过程"></a>实现Dockerfile，打包python3.9的编译过程</h1><h2 id="1-什么是Dockerfile"><a href="#1-什么是Dockerfile" class="headerlink" title="1.什么是Dockerfile"></a>1.什么是Dockerfile</h2><p>Dockerfile是一个文本文件，其内包含了多条指令，每一条指令构建一层。因此每一条指令的内容，就是描述该层应当如何构建。有了Dockerfile之后，我们需要构建自己的额外需求时，只需要在Dockerfile上添加或者修改指令，重新生成镜像即可，省去了敲命令的麻烦。</p>
<h2 id="2-Dockerfile文件格式"><a href="#2-Dockerfile文件格式" class="headerlink" title="2.Dockerfile文件格式"></a>2.Dockerfile文件格式</h2><p>Dockerfile分为四部分：</p>
<blockquote>
<p>基础镜像信息</br><br>维护者信息</br><br>镜像操作命令</br><br>容器启动执行命令</br></p>
</blockquote>
<p>值得注意的是，Dockerfile的指令每执行一次都会在docker上新建一层。所以过多无意义的层，会造成镜像膨胀。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<p>以上执行方式会创建层镜像，推荐简化为以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="3-构建docker镜像相关命令"><a href="#3-构建docker镜像相关命令" class="headerlink" title="3.构建docker镜像相关命令"></a>3.构建docker镜像相关命令</h2><p>docker build命令会根据Dockerfile文件已经上下文构建新的Docker镜像。构建上下文是指Dockerfile所在的本地路径或者一个url<br>使用当前目录的Dockerfile构建镜像，指定标签。</br><br>上下文路径是指docker在构建镜像，若想使用本机的文件，docker build命令获得这个路径后，会将路径下所有文件进行打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;镜像名&gt;:&lt;tag&gt; .</span><br></pre></td></tr></table></figure>
<p>根据指定镜像构建容器，并在后台运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name &lt;容器的指定名称&gt; -d -i -t &lt;镜像名&gt;:&lt;tag&gt; &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h2 id="4-Dockerfile中的层机制"><a href="#4-Dockerfile中的层机制" class="headerlink" title="4.Dockerfile中的层机制"></a>4.Dockerfile中的层机制</h2><p>Dockerfile中每个<code>RUN</code>命令都会在新的容器中运行，以下列代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN cd cosign-master</span><br><span class="line">RUN autoconf</span><br><span class="line">RUN .&#x2F;configure --enable-apache2&#x3D;&#96;which apxs&#96;</span><br></pre></td></tr></table></figure>
<p>这三条命令会在三个独立的容器中运行，所以对下一个容器,<code>cd cosign-master</code>命令没有改变工作目录。</br><br>生成镜像有如下两条建议：</br></p>
<blockquote>
<p>1.一条指令应该执行多条命令，来减少最终镜像的层数，因为每条指令都会生成新的一层。</br><br>2.应清理中间文件或软件来减小最终镜像的大小。<br>对于上面的代码，推荐更换成如下形式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUN cd cosign-master \</span><br><span class="line">    &amp;&amp; autoconf \</span><br><span class="line">    &amp;&amp; .&#x2F;configure --enable-apache2&#x3D;&#96;which apxs&#96; \</span><br><span class="line">    &amp;&amp; make \</span><br><span class="line">    &amp;&amp; make install</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python接口自动化测试实战教程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/08/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/"
    >Python接口自动化测试实战教程</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/08/08/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/" class="article-date">
  <time datetime="2022-08-08T09:06:03.000Z" itemprop="datePublished">2022-08-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Python接口自动化测试实战教程"><a href="#Python接口自动化测试实战教程" class="headerlink" title="Python接口自动化测试实战教程"></a>Python接口自动化测试实战教程</h1><h2 id="一-pytest用例管理框架"><a href="#一-pytest用例管理框架" class="headerlink" title="一.pytest用例管理框架"></a>一.pytest用例管理框架</h2><h3 id="pyest默认规则："><a href="#pyest默认规则：" class="headerlink" title="pyest默认规则："></a>pyest默认规则：</h3><p>1.py文件必须以test_开头或者_test结尾</br><br>2.类名必须以Test开头</br><br>3.测试用例必须以test_开头<br></p>
<h3 id="pytest用例管理框架的作用？"><a href="#pytest用例管理框架的作用？" class="headerlink" title="pytest用例管理框架的作用？"></a>pytest用例管理框架的作用？</h3><p>1.发现测试用例：从多个py文件中通过默认的规则去找测试用例。</br><br>2.执行测试用例：顺序和条件。</br><br>3.判断测试结果：断言。</br><br>4.生成测试报告：html，allure。</br><br>5.python:unittest或pytest。</br><br>6.java:Junit,testong.</p>
<h2 id="二-pytest全局观"><a href="#二-pytest全局观" class="headerlink" title="二.pytest全局观"></a>二.pytest全局观</h2><h6 id="1-它可以和所有自动化测试工具selenium-requests结合实现web自动化，接口自动化以及app自动化。"><a href="#1-它可以和所有自动化测试工具selenium-requests结合实现web自动化，接口自动化以及app自动化。" class="headerlink" title="1.它可以和所有自动化测试工具selenium, requests结合实现web自动化，接口自动化以及app自动化。"></a>1.它可以和所有自动化测试工具selenium, requests结合实现web自动化，接口自动化以及app自动化。</h6><h6 id="2-跳过用例以及失败用例重跑"><a href="#2-跳过用例以及失败用例重跑" class="headerlink" title="2.跳过用例以及失败用例重跑"></a>2.跳过用例以及失败用例重跑</h6><h6 id="3-结合allure生成美观的测试报告"><a href="#3-结合allure生成美观的测试报告" class="headerlink" title="3.结合allure生成美观的测试报告"></a>3.结合allure生成美观的测试报告</h6><h6 id="4-和Jenkins自动集成"><a href="#4-和Jenkins自动集成" class="headerlink" title="4.和Jenkins自动集成"></a>4.和Jenkins自动集成</h6><h6 id="5-有很多强大的插件"><a href="#5-有很多强大的插件" class="headerlink" title="5.有很多强大的插件"></a>5.有很多强大的插件</h6><blockquote>
<p>pytest-html 生成html测试报告</br><br>pytest-xdist 多线程运行</br><br>pytest-ordering 改变测试用例的执行顺序</br><br>pytest-rerunfailures 失败用例重跑</br><br>allure-pytest 生成allure测试报告</p>
</blockquote>
<h2 id="三-运行方式"><a href="#三-运行方式" class="headerlink" title="三.运行方式"></a>三.运行方式</h2><p>1.主函数的方式（命令行的方式）</br><br>-v: 输出更加详细的信息</br><br>-s：输出调试信息</br><br>-n：指定线程个数</br><br>–reruns：失败用例重跑</br><br>–html 生成报告的路径</br><br>2.项目中使用pytest.ini配置文件，举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line">addopts &#x3D; -vs</span><br><span class="line">testpaths &#x3D; .&#x2F;testcases</span><br><span class="line">python_files &#x3D; test_*.py</span><br><span class="line">python_classes &#x3D; Test*</span><br><span class="line">python_functions &#x3D; test_*</span><br></pre></td></tr></table></figure>
<h2 id="四-前后置、夹具"><a href="#四-前后置、夹具" class="headerlink" title="四.前后置、夹具"></a>四.前后置、夹具</h2><p>1.setup/teardown 在每个用例之前/之后执行一次</br><br>2.setup_class/teardown_class 在每个类之前和之后执行一次</br></p>
<h5 id="如何实现部分前置？装饰器"><a href="#如何实现部分前置？装饰器" class="headerlink" title="如何实现部分前置？装饰器"></a>如何实现部分前置？装饰器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@pytest.fixture(scope&#x3D;&quot;作用域&quot;， params&#x3D;&quot;数据驱动&quot;, autouse&#x3D;&quot;自动执行&quot;, ids&#x3D;&quot;自定义参数名&quot;,name&#x3D;&quot;重命名&quot;)</span><br></pre></td></tr></table></figure>
<p>作用域：function.class,module, package/session<br>可以通过yield唤醒类似teardown功能，简单理解就是返回，yield和return都表示返回数据的意思，只是区别在于：yield返回多次且其后可以跟代码，return只返回一次且其后不能跟代码</p>
<h5 id="conftest-py文件很强大"><a href="#conftest-py文件很强大" class="headerlink" title="conftest.py文件很强大"></a>conftest.py文件很强大</h5><p>1.conftest.py文件是单独存放@pytest.fixture()的方法，用处是可以在多个py文件之间共享前置配置</br><br>2.conftest.py里面的方法在调用时不需要导入，可以直接使用。</br><br>3.conftest.py可以有多个，也可以有不同的层级。</p>
<h2 id="接口自动化框架封装"><a href="#接口自动化框架封装" class="headerlink" title="接口自动化框架封装"></a>接口自动化框架封装</h2><p>一般情况下通过关联的yaml文件来实现</p>
<h2 id="五-接口断言"><a href="#五-接口断言" class="headerlink" title="五.接口断言"></a>五.接口断言</h2><h2 id="六。pytest结合allure-pytest生成allure生成测试报告"><a href="#六。pytest结合allure-pytest生成allure生成测试报告" class="headerlink" title="六。pytest结合allure-pytest生成allure生成测试报告"></a>六。pytest结合allure-pytest生成allure生成测试报告</h2><p>1.官网下载allure</p>
<h2 id="七-接口自动化测试框架Yaml数据驱动的封装"><a href="#七-接口自动化测试框架Yaml数据驱动的封装" class="headerlink" title="七.接口自动化测试框架Yaml数据驱动的封装"></a>七.接口自动化测试框架Yaml数据驱动的封装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.parametrize(args_name, args_value)</span><br><span class="line">args_name：参数名</span><br><span class="line">args_value：参数值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestApi:</span><br><span class="line"></span><br><span class="line">    @pytest.mark.parametrize(&#39;args&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span><br><span class="line">    def test_api(self, args):</span><br><span class="line">        print(&quot;1&quot;)</span><br><span class="line">        print(args)</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[gw0] win32 Python 3.8.6 cwd: D:\2021_practice\heaven-sword-backend</span><br><span class="line">[gw1] win32 Python 3.8.6 cwd: D:\2021_practice\heaven-sword-backend</span><br><span class="line">[gw2] win32 Python 3.8.6 cwd: D:\2021_practice\heaven-sword-backend</span><br><span class="line">[gw0] Python 3.8.6 (tags&#x2F;v3.8.6:db45529, Sep 23 2020, 15:52:53) [MSC v.1927 64 bit (AMD64)]</span><br><span class="line">[gw1] Python 3.8.6 (tags&#x2F;v3.8.6:db45529, Sep 23 2020, 15:52:53) [MSC v.1927 64 bit (AMD64)]</span><br><span class="line">[gw2] Python 3.8.6 (tags&#x2F;v3.8.6:db45529, Sep 23 2020, 15:52:53) [MSC v.1927 64 bit (AMD64)]</span><br><span class="line">gw0 [3] &#x2F; gw1 [3] &#x2F; gw2 [3]</span><br><span class="line"></span><br><span class="line">scheduling tests via LoadScheduling</span><br><span class="line"></span><br><span class="line">test_api.py::TestApi::test_api[a] </span><br><span class="line">test_api.py::TestApi::test_api[c] </span><br><span class="line">test_api.py::TestApi::test_api[b] </span><br><span class="line">[gw0] [ 33%] PASSED test_api.py::TestApi::test_api[a] </span><br><span class="line">[gw1] [ 66%] PASSED test_api.py::TestApi::test_api[b] </span><br><span class="line">[gw2] [100%] PASSED test_api.py::TestApi::test_api[c] </span><br></pre></td></tr></table></figure>
<h2 id="八-YAML详解"><a href="#八-YAML详解" class="headerlink" title="八.YAML详解"></a>八.YAML详解</h2><p>也是一种数据格式。</br><br>主要的两个作用：<br>1.配置文件<br>2.测试用例</br><br>数据组成：1.map对象：键(空格)值 2.列表：用-开头</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-有关自动化测试的思考"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/02/%E6%9C%89%E5%85%B3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83/"
    >有关自动化测试的思考</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/08/02/%E6%9C%89%E5%85%B3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2022-08-02T09:42:52.000Z" itemprop="datePublished">2022-08-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="哪些测试场景-用例可以自动化？"><a href="#哪些测试场景-用例可以自动化？" class="headerlink" title="哪些测试场景/用例可以自动化？"></a>哪些测试场景/用例可以自动化？</h2><blockquote>
<p>1.重复性的测试：在多次构建中运行的测试</br><br>2.容易导致人为错误的测试</br><br>3.需要多个数据集的测试</br><br>4.软件经常使用的功能：意味着高风险</br><br>5.不能手动执行的测试：压力/性能测试等</br><br>6.手动测试时需要花费大量精力和时间的测试</br></p>
</blockquote>
<h2 id="在自动化任何测试用例之前应该考虑什么？"><a href="#在自动化任何测试用例之前应该考虑什么？" class="headerlink" title="在自动化任何测试用例之前应该考虑什么？"></a>在自动化任何测试用例之前应该考虑什么？</h2><h5 id="1-测试频率"><a href="#1-测试频率" class="headerlink" title="1.测试频率"></a>1.测试频率</h5><p>边缘情况进行手动测试可能更有效</p>
<h5 id="2-测试覆盖率"><a href="#2-测试覆盖率" class="headerlink" title="2.测试覆盖率"></a>2.测试覆盖率</h5><h5 id="3-测试的结果应该是明确的"><a href="#3-测试的结果应该是明确的" class="headerlink" title="3.测试的结果应该是明确的"></a>3.测试的结果应该是明确的</h5><p>自动化测试需要预先定义输入和输出来产生通过和失败条件。</p>
<h5 id="4-时间回报比"><a href="#4-时间回报比" class="headerlink" title="4.时间回报比"></a>4.时间回报比</h5><p>进行自动化测试前，必须要将维护自动化测试所需的时间和成本进行充分考虑。</p>
<h5 id="5-人的干预"><a href="#5-人的干预" class="headerlink" title="5.人的干预"></a>5.人的干预</h5><p>如果自动化测试套件过于复杂，需要人重新检查测试结果或交互过程，那进行自动化测试的意义不大。</p>
<h5 id="6-考虑优先级"><a href="#6-考虑优先级" class="headerlink" title="6.考虑优先级"></a>6.考虑优先级</h5><p>如果自动化测试有助于更快地将产品推向时长，则应该继续使用自动化测试。但如果需要立即获得结果，不要让编写和运行自动化测试成为瓶颈。</p>
<h2 id="经常自动化的测试用例"><a href="#经常自动化的测试用例" class="headerlink" title="经常自动化的测试用例"></a>经常自动化的测试用例</h2><h5 id="1-性能测试（负载、压力测试）"><a href="#1-性能测试（负载、压力测试）" class="headerlink" title="1.性能测试（负载、压力测试）"></a>1.性能测试（负载、压力测试）</h5><p>此时自动化测试工具可以以很少的成本有效地模拟用户和资源。</p>
<h5 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h5><p>单元测试在重构代码时非常有效</p>
<h5 id="3-回归测试（烟雾、健全性测试）"><a href="#3-回归测试（烟雾、健全性测试）" class="headerlink" title="3.回归测试（烟雾、健全性测试）"></a>3.回归测试（烟雾、健全性测试）</h5><p>回归测试需要确保即使进行了大量更改，应用程序也能顺利运行。这意味着需要反复重新测试多个应用程序组件。此时，自动化测试是理想方法。</p>
<h5 id="4-功能测试"><a href="#4-功能测试" class="headerlink" title="4.功能测试"></a>4.功能测试</h5><p>功能测试应尽量自动化进行，以确保无错误的产品交付。</p>
<h2 id="哪些测试不应该自动化？"><a href="#哪些测试不应该自动化？" class="headerlink" title="哪些测试不应该自动化？"></a>哪些测试不应该自动化？</h2><h5 id="1-探索性测试"><a href="#1-探索性测试" class="headerlink" title="1.探索性测试"></a>1.探索性测试</h5><p>探索性测试包括广泛的非脚本测试。通常，这些测试需要一些领域知识和对应用程序的熟悉才能找出意外行为。因为它们没有被很好地定义，它们不能被自动化。</p>
<h5 id="2-可用性测试"><a href="#2-可用性测试" class="headerlink" title="2.可用性测试"></a>2.可用性测试</h5><p>可用性测试不应该被自动化。因为人类行为难以进行完全预测，这可能包括错误的字体、颜色或使人们感到困惑的ui</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Docker进阶学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/03/Docker%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"
    >Docker进阶学习</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/07/03/Docker%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-07-03T15:15:03.000Z" itemprop="datePublished">2022-07-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker进阶学习笔记"><a href="#Docker进阶学习笔记" class="headerlink" title="Docker进阶学习笔记"></a>Docker进阶学习笔记</h1><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>往常方式：DockerFile build run 手动操作启动，单个容器。</br><br>微服务场景：100个微服务，存在依赖关系。</p>
</blockquote>
<p>Docker compose来轻松高效地管理容器，定义运行多个容器</p>
<h3 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h3><p>定义、运行多个容器</br><br>YAML file配置文件 </p>
<figure class="highlight plain"><figcaption><span>is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see the list of features.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in Common Use Cases.</span><br><span class="line"></span><br><span class="line">Using Compose is basically a three-step process:</span><br><span class="line"></span><br><span class="line">Define your app’s environment with a Dockerfile so it can be reproduced anywhere.</span><br><span class="line">1.Dockerfile保证我们的项目可以在任何地方运行</span><br><span class="line"></span><br><span class="line">Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment.</span><br><span class="line">2.docker-compose.yml文件</span><br><span class="line"></span><br><span class="line">Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary.</span><br><span class="line">3.docker-compose up命令启动服务</span><br></pre></td></tr></table></figure>
<p>作用：批量容器编排</p>
<h3 id="扩展理解"><a href="#扩展理解" class="headerlink" title="扩展理解"></a>扩展理解</h3><p>Compose是Docker官方的开源项目，需要独立安装</br><br>Dockerfile让程序在任何地方运行。web服务、redis、mysql、nginx多个容器。</br></p>
<h3 id="官方compose-yml文件示例"><a href="#官方compose-yml文件示例" class="headerlink" title="官方compose.yml文件示例"></a>官方compose.yml文件示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.9&quot;  # optional since v1.27.0</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:5000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - .:&#x2F;code</span><br><span class="line">      - logvolume01:&#x2F;var&#x2F;log</span><br><span class="line">    links:</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h3><blockquote>
<p>服务services, 容器，应用。<br>项目project：一组关联的容器。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>该部分内容见官方文档<br><code>https://docs.docker.com/compose/install/</code></p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><blockquote>
<p>场景：官网案例是一个计数器应用，用redis辅助<br>1.创建</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir composetest</span><br><span class="line">cd composetest</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure>
<p>app.py文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">cache &#x3D; redis.Redis(host&#x3D;&#39;redis&#39;, port&#x3D;6379)</span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries &#x3D; 5</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            return cache.incr(&#39;hits&#39;)</span><br><span class="line">        except redis.exception.ConnectionError as exec:</span><br><span class="line">            if retries &#x3D;&#x3D; 0:</span><br><span class="line">                raise exec</span><br><span class="line">            retries -&#x3D; 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;) </span><br><span class="line">def hello():</span><br><span class="line">    count +&#x3D; get_hit_count()</span><br><span class="line">    return &#39;Hellow World! I have been seen &#123;&#125; times.\n&#39;.format(count</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim requirements.txt</span><br><span class="line">内容如下：</span><br><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<p>create Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-alipine</span><br><span class="line">FROM python:3.7-pline</span><br><span class="line">WORKDIR &#x2F;code</span><br><span class="line">WORKDIR &#x2F;code</span><br><span class="line">ENV FLASK_APP app.py</span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
<p>在compose.yml中定义服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:5000&quot;</span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alipine&quot;</span><br></pre></td></tr></table></figure>
<p>其中定义了启动服务的两种方式：1.build(依赖于Dockerfile)。 2.依赖官方镜像</p>
<h3 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h3><p>1.应用：app.py</br><br>2.Dockerfile应用打包为镜像</br><br>3.Docker-compose yaml文件定义整个服务</br><br>4.启动compose项目(docker-compose up)</br></p>
<h3 id="网络规则"><a href="#网络规则" class="headerlink" title="网络规则"></a>网络规则</h3><p>项目中的内容都在同个网络下，可以直接通过域名访问（例：可直接用：mysql:3306访问mysql服务）</p>
<h3 id="停止方法："><a href="#停止方法：" class="headerlink" title="停止方法："></a>停止方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>
<p>或<br>crtl+c</p>
<h3 id="Compose文件的编写规则"><a href="#Compose文件的编写规则" class="headerlink" title="Compose文件的编写规则"></a>Compose文件的编写规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有且仅有三层</span><br><span class="line">第一层：version-docker-compose版本，和docker engine对应</span><br><span class="line">第二层: services</span><br><span class="line">服务1</span><br><span class="line">   # 服务配置</span><br><span class="line">   images</span><br><span class="line">   build</span><br><span class="line">   network</span><br><span class="line">服务2</span><br><span class="line">第三层：其他配置: 网络&#x2F;卷、全局规则</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-使用Jenkins构建Docker镜像并自动上传到docker registry仓库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/01/%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0docker%20registry%E4%BB%93%E5%BA%93/"
    >使用Jenkins构建Docker镜像并自动上传到docker registry私有仓库</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/06/01/%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0docker%20registry%E4%BB%93%E5%BA%93/" class="article-date">
  <time datetime="2022-06-01T14:07:03.000Z" itemprop="datePublished">2022-06-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="使用Jenkins构建Docker镜像并自动上传到docker-registry仓库"><a href="#使用Jenkins构建Docker镜像并自动上传到docker-registry仓库" class="headerlink" title="使用Jenkins构建Docker镜像并自动上传到docker registry仓库"></a>使用Jenkins构建Docker镜像并自动上传到docker registry仓库</h1><h2 id="0-Jenkins构建docker镜像的应用需求"><a href="#0-Jenkins构建docker镜像的应用需求" class="headerlink" title="0 Jenkins构建docker镜像的应用需求"></a>0 Jenkins构建docker镜像的应用需求</h2><p>公司各个项目分成多个组进行开发，为了便于各个组进行测试，进行如下设计：</br></p>
<blockquote>
<p>1.各个项目在gitee上创建一个或多个branch，jenkins为各组master的branch创建一个job，并为job创建对应的build策略。</br><br>2.镜像私有仓库中存储了各个项目的镜像。</br><br>3.提交到gitee的源码需要包含一个dockerfile。</br><br>4.项目更新代码后，jenkins拉取提交的branch代码，并在jenkins服务器本地执行Dockerfile，完成image的升级或更新，然后根据job的build策略，执行build操作，生成一个新镜像。</br><br>5.job对应的build策略中，包含了将镜像push到私有仓库的操作。</br><br>6.查看仓库中是否有该镜像，如果有，则说明成功。</br><br>7.各项目继续进行开发，可以基于上一次更新的image</br></p>
</blockquote>
<h2 id="1-Jenkins上创建一个job"><a href="#1-Jenkins上创建一个job" class="headerlink" title="1.Jenkins上创建一个job"></a>1.Jenkins上创建一个job</h2><blockquote>
<p>该文章基于已经创建了gitee, jenkins以及docker registry的基础之上。</br><br>下述过程可以构建一个dockerfile。</p>
</blockquote>
<h5 id="1-创建job"><a href="#1-创建job" class="headerlink" title="(1) 创建job"></a>(1) 创建job</h5><p>构建一个<b>自由风格的软件项目</b>.<br><img src="/images/jenkins.png"></br><br>如图配置，这里使用的是gitee仓库。</p>
<h5 id="2-构建脚本，往下拉到build–add-build-step，选择执行shell。"><a href="#2-构建脚本，往下拉到build–add-build-step，选择执行shell。" class="headerlink" title="(2)构建脚本，往下拉到build–add build step，选择执行shell。"></a>(2)构建脚本，往下拉到build–add build step，选择执行shell。</br></h5><p>添加如下内容，主要就是<code>docker build</code>和<code>docker push</code>所需要的参数，这里要注意docker所在的路径，可以先用<code>whereis docker</code>命令找一下，shell脚本的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">#</span><br><span class="line">echo &quot;release_tag&#x3D;$&#123;release_tag&#125;&quot;</span><br><span class="line"></span><br><span class="line">upload_p&#x3D;$&#123;upload_path&#125;</span><br><span class="line"></span><br><span class="line"> DIR&#x3D;&quot;.&quot;</span><br><span class="line">sudo &#x2F;usr&#x2F;bin&#x2F;docker build -t andon_$&#123;release_tag&#125; $DIR | tee $DIR&#x2F;Docker_build_result.log</span><br><span class="line"> </span><br><span class="line">RESULT&#x3D;$(cat $DIR&#x2F;Docker_build_result.log | tail -n 1)</span><br><span class="line"> </span><br><span class="line">if [[&quot;$RESULT&quot; !&#x3D; *Successfully*]];then</span><br><span class="line">  exit -1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># aliyun exclusive tagging and image push operations</span><br><span class="line">function uploadAliyun()&#123;</span><br><span class="line">    echo &#39;&gt;&gt;&gt; Add tag to the new image&#39;</span><br><span class="line">    sudo &#x2F;usr&#x2F;bin&#x2F;docker tag andon_$&#123;release_tag&#125; registry.cn-hangzhou.aliyuncs.com&#x2F;images_manage&#x2F;andon:$&#123;release_tag&#125;</span><br><span class="line">    echo &#39;&gt;&gt;&gt; Start push new image&#39;</span><br><span class="line">    sudo &#x2F;usr&#x2F;bin&#x2F;docker push registry.cn-hangzhou.aliyuncs.com&#x2F;images_manage&#x2F;andon:$&#123;release_tag&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [[ &quot;$upload_p&quot; &#x3D;&#x3D; &quot;aliyun&quot; ]];then</span><br><span class="line">    uploadAliyun</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置结束后，点击应用并保存。</p>
<h5 id="3-配置jenkins用户"><a href="#3-配置jenkins用户" class="headerlink" title="(3)配置jenkins用户"></a>(3)配置jenkins用户</h5><p>此时还不能立刻构建，因为jenkins触发脚本并不是root用户，因此需要将jenkins免密码，并将用户加入到docker组，否则获取不到容器ID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nano&#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">Default:jenkins !requiretty</span><br><span class="line"># User privilege specification</span><br><span class="line">root  ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">jenkins ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
<h5 id="4-开始构建镜像"><a href="#4-开始构建镜像" class="headerlink" title="(4)开始构建镜像"></a>(4)开始构建镜像</h5><p>在jenkins页面上对项目执行build。查看日志，jenkins会自动把gitee上的文件给下载下来放在workpace目录中。因此，触发脚本后，直接开始构建镜像。</p>
<h5 id="5-配置自动推送镜像"><a href="#5-配置自动推送镜像" class="headerlink" title="(5)配置自动推送镜像"></a>(5)配置自动推送镜像</h5><p>修改job中的配置中的build中的shell脚本。我们选择的是阿里云私人镜像仓库。</br><br>将官网上的操作指南记录如下：</br><br>1&gt; 登录阿里云Docker Registry.</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login --username&#x3D;aliyun1490882597 registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure>
<p>2&gt; 将镜像推送至Registry。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com&#x2F;images_manage&#x2F;andon:[镜像版本号]</span><br><span class="line">$ docker push registry.cn-hangzhou.aliyuncs.com&#x2F;images_manage&#x2F;andon:[镜像版本号]</span><br></pre></td></tr></table></figure>
<h2 id="在Jenkins中配置根据参数进行构建"><a href="#在Jenkins中配置根据参数进行构建" class="headerlink" title="在Jenkins中配置根据参数进行构建"></a>在Jenkins中配置<code>根据参数进行构建</code></h2><blockquote>
<p>场景描述：我们在构建任务时经常会遇到这样的场景：一个任务配置好了以后，在后面的构建过程中，又会修改一些配置。例如，我们构建的项目的代码可能是拉取指定的分支或者是Tag进行构建，又或者构建是在特定的平台上进行的。如果我们每次构建时都去修改配置，这就太麻烦了。这种情况下我们选择通过参数进行控制。</br><br>Jenkins默认已经支持的参数类型有：凭据参数、字符参数、密码参数、布尔参数、文件参数、选项参数等。具体使用方法记录如下：</br></p>
</blockquote>
<h5 id="1-创建job时，在【配置】中勾选上【参数化构建过程】"><a href="#1-创建job时，在【配置】中勾选上【参数化构建过程】" class="headerlink" title="(1)创建job时，在【配置】中勾选上【参数化构建过程】"></a>(1)创建job时，在【配置】中勾选上【参数化构建过程】</h5><p>可以在shell脚本中，输出我们的参数内容看看效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;release_tag&#x3D;$&#123;release_tag&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>保存之后，左侧菜单栏中的【立即构建】按钮会变成【Build with Parameters】,并且点击【Build with parameters】会要求输入参数，下图是默认的参数情况</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jenkins/" rel="tag">jenkins</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Docker官方手册学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/04/Docker%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >Docker官方手册学习笔记</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/05/04/Docker%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-05-04T08:56:03.000Z" itemprop="datePublished">2022-05-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker官方手册学习笔记"><a href="#Docker官方手册学习笔记" class="headerlink" title="Docker官方手册学习笔记"></a>Docker官方手册学习笔记</h1><blockquote>
<p>官方学习手册：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/introduction/what">https://yeasy.gitbook.io/docker_practice/introduction/what</a></p>
</blockquote>
<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><p>Docker使用Google公司推出的Go语言进行开发实现，基于linux内核的cgroup、namespace、以及Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术(将操作系统内核虚拟化，可以允许用户空间软件实例被分割成几个独立的单元)。</br><br><img src="/images/docker.png"></br></p>
<blockquote>
<p>runc是一个Linux命令行工具，用于根据OCI容器运行时规范创建和运行容器。</br><br>containerd是一个守护程序，它管理容器生命周期，提供了一个在节点上执行容器和管理镜像的最小功能集。</p>
</blockquote>
<p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。</br></p>
<h5 id="Docker与传统虚拟化方式的不同之处"><a href="#Docker与传统虚拟化方式的不同之处" class="headerlink" title="Docker与传统虚拟化方式的不同之处"></a>Docker与传统虚拟化方式的不同之处</h5><p>传统虚拟机技术是模拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上再运行所需应用进程。<b>而容器内的应用进程则直接运行于宿主的内核。容器内没有自己的内核，而且也没有进行硬件模拟，因此容器要比传统虚拟机更为轻便</b>。</br></p>
<h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><h5 id="1-更高效的利用系统资源"><a href="#1-更高效的利用系统资源" class="headerlink" title="1.更高效的利用系统资源"></a>1.更高效的利用系统资源</h5><p>容器不需要进行硬件虚拟以及完整操作系统等额外开销。Docker对系统资源的利用率更高。在<b>应用执行速度、内存损耗、文件存储速度</b>等方面都比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<h5 id="2-更快速的启动时间"><a href="#2-更快速的启动时间" class="headerlink" title="2.更快速的启动时间"></a>2.更快速的启动时间</h5><p>Docker容器应用，直接运行于宿主内核，无需启动完整的操作系统。因此可以做到秒级、毫秒级的启动时间。<b>大大的节约了开发、测试、部署的时间。</b></p>
<h5 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h5><p>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。</p>
<h5 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h5><p>开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试。而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</p>
<h5 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h5><p>Docker确保了执行环境的一致性，使得应用的迁移更加容易。用户可以轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h5 id="更轻松的维护和拓展"><a href="#更轻松的维护和拓展" class="headerlink" title="更轻松的维护和拓展"></a>更轻松的维护和拓展</h5><blockquote>
<p>1.Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易。</br><br>2.Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可用于专门定制，大大降低了应用服务的镜像制作成本。</p>
</blockquote>
<h1 id="基础概念区分"><a href="#基础概念区分" class="headerlink" title="基础概念区分"></a>基础概念区分</h1><h5 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1.镜像"></a>1.镜像</h5><p>操作系统分为内核和用户空间。相对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像，就相当于是一个root文件系统。比如官方镜像ubuntu:18.04就包含了完整的一套Ubuntu 18.04最小系统的root文件系统。</br><br>&emsp;&emsp;<b>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。</b></br></p>
<h5 id="分层存储机制"><a href="#分层存储机制" class="headerlink" title="分层存储机制"></a>分层存储机制</h5><p>Docker被设计为分层存储的架构。所以严格来说，镜像并非是像一个ISO那样的打包文件爱，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</br><br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生变化，后一层上的任何改变只发生在自己这一层</p>
<h5 id="2-容器"><a href="#2-容器" class="headerlink" title="2.容器"></a>2.容器</h5><p>&emsp;&emsp;容器(container)与镜像(image)的关系，就像是面对对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</br><br>&emsp;&emsp;容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此，<b>容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间</b>。容器内的进程，运行在一个隔离的环境中，使用起来像是在一个独立与宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主机运行更加安全。</br><br>&emsp;&emsp;镜像使用的是分层存储，容器亦是如此，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层。</br><br>&emsp;&emsp;容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</br><br>&emsp;&emsp;按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(volume)或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</br><br>&emsp;&emsp;数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷之后，容器删除或者重新运行之后，数据不会丢失。</br></p>
<h5 id="3。仓库"><a href="#3。仓库" class="headerlink" title="3。仓库"></a>3。仓库</h5><p>仓库提供一个集中的存储、分发镜像的服务</p>
<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从Docker镜像仓库获取镜像的命令是docker pull。其命令格式是：<br><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code><br>镜像名称的格式：</p>
<blockquote>
<p>1.Docker镜像仓库地址：地址格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub</br><br>2.仓库名：采用两段式名称。即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名，则默认为library，也就是官方镜像</p>
</blockquote>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>&emsp;&emsp;有了镜像后，我们就能以这个镜像为基础启动并运行一个容器。</br></p>
<figure class="highlight docker"><figcaption><span>run```就是运行容器的命令。以以下命令为例，简要说明一下上面用到的参数:</br></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```docker <span class="keyword">run</span><span class="bash"> -it --rm ubuntu:18.04 bash```</span></span><br><span class="line">&gt; 1.```-it```：这是两个参数，一个是-i:交互式操作，一个是-t终端。这里打算进入bash执行一些命令并查看返回结果，因此我们需要交互式终端。&lt;/br&gt;</span><br><span class="line">&gt; 2.```--rm```：这个参数是说容器退出后随之将其删除。&lt;/br&gt;</span><br><span class="line">&gt; 3.```ubuntu:18.04```：这是指用ubuntu:18.04镜像为基础来启动容器。&lt;/br&gt;</span><br><span class="line">&gt; <span class="number">4</span>.```bash```放在镜像名称后的是命令，这里我们希望有个交互式<span class="keyword">shell</span><span class="bash">，因此用的是bash</span></span><br><span class="line"></span><br><span class="line">可以通过```exit```命令退出容器</span><br><span class="line"><span class="comment">## 删除本地镜像</span></span><br><span class="line">```docker image rm [选项] &lt;镜像<span class="number">1</span>&gt; [&lt;镜像<span class="number">2</span>&gt;...]```</span><br><span class="line">其中，```镜像```可以是```镜像短ID、镜像长ID、镜像名或者镜像摘要```&lt;/br&gt;</span><br><span class="line">```短ID```一般取<span class="number">3</span>个字符以上，只要足够区分于别的镜像就可以了</span><br><span class="line"><span class="comment">## docker commit</span></span><br><span class="line">当我们运行一个容器的时候(如果不使用卷的话)，我们做的任何文件修改都会被记录于容器存储层内。而Docker提供了一个```docker commit```命令，可以将容器的存储层保存下来作为新的镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后运行这个新镜像的时候，就会拥有原有容器最后的文件变化。&lt;/br&gt;</span><br><span class="line">其语法格式为：&lt;/br&gt;</span><br><span class="line">```docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]```</span><br><span class="line">然而，由于命令的执行，还有很多文件被改动或添加了。如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。&lt;/br&gt;</span><br><span class="line">此外，使用```docker commit```意味着对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像。黑箱镜像的维护工作是非常痛苦的。&lt;/br&gt;</span><br><span class="line">如果使用```docker commit```制作镜像，以及后期修改的话，每次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直跟随着这个镜像，即使根本无法访问到，这会让镜像更加臃肿。</span><br><span class="line"><span class="comment">## 使用Dockerfile来定制镜像</span></span><br><span class="line">&gt; 原理介绍：镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。这个脚本就是Dockerfile</span><br><span class="line"><span class="comment">### FROM指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span>就是指定基础镜像，一个Dockerfile中<span class="keyword">FROM</span>是必备的指令，而且必须是第一条指令</span><br><span class="line"><span class="comment">### RUN执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">指令是在定制镜像时最常用的指令之一，其格式有如下两种：</span></span><br><span class="line">&gt; <span class="number">1</span>.shell格式：```<span class="keyword">RUN</span><span class="bash"> &lt;命令&gt;```，就像直接在命令行中输入的命令一样</span></span><br><span class="line">&gt; <span class="number">2</span>.exec格式</span><br><span class="line">```<span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]```</span></span><br><span class="line">Dockerfile中每一个指令都会建立一层，<span class="keyword">RUN</span><span class="bash">也不例外。每一个RUN的行为，就和刚才手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit这一层的修改，构成新镜像</span></span><br><span class="line"><span class="comment">### COPY复制文件</span></span><br></pre></td></tr></table></figure>
<p>COPY [–chown=<user>:<group>] &lt;源路径&gt;…&lt;目标路径&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COPY指令将从构建上下文目录中&#96;&#96;&#96;&lt;源路径&gt;&#96;&#96;&#96;的文件&#x2F;目录复制到新的一层镜像内的&#96;&#96;&#96;&lt;目标路径&gt;&#96;&#96;&#96;位置</span><br><span class="line">&#96;&#96;&#96;COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;&#96;&#96;&#96;</span><br><span class="line">值得注意的是，使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用Git进行管理的时候。&lt;&#x2F;br&gt;</span><br><span class="line">在使用该指令的时候还可以加上&#96;&#96;&#96;--chown&#x3D;&lt;user&gt;:&lt;group&gt;&#96;&#96;&#96;选项来改变文件的所属用户及所属组。</span><br><span class="line">### ENTRYPOINT入口点</span><br><span class="line">&#96;&#96;&#96;ENTRYPOINT&#96;&#96;&#96;的目的和&#96;&#96;&#96;CMD&#96;&#96;&#96;一样，都是在指定容器启动程序及参数，指令格式为：&lt;&#x2F;br&gt;</span><br><span class="line">&#96;&#96;&#96;&lt;ENTRYPOINT&gt; &quot;CMD&quot;&#96;&#96;&#96;</span><br><span class="line">##### 场景一：让镜像变成命令一样被使用</span><br></pre></td></tr></table></figure>
<p>FROM ubuntu:18.04<br>RUN apt-get update <br>    &amp;&amp; apt-get install -y curl <br>    &amp;&amp; rm -rf /var/lib/apt/lists*<br>ENTRYPOINT [“curl”, “-s”, “<a href="http://myip.ipip.net&quot;]">http://myip.ipip.net&quot;]</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用：</span><br></pre></td></tr></table></figure>
<p>docker run myip -i</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当存在ENTRYPOINT后，CMD的内容将会作为参数传递给ENTRYPOINT，-i就是这里新的CMD，会作为参数传递给curl</span><br><span class="line">##### 场景二：应用运行前的准备工作</span><br><span class="line">启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。&lt;&#x2F;br&gt;</span><br><span class="line">比如mysql类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的mysql服务器运行之前解决。&lt;&#x2F;br&gt;</span><br><span class="line">此外，要避免使用root用户去启动服务，从而提高安全性，在启动服务之前需要以root身份执行一些必要的准备工作。&lt;&#x2F;br&gt;</span><br><span class="line">官方镜像redis就是这么做的：</span><br></pre></td></tr></table></figure>
<p>FROM alpine:3.4<br>…<br>RUN　addgroup -S redis &amp;&amp; adduser -S -G redis redis<br>…<br>ENTRYPOINT [“docker-entrypoint.sh”]</p>
<p>EXPOSE 6379<br>CMD [“redis-server”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### ENV设置环境变量</span><br><span class="line">这个指令就是设置环境变量，以官方&#96;&#96;&#96;node&#96;&#96;&#96;镜像的Dockerfile为例</span><br></pre></td></tr></table></figure>
<p>ENV NODE_VERSION 7.2.0</p>
<p>RUN curl -SLO “<a target="_blank" rel="noopener" href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;</a> <br>  &amp;&amp; curl -SLO “<a target="_blank" rel="noopener" href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</a> <br>  &amp;&amp; gpg –batch –decrypt –output SHASUMS256.txt SHASUMS256.txt.asc <br>  &amp;&amp; grep “ node-v$NODE_VERSION-linux-x64.tar.xz$“ SHASUMS256.txt | sha256sum -c - <br>  &amp;&amp; tar -xJf “node-v$NODE_VERSION-linux-x64.tar.xz” -C /usr/local –strip-components=1 <br>  &amp;&amp; rm “node-v$NODE_VERSION-linux-x64.tar.xz” SHASUMS256.txt.asc SHASUMS256.txt <br>  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里先定义了环境变量&#96;&#96;&#96;NODE_VERSION&#96;&#96;&#96;，其后的&#96;&#96;&#96;RUN&#96;&#96;&#96;这层里，多次使用&#96;&#96;&#96;$NODE_VERSION&#96;&#96;&#96;来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新&#96;&#96;&#96;7.2.0&#96;&#96;&#96;即可，&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;构建维护变得更轻松了。</span><br><span class="line">### VOLUME定义匿名卷</span><br><span class="line">格式为：</span><br></pre></td></tr></table></figure>
<p>VOLUME &lt;路径&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)之中。在Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</span><br></pre></td></tr></table></figure>
<p>VOLUME /data</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的&#96;&#96;&#96;&#x2F;data&#96;&#96;&#96;目录就会在容器运行时自动挂载为匿名卷，任何向&#96;&#96;&#96;&#x2F;data&#96;&#96;&#96;中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置，比如：</span><br></pre></td></tr></table></figure>
<p>docker run -d -v mydata:/data xxxx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在这行命令中，就使用了mydata这个命名卷挂载到了&#x2F;data这个位置，替代了&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;中的匿名卷的挂载配置。</span><br><span class="line">### EXPOSE暴露端口</span><br><span class="line">格式为：</span><br></pre></td></tr></table></figure>
<p>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在Dockerfile中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。另一个好处则是在运行时使用随机端口映射，也就是&#96;&#96;&#96;docker run -P&#96;&#96;&#96;时，会自动随机映射&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;端口。&lt;&#x2F;br&gt;</span><br><span class="line">要将&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;和在运行时使用&#96;&#96;&#96;-p &lt;宿主端口&gt;：&lt;容器端口&gt;&#96;&#96;&#96;区分开来。&#96;&#96;&#96;-p&#96;&#96;&#96;，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问。而&#96;&#96;&#96;EXPOSE&#96;&#96;&#96;仅仅是声明容器打算使用什么端口二义，并不会自动在宿主机进行端口映射。</span><br><span class="line">### WORKDIR指定工作目录</span><br><span class="line">格式为：&lt;&#x2F;br&gt;</span><br></pre></td></tr></table></figure>
<p>WORKDIR &lt;工作目录路径&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用&#96;&#96;&#96;WORKDIR&#96;&#96;&#96;指令可以来指定工作目录。目录不存在时，WORKDIR会帮你新建目录。</span><br><span class="line">以下举一个错误的例子：</span><br></pre></td></tr></table></figure>
<p>RUN cd /app<br>RUN echo “hello” &gt; world.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将这个&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;进行构建镜像运行后，会发现找不到&#96;&#96;&#96;&#x2F;app&#x2F;world.txt&#96;&#96;&#96;文件，或者其内容不是&#96;&#96;&#96;hello&#96;&#96;&#96;。原因很简单，在Shell中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;中，这两行&#96;&#96;&#96;RUN&#96;&#96;&#96;命令的执行环境根本不同，是两个完全不同的容器，这就是对&#96;&#96;&#96;Dockerfile&#96;&#96;&#96;构建分层存储的概念不了解所导致的错误。&lt;&#x2F;br&gt;</span><br><span class="line">之前说过，每一个&#96;&#96;&#96;RUN&#96;&#96;&#96;都是启动一个容器，执行命令、执行命令、然后提交存储层文件变更。第一层&#96;&#96;&#96;RUN cd &#x2F;app&#96;&#96;&#96;的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已。其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器。跟第一层的容器完全没关系，自然不可能继承前一层构建过程中的内存变化。&lt;&#x2F;br&gt;</span><br><span class="line">因此如果需要改变以后各层的工作目录的位置，那么应该使用WORKDIR指令。</span><br></pre></td></tr></table></figure>
<p>WORKDIR /app<br>RUN echo “hello” &gt; world.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 操作容器</span><br><span class="line">&gt; 前言：简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用</span><br><span class="line">### 启动</span><br><span class="line">&gt; 启动容器有两种方式：一种是基于镜像新建一个容器并启动，另外一个是将在终止状态(exited)的容器重新启动。Dokcer实在是太轻量级了，很多时候用户都是随时删除和新创建容器&lt;&#x2F;br&gt;</span><br><span class="line"></span><br><span class="line">下面的命令启动一个bash终端，允许用户进行交互</span><br></pre></td></tr></table></figure>
<p>docker run -t -i ubuntu:18.04 /bin/bash<br>root@af8bae53bdd3:/#</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">其中，-t选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上，-i则让容器的标准输入保持打开</span><br><span class="line">### 守护态运行</span><br><span class="line">大多数情况下，我们需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下，通过添加参数&#96;&#96;&#96;-d&#96;&#96;&#96;可以让容器在后台运行。</span><br><span class="line">### 终止</span><br><span class="line">可以使用&#96;&#96;&#96;docker container stop&#96;&#96;&#96;来终止一个运行中的容器&lt;&#x2F;br&gt;</span><br><span class="line">对于处于终止状态的容器，可以通过&#96;&#96;&#96;docker container start&#96;&#96;&#96;命令来重新启动。&lt;&#x2F;br&gt;</span><br><span class="line">此外，&#96;&#96;&#96;docker container restart&#96;&#96;&#96;命令会将一个运行态的容器终止，然后再重新启动它。</span><br><span class="line">### 进入容器</span><br><span class="line">对于需要进入容器才能进行的操作，可以使用&#96;&#96;&#96;docker attach&#96;&#96;&#96;或者&#96;&#96;&#96;docker exec&#96;&#96;&#96;命令，一般只使用&#96;&#96;&#96;docker exec&#96;&#96;&#96;命令&lt;&#x2F;br&gt;</span><br><span class="line">&#96;&#96;&#96;docker exec -it &lt;container_id&gt; bash&#96;&#96;&#96;</span><br><span class="line">如果从这个stdin中exit，不会导致容器的终止，这就是为什么推荐大家使用&#96;&#96;&#96;docker exec&#96;&#96;&#96;的原因</span><br><span class="line">### 导出和导入</span><br><span class="line">#### 导出容器</span><br><span class="line">如果想要导出本地某个容器，可以使用&#96;&#96;&#96;docker export&#96;&#96;&#96;命令</span><br></pre></td></tr></table></figure>
<p>$ docker container ls -a<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES<br>7691a814370e        ubuntu:18.04        “/bin/bash”         36 hours ago        Exited (0) 21 hours ago                       test<br>$ docker export 7691a814370e &gt; ubuntu.tar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 导入容器快照</span><br><span class="line">可以使用&#96;&#96;&#96;docker import&#96;&#96;&#96;从容器快照文件中再导入为镜像：</span><br></pre></td></tr></table></figure>
<p>$ cat ubuntu.tar | docker import - test/ubuntu:v1.0<br>$ docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE<br>test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 删除容器</span><br><span class="line">可以使用&#96;&#96;&#96;docker container rm&#96;&#96;&#96;来删除一个处于终止状态的容器</span><br></pre></td></tr></table></figure>
<p>$ docker container rm trusting_newton<br>trusting_newton</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果要删除一个运行中的容器，可以添加&#96;&#96;&#96;-f&#96;&#96;&#96;参数来强制执行。Docker会发送SIGKILL信号给容器。</span><br><span class="line">### 清理所有处于终止状态的容器</span><br></pre></td></tr></table></figure>
<p>docker container prune</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 数据管理</span><br><span class="line">### 数据卷</span><br><span class="line">数据卷是一个可供一个或多个容器使用的特殊目录，它可以提供很多有用的特性：</span><br><span class="line">&gt; 1.数据卷可以在容器之间共享和重用</span><br><span class="line">&gt; 2.对数据卷的修改会立马生效</span><br><span class="line">&gt; 3.对数据卷的更新，不会影响镜像</span><br><span class="line">&gt; 4.数据卷默认会一直存在，即使容器被删除</span><br><span class="line">注意：数据卷的使用，类似于Linux下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷当中（仅数据卷为空时会复制）。</span><br><span class="line">### 挂载主机目录</span><br><span class="line">使用&#96;&#96;&#96;--mount&#96;&#96;&#96;命令可以指定挂载一个本地主机的目录到容器中去</span><br><span class="line"># 外部访问容器</span><br></pre></td></tr></table></figure>
<p>$ docker run -d -P nginx:alpine</p>
<p>$ docker container ls -l<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES<br>fae320d08268        nginx:alpine        “/docker-entrypoint.…”   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本地主机的32768被映射到了容器的80端口。此时访问本机的32768端口即可访问容器内NGINX默认页面&lt;&#x2F;br&gt;</span><br><span class="line">使用&#96;&#96;&#96;hostPort:containerPort&#96;&#96;&#96;格式本地的80端口映射到容器的80端口，可以执行：</span><br><span class="line">&#96;&#96;&#96;docker run -d -p 80:80 nginx:airpline&#96;&#96;&#96;</span><br><span class="line">此时默认会绑定本地所有接口上的所有地址</span><br><span class="line">##### 使用&#96;&#96;&#96;docker port&#96;&#96;&#96;来查看当前映射的端口配置</span><br><span class="line">&#96;&#96;&#96;docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><figure class="highlight docker"><figcaption><span>Compose```，负责快速的部署分布式应用。</br></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Compose允许用户通过一个单独的```docker-compose.yml```模板文件(YAML格式)来定义一组相关联的应用容器为一个项目(project)。简单来说，```docker-compose.yml```可以管理多个Dockerfile</span><br><span class="line"><span class="comment">##### docker-compose up</span></span><br><span class="line">命令格式为：</span><br><span class="line">```docker-compose up [options] [SERVICE...]```</span><br><span class="line">该命令十分强大，它将尝试自动完成包括构建镜像、创建服务、启动服务，并关联服务相关容器的一系列操作。&lt;/br&gt;</span><br><span class="line">可以说，大部分时候都可以直接通过该命令来启动一个项目。&lt;/br&gt;</span><br><span class="line">如果使用```dockerc-compose up -d```，将会在后台启动并运行所有容器。一般推荐生产环境下使用该选项。&lt;/br&gt;</span><br><span class="line">默认情况，如果服务容器已经存在，```docker-compose up```将会尝试停止容器，然后重新创建，以保证新启动的服务匹配```docker-compose.yml```文件的最新内容</span><br><span class="line"><span class="comment">#### Compose模板文件</span></span><br><span class="line">默认的模板文件名称为```docker-compose.yml```，格式为YAML格式</span><br></pre></td></tr></table></figure>
<p>version: “3”</p>
<p>services:<br>  webapp:<br>    image: examples/web<br>    ports:<br>      - “80:80”<br>    volumes:<br>      - “/data”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意每个服务都必须通过image指令指定镜像或build指令等来自动构建生成镜像。&lt;&#x2F;br&gt;</span><br><span class="line">如果使用build指令，在Dockerfile中设置的选项(例如：CMD、EXPOSE、VOLUME、ENV等)将会被自动获取，无需在&#96;&#96;&#96;docker-compose.yml&#96;&#96;&#96;中重复设置</span><br><span class="line">#### 介绍几个重要的参数</span><br><span class="line">##### build</span><br><span class="line">指定Dockerfile所在文件夹的路径，Compose将会利用它自动构建这个镜像，然后使用这个镜像</span><br></pre></td></tr></table></figure>
<p>version: ‘3’<br>services:</p>
<p>  webapp:<br>    build:<br>      context: ./dir<br>      dockerfile: Dockerfile-alternate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### devices</span><br><span class="line">指定设备映射关系</span><br></pre></td></tr></table></figure>
<p>devices:</p>
<ul>
<li>“/dev/ttyUSB1:/dev/ttyUSB0”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### depends_on</span><br><span class="line">解决容器的依赖、启动先后的问题。以下例子中会先启动redis、db再启动web</span><br></pre></td></tr></table></figure>
version: ‘3’</li>
</ul>
<p>services:<br>  web:<br>    build: .<br>    depends_on:<br>      - db<br>      - redis</p>
<p>  redis:<br>    image: redis</p>
<p>  db:<br>    image: postgres</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### env_file</span><br><span class="line">从文件中获取环境变量，可以为单独的文件路径或列表</span><br></pre></td></tr></table></figure>
<p>env_file:</p>
<ul>
<li>./common.env</li>
<li>./apps/web.env</li>
<li>/opt/secrets.env<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### environment</span><br><span class="line">设置环境变量</span><br></pre></td></tr></table></figure>
environment:<br>RACK_ENV: development<br>SESSION_SECRET:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##### expose</span><br><span class="line">暴露端口，但不映射到宿主机，只被连接的服务访问</span><br><span class="line">##### ports</span><br><span class="line">暴露端口信息。&lt;&#x2F;br&gt;</span><br><span class="line">使用宿主端口：容器端口(HOST:CONTAINER)格式。若仅指定容器端口(宿主将会随机选择端口)</span><br></pre></td></tr></table></figure>
<p>ports:</p>
<ul>
<li>“3000”</li>
<li>“8000:8000”</li>
<li>“49100:22”</li>
<li>“127.0.0.1:8001:8001”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### volumes</span><br><span class="line">数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式</span><br></pre></td></tr></table></figure>
version: “3”</li>
</ul>
<p>services:<br>  my_src:<br>    image: mysql:8.0<br>    volumes:<br>      - mysql_data:/var/lib/mysql</p>
<p>volumes:<br>  mysql_data:<br>```</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Go语言基础进阶教程(一)：bufio包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/28/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B(%E4%B8%80)%EF%BC%9Abufio%E5%8C%85/"
    >Go语言基础进阶教程(一)：bufio包</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/04/28/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B(%E4%B8%80)%EF%BC%9Abufio%E5%8C%85/" class="article-date">
  <time datetime="2022-04-28T12:59:52.000Z" itemprop="datePublished">2022-04-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-bufio包原理"><a href="#1-bufio包原理" class="headerlink" title="1.bufio包原理"></a>1.bufio包原理</h2><h5 id="bufio是通过缓冲来提高效率的"><a href="#bufio是通过缓冲来提高效率的" class="headerlink" title="bufio是通过缓冲来提高效率的"></a>bufio是通过缓冲来提高效率的</h5><p>&emsp;&emsp;前言：io操作本身的效率并不低，低的是频繁访问本地磁盘的文件。所以bufio就提供了缓冲区（分配一块内存），读和写都先在缓冲区中进行，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。</br><br>&emsp;&emsp;缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。</br><br>&emsp;&emsp;bufio封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象.</br><br>&emsp;&emsp;io.Reader或io.Writer接口实现read()和write()方法，对于实现这个接口的对象都是可以使用这两个方法的。</br></p>
<h5 id="Reader对象"><a href="#Reader对象" class="headerlink" title="Reader对象"></a>Reader对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reader implements buffering for an io.Reader object</span><br><span class="line">type Reader struct&#123;</span><br><span class="line">    buf   []byte</span><br><span class="line">    rd    io.Reader &#x2F;&#x2F;reader provided by the client</span><br><span class="line">    r, w  int</span><br><span class="line">    err   error</span><br><span class="line">    lastByte int&#x2F;&#x2F;last byte read for UnreadByte; -1 means invalid</span><br><span class="line">    lastRuneSize int &#x2F;&#x2F;size of last rune read for UnreadRune; -1 means invalid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取规则如下：</br><br>bufio.Read(p []byte)相当于读取大小len(p)的内容：</p>
<blockquote>
<p>1.当缓存区有内容时，将缓存区内容全部填入p并清空缓存区。</br><br>2.若想要读取的内容比缓存区还要大，直接去文件读取即可。</br><br>3.当缓存区没有内容，且要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满(此时缓存区有剩余内容)</br></p>
</blockquote>
<p>bufio.Writer是bufio中对io.Writer的封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer</span><br><span class="line">type Writer struct&#123;</span><br><span class="line">    err error</span><br><span class="line">    buf []byte</span><br><span class="line">    n int</span><br><span class="line">    wr io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bufio.Write(p []byte)的思路如下：</p>
<blockquote>
<p>1.判断buf中可用容量是否可以放下p。</br><br>2.如果能放下，直接把p拼接在buf后面，即把内容放到缓冲区。</br><br>3.如果缓冲区的容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可。</br><br>4.如果缓冲区的容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区。</br><br>5.判断p的剩余内容大小是否能放入缓冲区，如果能放下，则把内容放到缓冲区。</br><br>6.如果p的剩余内容仍旧大于缓冲区，则把p的剩余内容直接写入文件。</p>
</blockquote>
<h5 id="b-flush-会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush-到文件"><a href="#b-flush-会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush-到文件" class="headerlink" title="b.flush()会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件"></a>b.flush()会将缓冲区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件</h5><h2 id="2-bufio包"><a href="#2-bufio包" class="headerlink" title="2.bufio包"></a>2.bufio包</h2><p>&emsp;&emsp;bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer对象，同时还提供了缓冲和一些文本I/O的帮助函数的对象。</br><br>&emsp;&emsp;bufio.Reader实现了如下接口：</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;NewReaderSize将rd封装成一个带缓存的bufio.Reader对象，</span><br><span class="line">&#x2F;&#x2F;缓存大小由size指定（若小于16， 会被设置为16）</span><br><span class="line">&#x2F;&#x2F;如果rd的基类型就是由足够缓存的bufio.Reader类型，则直接将rd转换为基类型返回</span><br><span class="line">func NewReaderSize(rd io.Reader, size int) *Reader</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;NewReader相当于NewReaderSize(rd, 4096)</span><br><span class="line">func NewReader(rd io.Reader) *Reader</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Peek返回缓存的一个切片，该切片引用缓存中前n个字节的数据，</span><br><span class="line">&#x2F;&#x2F;该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之前</span><br><span class="line">&#x2F;&#x2F;是有效的，如果切片的长度小于n，则返回一个错误信息并说明原因</span><br><span class="line">&#x2F;&#x2F;如果n大于缓存的总大小，则返回ErrBufferFull</span><br><span class="line">func (b *Reader) Peek(n int)([]byte error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Read从b中读出数据到p中，返回读出的字节数和遇到的错误</span><br><span class="line">&#x2F;&#x2F;如果缓存不为空，则只能读出缓存中的数据，不会从底层的io.Reader</span><br><span class="line">&#x2F;&#x2F;中读取数据，如果缓存为空，则：</span><br><span class="line">&#x2F;&#x2F;1.len(p) &gt;&#x3D;缓存大小，则跳过缓存，直接从底层io.Reader中</span><br><span class="line">&#x2F;&#x2F;读出到p中</span><br><span class="line">&#x2F;&#x2F;2.len(p)&lt;缓存大小，则先将数据从底层io.Reader中读取到缓存中，再从缓存读取到p中。</span><br><span class="line">func (b * Reader)Read(p []byte)(n int, err error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Buffered返回缓存中未读取的数据的长度</span><br><span class="line">func (b *Reader)Buffered() int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ReadBytes功能同ReadSlice，只不过返回的是缓存的考本</span><br><span class="line">func (b *Reader)ReadBytes(delim byte)(line []byte, err error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ReadString功能同ReadBytes，只不过返回的是字符串</span><br><span class="line">func (b *Reader) ReadString(delim byte) (line string, err error)</span><br></pre></td></tr></table></figure>
<p>bufio.Write实现了如下接口：</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;NewWriterSize将wr封装成一个带缓存的bufio.Writer对象，</span><br><span class="line">&#x2F;&#x2F;缓存大小由size决定（如果小于4096会被设置为4096）</span><br><span class="line">&#x2F;&#x2F;如果wr的基类型就是有足够缓存的bufio.Writer类型，则直接将</span><br><span class="line">&#x2F;&#x2F;wr转换为基类型返回</span><br><span class="line">func NewWriter(wr io.Writer, size int) *Writer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;NewWriter相当于NewWrietrSize(wr, 4096)</span><br><span class="line">func NewWriter(wr io.Writer) *Writer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;WriteString 功能同write</span><br><span class="line">func (b *Write) WriteString(s string) (int ,error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;WriteRune向b写入r的UTF-8编码，返回r的编码长度</span><br><span class="line">func (b *Write)WriteRune(r rune)(size int, err error)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Flush将缓存中的数据提交到底层的io.Writer中</span><br><span class="line">func (b *Writer) Flush() error</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Available 返回缓存中未使用的空间的长度</span><br><span class="line">func (b *Writer)Available() int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Buffered返回缓存中未提交的数据的长度</span><br><span class="line">func (b *Writer)Buffered() int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Reset将b的底层Writer重新指定为w，同时丢弃缓存中的所有数据，复位</span><br><span class="line">&#x2F;&#x2F;所有标记和错误信息。相当于创建一个新的bufio.Writer</span><br><span class="line">func (b *Writer) Reset(w io.Writer)</span><br><span class="line"></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Docker build的cache机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/17/Docker%20build%E7%9A%84cache%E6%9C%BA%E5%88%B6/"
    >Docker build的cache机制</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/04/17/Docker%20build%E7%9A%84cache%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2022-04-17T11:15:03.000Z" itemprop="datePublished">2022-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker-build的cache机制"><a href="#Docker-build的cache机制" class="headerlink" title="Docker build的cache机制"></a>Docker build的cache机制</h1><h3 id="docker-build命令简介"><a href="#docker-build命令简介" class="headerlink" title="docker build命令简介"></a>docker build命令简介</h3><p>以如下这个Dockerfile为例：</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM Ubuntu:14.04</span><br><span class="line">RUN apt-get update ADD run.sh &#x2F; VOLUME &#x2F;data CMD[&quot;.&#x2F;run.sh&quot;]</span><br></pre></td></tr></table></figure>
<p>随后执行下面一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t&#x3D;&quot;my_new_image&quot;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即可将当前目录下的Dockerfile构建成一个名为my_new_image的镜像，镜像的默认tag是latest。对于以上的docker build请求，Docker Daemon新创建了4层镜像，除了FROM命令，其余的RUN、ADD、VOLUME以及CMD命令都会创建一层新的镜像。</p>
<h3 id="镜像cache机制的介绍"><a href="#镜像cache机制的介绍" class="headerlink" title="镜像cache机制的介绍"></a>镜像cache机制的介绍</h3><p>&emsp;&emsp;Dockerfile可以通过<code>docker build</code>命令构建为一个新的镜像，Dockerfile中的每一条命令都会构建出一个新的镜像层。既然如此，构建成功后宿主机上的镜像层是否会不断增多，导致磁盘空间资源逐渐缩小？另外，一个Dockerfile如果构建多次，对于Dockerfile中的某一指定指令，是否会出现产生多个对应镜像层的情况呢？</p>
<h3 id="docker-build的cache机制"><a href="#docker-build的cache机制" class="headerlink" title="docker build的cache机制"></a>docker build的cache机制</h3><p>&emsp;&emsp;Docker Daemon通过Dockerfile构建镜像时，当发现即将新构建出的镜像与已有的某镜像重复时，可以选择放弃构建新的镜像，也就是采取本地已经cache的镜像作为结果。</p>
<h3 id="cache机制的实现原理："><a href="#cache机制的实现原理：" class="headerlink" title="cache机制的实现原理："></a>cache机制的实现原理：</h3><p>&emsp;&emsp;Docker镜像，由镜像层文件系统和镜像json文件组成，而这两者都含有一个相同的镜像ID。</br></p>
<blockquote>
<p>1.<code>FROM buntu:14.04</code>:FROM命令是Dockerfile中唯一不可缺少的命令，它为最终构建出的镜像设定了一个基础镜像(base image)。docker build命令解析Dockerfile的FROM命令时，可以立即获悉在哪一个镜像基础上完成下一条命令<code>RUN apt-get update</code>的镜像构建。此时，Docker Daemon获取Ubuntu: 14.04镜像的镜像ID，并提取该镜像json文件中的内容，以备下一条命令构建时使用。</br><br>2.<code>RUN apt-get update</code>:RUN命令是在上一层镜像(即ubuntu:14.04镜像)上运行apt-get update，所有对文件系统内容有更新的文件，都会保留于新构建的镜像层中，同时更新上一层镜像的json文件。</p>
</blockquote>
<h3 id="有关docker-build命令的事实："><a href="#有关docker-build命令的事实：" class="headerlink" title="有关docker build命令的事实："></a>有关docker build命令的事实：</h3><blockquote>
<p>1.镜像关系：对于命令<code>RUN apt-get update</code>的构建，一定会产生一个新镜像，新镜像的父镜像ID为ubuntu:14.04的镜像ID。</br><br>2.镜像json文件更新：运行命令<code>apt-get update</code>后产生新镜像，新镜像json文件仅仅更新ubuntu:14.04镜像json文件的cmd属性，其他如config属性均不会修改。</br><br>3.镜像层文件系统内容更新：运行<code>apt-get update</code>后，对于容器可读写层的内容更新，全部将被打包进新镜像的镜像层文件系统内容。</br></p>
</blockquote>
<h3 id="cache机制的核心："><a href="#cache机制的核心：" class="headerlink" title="cache机制的核心："></a>cache机制的核心：</h3><p>&emsp;&emsp;遍历本地所有镜像，发现镜像与即将构建出的镜像一致时，将找到的镜像作为cache镜像，复用cache镜像作为构建结果。</p>
<h3 id="cache机制注意事项"><a href="#cache机制注意事项" class="headerlink" title="cache机制注意事项"></a>cache机制注意事项</h3><p>&emsp;&emsp;cache机制很大程度上做到了镜像的复用，降低存储空间的同时，还大大缩短了构建时间。以下列出使用cache机制的几项注意事项：</p>
<h5 id="ADD命令与COPY命令"><a href="#ADD命令与COPY命令" class="headerlink" title="ADD命令与COPY命令"></a>ADD命令与COPY命令</h5><p>&emsp;&emsp;判断ADD命令或者COPY命令后紧接的文件是否发生变化，成为是否沿用cache的重要依据。Docker采取的策略是：获取Dockerfile下的内容，计算出一个唯一的hash值，若hash值未发生变化，则可以认为文件内容没有发生变化，可以使用cache机制；反之亦然。</p>
<h5 id="RUN命令存在外部依赖"><a href="#RUN命令存在外部依赖" class="headerlink" title="RUN命令存在外部依赖"></a>RUN命令存在外部依赖</h5><p>&emsp;&emsp;以命令<code>RUN apt-get update</code>为例，随着时间的推移，基于同一个基础镜像，一年前的<code>apt-get update</code>和一年后的<code>apt-get update</code>，由于软件源软件的更新，从而导致产生的镜像理论上应该不同。如果继续使用cache机制，将存在不满足用户需求的情况。</br><br>&emsp;&emsp;Docker采取的策略是：用户可以使用参数<code>--no-cache</code>确保获取最新的外部依赖。</br><br><code>docker build --no-cache -t=&quot;my_new_image&quot;</code></p>
<h5 id="树状镜像的关系"><a href="#树状镜像的关系" class="headerlink" title="树状镜像的关系"></a>树状镜像的关系</h5><p>&emsp;&emsp;树状的镜像关系决定了，一次新镜像的成功构建将导致后续的cache机制全部失效。</br><br>&emsp;&emsp;一旦产生一个新的镜像，意味着产生一个新的镜像ID。而当前宿主机环境中肯定不会存在一个镜像，此镜像ID的父镜像ID是新产生镜像的ID。这也是为什么，书写Dockerfile的时候，应该将更多静态的安装、配置命令尽可能地放在Dockerfile的较前位置。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;docker build的cache机制实现了镜像的复用，不仅节省了镜像的存储空间，也为镜像构建节省了大量的时间。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Git踩坑记录"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/11/Git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"
    >Git踩坑记录</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/04/11/Git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2022-04-11T02:56:03.000Z" itemprop="datePublished">2022-04-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Git踩坑记录"><a href="#Git踩坑记录" class="headerlink" title="Git踩坑记录"></a>Git踩坑记录</h1><p>前言：对git的操作使用好像一直停滞在：</p>
<blockquote>
<p>git pull</br><br>git add </br><br>git commit -m</br><br>git push</br></p>
</blockquote>
<p>这几大简单操作上，于是想着开个文档，记录一下其他学习内容，方便后续回顾。</br></p>
<h1 id="Git缓存区"><a href="#Git缓存区" class="headerlink" title="Git缓存区"></a>Git缓存区</h1><h6 id="git-add-files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事："><a href="#git-add-files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事：" class="headerlink" title="git add files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事："></a>git add files把当前工作目录中的文件放入暂存区域，其实主要做了以下两件事：</h6><blockquote>
<p>1.将本地文件的时间戳、长度，当前文档对象的id等信息保存到一个树形目录中去</br><br>2.将本地文件的内容做快照并保存到Git的对象库。</p>
</blockquote>
<p>综上所述，暂存区实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等），文件的内容并不存储其中，而是保存在Git对象库(.git/objects)中，文件索引建立了文件和对象库中对象实体之间的对应。</br><br>有关git暂存区的命令学习：</br></p>
<blockquote>
<p>1.<code>git rm --cached 文件名</code></br><br>这个命令不会删除物理文件，只是将已经add进缓存的文件删除。</br><br>2.<code>git rm --f 文件名</code></br><br>这个命令不仅将文件从缓存中删除，还会将物理文件删除，所以使用这个命令要非常谨慎。</br><br>3.若删除已经添加缓存的某一个目录下所有文件的话需要添加一个参数-r</br><br><code>git rm -r --cached 文件名</code></p>
</blockquote>
<h1 id="git-submodule用法整理"><a href="#git-submodule用法整理" class="headerlink" title="git submodule用法整理"></a>git submodule用法整理</h1><p>&emsp;&emsp;有submodule的仓库在当前目录会有个<code>.gitmodules</code>文件。记录path和url。这里表示项目引用子模块的关系</br><br>&emsp;&emsp;克隆带有子模块的项目后，需要初始化并拉取子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"># 上面两条命令的组合，一般直接使用组合命令</span><br><span class="line">git submodule update --init</span><br><span class="line">#可以加上--recursive拉取嵌套的子模块（子模块中还包含有其他子模块）</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;或者可以在clone代码时加上<code>--recurse-submodules</code>选项自动完成拉取</br><br><code>git clone --recurse-submodules &lt;main-project-repo-url&gt;</code><br>当需要更新子模块时，可以使用下面的指令，不用切目录就能进行手动更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote [submodule-path]</span><br></pre></td></tr></table></figure>
<p>上述所有命令都默认拉取的是master分支的代码，如果想拉取其他分支，则进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -f .gitmodules submodule.&lt;submodule-name&gt;.branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Linux入门学习指南"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/29/Linux%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"
    >Linux入门学习指南</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/03/29/Linux%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" class="article-date">
  <time datetime="2022-03-29T08:56:03.000Z" itemprop="datePublished">2022-03-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux入门学习"><a href="#Linux入门学习" class="headerlink" title="Linux入门学习"></a>Linux入门学习</h1><h2 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1.什么是操作系统"></a>1.什么是操作系统</h2><p>&emsp;&emsp;操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能：如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如：</br></p>
<blockquote>
<p>(1)文件系统：提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。</br><br>(2)设备驱动程序：提供连接计算机每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。（不了解硬件结构，但对如何操作底层硬件是透明的。）</br><br>(3)用户接口：操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的Windows图形界面，可以理解为一种用户与操作系统交互的方式。</br><br>(4)系统服务程序：当计算机启动时，会自启许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。</p>
</blockquote>
<h2 id="2-Linux介绍"><a href="#2-Linux介绍" class="headerlink" title="2.Linux介绍"></a>2.Linux介绍</h2><p>&emsp;&emsp;Linux系统可以抽象为三个层次：①底层是UNIX/Linux操作系统，即系统内核(Kernel)；②中间层是shell层，即命令解释层。③高层：应用层</br></p>
<blockquote>
<p>(1)内核层：内核层是UNIX/Linux系统的核心与基础，它直接附着在硬件平台上，控制和管理系统内各种资源(硬件资源和软件资源)，有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</br><br>(2)Shell层：Shell层是与用户直接交互的界面。用户可以在提示符下输入命令行，由Shell解释执行并输出相应结果或者有关信息，所以我们也把Shell称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</br><br>(3)应用层：应用层提供基于X Window协议的图形环境</p>
</blockquote>
<h2 id="3-Linux相比Windows的优点"><a href="#3-Linux相比Windows的优点" class="headerlink" title="3.Linux相比Windows的优点"></a>3.Linux相比Windows的优点</h2><blockquote>
<p>(1)大量的可用软件及免费软件</br><br>(2)良好的可移植性和灵活性</br><br>(3)优良的稳定性和安全性</br><br>(4)支持几乎所有的网络协议及开发语言</br></p>
</blockquote>
<h2 id="4-常见的Linux发行版本"><a href="#4-常见的Linux发行版本" class="headerlink" title="4.常见的Linux发行版本"></a>4.常见的Linux发行版本</h2><p>&emsp;&emsp;说明：林纳斯托瓦刺开发的Linux是一个内核版本。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件。</br><br>&emsp;&emsp;现在市面上常见的Linux系统不如说是：“以Linux为核心的操作系统软件包”。</br></p>
<blockquote>
<p>red hat</br><br>Ubuntu:桌面系统好</br><br>SuSE linux：实现了较好地与Windows的交互。</br><br>Gentoo linux：快速、设计干净且有弹性。</br></p>
</blockquote>
<h2 id="5-Linux远程管理协议"><a href="#5-Linux远程管理协议" class="headerlink" title="5.Linux远程管理协议"></a>5.Linux远程管理协议</h2><h3 id="常用的远程管理协议有以下四种："><a href="#常用的远程管理协议有以下四种：" class="headerlink" title="常用的远程管理协议有以下四种："></a>常用的远程管理协议有以下四种：</h3><blockquote>
<p>(1)RDP(remote desktop protocol)：远程桌面协议，Windows系统中的远程桌面管理就基于该协议</br><br>(2)RFB(remote framebuffer)图形化远程管理协议，VNC远程管理工具基于此协议。</br><br>(3)Telnet 命令行界面远程管理程序，几乎所有操作协同都默认支持该协议。此协议的特点是：数据传送采用明文方式，不对传输数据进行加密。</br><br>(4)SSH(Secure Shell)：命令行界面远程管理协议，几乎所有操作系统都默认支持该协议。区别于Telnet，该协议在数据传送时会对数据进行加密并压缩，因此以该协议进行数据传送既安全又快速。(其基本代替了SSH)</br></p>
</blockquote>
<h3 id="linux远程管理软件"><a href="#linux远程管理软件" class="headerlink" title="linux远程管理软件"></a>linux远程管理软件</h3><blockquote>
<p>(1)基于VNC，图形远程管理软件。</br><br>(2)基于SSH协议的命令行操作管理。</br><br>(3)类似Webmin的基于浏览器的管理，该种方式下管理功能有限。</br></p>
</blockquote>
<h2 id="6-Linux软件包"><a href="#6-Linux软件包" class="headerlink" title="6.Linux软件包"></a>6.Linux软件包</h2><p>&emsp;&emsp;Linux软件包几乎都是经GPL授权的。这意味着如果你具备修改软件源代码的能力，可以随意地修改软件源代码。</br></p>
<h4 id="Linux源码包"><a href="#Linux源码包" class="headerlink" title="Linux源码包"></a>Linux源码包</h4><p>源码包的安装需要很长时间的编译过程</br><br>例：MySQL安装包的大小只有23M，但其安装却需要30分钟左右的时间</p>
<h4 id="Linux二进制包"><a href="#Linux二进制包" class="headerlink" title="Linux二进制包"></a>Linux二进制包</h4><p>二进制包在发布之前就已经完成了编译的工作。目前主要有2大主流的二进制包管理系统：</br></p>
<blockquote>
<p>1.RPM包管理系统：功能强大，安装、升级、查询和卸载非常简单方便。因此很多Linux发行版都默认采用此机制做为软件安装包的管理方式。</br><br>2.DPKG包管理方式：由Debian Linux所开发的软件包管理方式。主要应用在Debian和Ubuntu中</p>
</blockquote>
<h4 id="源码包VSRPM二进制包"><a href="#源码包VSRPM二进制包" class="headerlink" title="源码包VSRPM二进制包"></a>源码包VSRPM二进制包</h4><p>源码包一般包含多个文件，为了方便发布，一般会对源码包做打包处理。Linux中最常用的打包格式是”tar.gz”。因此源码包也会被称为tarball。</br><br>源码包需要我们去软件官方网站进行下载，其一般包含如下内容：</br></p>
<blockquote>
<p>1.源代码文件</br><br>2.配置和检测程序（如configure或config）</br><br>3.软件安装说明和软件说明(如INSTALL或README)</br></p>
</blockquote>
<p>总得来说，使用源码包安装软件具有以下好处：</br></p>
<blockquote>
<p>1.开源，能力足够的话可以自行修改源码。</br><br>2.可以自由选择所需的功能。</br><br>3.软件采用编译安装的方式。更适合自己的系统、更加稳定、效率也更高。</br></p>
</blockquote>
<p>但同时，使用源码包安装软件也存在以下几点不足：</br></p>
<blockquote>
<p>1.安装过程步骤较多、容易出错。</br><br>2.编译时间较长导致的安装时间较长。</br><br>3.因为软件是编译安装的，编译过程一旦出错，新手很难解决。</br></p>
</blockquote>
<p>使用RPM包安装软件具有以下好处：</br></p>
<blockquote>
<p>1.包管理系统简单，只需要几个命令就可以实现包的安装、升级、查询和卸载。</br></p>
</blockquote>
<p>使用RPM包安装软件存在以下不足：</br></p>
<blockquote>
<p>1.经过编译，不能再看到源代码。</br><br>2.功能选择不如源码包灵活。</br><br>3.依赖性有可能非常强。</br></p>
</blockquote>
<h2 id="7-yum源及其配置"><a href="#7-yum源及其配置" class="headerlink" title="7.yum源及其配置"></a>7.yum源及其配置</h2><p>&emsp;&emsp;yum，全称“Yellow dog Updater, Modified”,是一个专门为了解决包的依赖关系而存在的软件包管理器。yum是改进型的RPM软件管理器，它很好地解决了RPM软件包依赖问题。</br><br>&emsp;&emsp;当管理员使用yum安装RPM包时，yum会先从服务器端下载RPM包的依赖文件</p>
<h2 id="8-Linux文件系统管理"><a href="#8-Linux文件系统管理" class="headerlink" title="8.Linux文件系统管理"></a>8.Linux文件系统管理</h2><h4 id="硬盘结构详解"><a href="#硬盘结构详解" class="headerlink" title="硬盘结构详解"></a>硬盘结构详解</h4><p>硬盘是计算机的主要外部存储设备，从存储数据的介质上来区分，硬盘可分为机械硬盘和固态硬盘，具体区别就不在此处赘述了。</br></p>
<h4 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h4><p>用于显示Linux系统中各文件系统的硬盘使用情况：包括文件系统所在硬盘分区的总容量、已使用容量、剩余容量等。采用df命令，显示出的各列信息的含义分别是：</p>
<blockquote>
<p>1.Filesystem: 表示该文件系统位于哪个分区，因此该列显示的是设备名称。</br><br>2.1K-blocks：此列表示文件系统的总大小，默认以KB为单位。</br><br>3.Used: 表示用掉的硬盘空间的大小。</br><br>4.Available：表示剩余的硬盘空间大小。</br><br>5.Use%：硬盘空间使用率。容量不足时，会严重影响系统的正常运行。</br><br>6.Mounted on：文件系统的挂载点，也就是硬盘挂载的目录位置</br></p>
</blockquote>
<h4 id="挂载Linux系统外的文件"><a href="#挂载Linux系统外的文件" class="headerlink" title="挂载Linux系统外的文件"></a>挂载Linux系统外的文件</h4><p>挂载的定义：将硬件设备的文件系统和Linux系统中的文件系统，通过指定目录（作为挂载点）进行关联。而要将文件挂载到Linux系统上，需要使用mount挂载命令。</br></p>
<h4 id="Linux物理内存与虚拟内存"><a href="#Linux物理内存与虚拟内存" class="headerlink" title="Linux物理内存与虚拟内存"></a>Linux物理内存与虚拟内存</h4><blockquote>
<p>1.物理内存就是系统硬件提供的内存的大小</br><br>2.虚拟内存：用磁盘虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间（swap空间）</br></p>
</blockquote>
<p>Linux会在物理内存不足时，使用交换分区的虚拟内存。</br><br>Linux的内存管理采取的是分页存储机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据库自动交换到虚拟内存中，而将经常使用的信息保留在物理内存。</p>
<h2 id="9-Linux进程管理"><a href="#9-Linux进程管理" class="headerlink" title="9.Linux进程管理"></a>9.Linux进程管理</h2><p>&emsp;&emsp;windows中的进程管理工具：任务管理器。</br><br>&emsp;&emsp;通常，使用任务管理器，主要有如下三个目的：</br></p>
<blockquote>
<p>(1)利用“应用程序”和“进程”标签来查看系统中到底运行了哪些程序和进程。</br><br>(2)利用“性能”和“用户”标签来判断服务器的健康状态。</br><br>(3)在“应用程序”和“进程”标签中强制终止任务和进程。</br></p>
</blockquote>
<h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>&emsp;&emsp;进程是正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源.</br><br>&emsp;&emsp;这也就是说，在操作系统中，所有可以执行的程序和命令都会产生进程。有的进程寿命很短。但还有一些进程，比如httpd进程，启动之后就会一直驻留在系统当中，我们把这样的进程称为<code>常驻内存进程</code>。</br></p>
<h3 id="进程的作用"><a href="#进程的作用" class="headerlink" title="进程的作用"></a>进程的作用</h3><p>&emsp;&emsp;杀死进程（强制终止进程）不过是进程管理工作中最不常用的手段，因为每个进程都有自己正确的结束方法，而杀死进程是在正常方法已经失效的情况下的后备手段。</br></p>
<blockquote>
<p>1.判断服务器的健康状态</br><br>如果当前服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。</br><br>2.查看系统中的所有进程。</br><br>3.杀死进程</br><br>一般情况下，当需要停止服务时，会通过正确关闭命令来停止服务(如apache服务可以通过service httpd stop命令来关闭)。如果正确终止进程的命令失效，才会考虑使用kill命令杀死进程</p>
</blockquote>
<h3 id="Linux启动进程的方式"><a href="#Linux启动进程的方式" class="headerlink" title="Linux启动进程的方式"></a>Linux启动进程的方式</h3><p>在Linux系统中，任务可以被配置在指定的时间、日期或者系统平均负载量低于指定值时自动启动。</p>
<h3 id="缓冲和缓存的区别"><a href="#缓冲和缓存的区别" class="headerlink" title="缓冲和缓存的区别"></a>缓冲和缓存的区别</h3><blockquote>
<p>缓存(cache)是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而去缓存中读取。</br><br>缓冲(buffer)是在向硬盘写入数据时，先把数据放入缓冲区，然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</br><br>简单来说，cache时用来加速数据从硬盘中“读取”的，而buffer是用来加速数据写入硬盘的。</p>
</blockquote>
<h2 id="10-一些小众命令的学习"><a href="#10-一些小众命令的学习" class="headerlink" title="10.一些小众命令的学习"></a>10.一些小众命令的学习</h2><h3 id="1-tailf"><a href="#1-tailf" class="headerlink" title="(1) tailf"></a>(1) tailf</h3><p>在屏幕上显示指定文件的末尾若干行内容，通常用于日志文件的跟踪输出</p>
<h5 id="tailf与tail-f的区别："><a href="#tailf与tail-f的区别：" class="headerlink" title="tailf与tail -f的区别："></a>tailf与tail -f的区别：</h5><blockquote>
<p>1.tailf总是从文件开头一点一点的读， 而tail -f则是从文件尾部开始读。</br><br>2.tailf check文件增长时，使用的是文件名，用stat系统调用；而tail -f则使用的是已打开的文件描述符；注：tail也可以做到类似跟踪文件名的效果；但是tail总是使用fstat系统调用，而非stat系统调用。结果就是：默认情况下，当tail的文件被偷偷删除时，tail是不知道的，而tailf是知道的。</p>
</blockquote>
<h5 id="补充说明：stat、lstat和fstat系统调用的区别"><a href="#补充说明：stat、lstat和fstat系统调用的区别" class="headerlink" title="补充说明：stat、lstat和fstat系统调用的区别"></a>补充说明：stat、lstat和fstat系统调用的区别</h5><p>&emsp;&emsp;stat系统调用系列包括了：fstat、stat和lstat，它们都是用来返回“相关文件状态信息”的，三者的不同之处在于设定源文件的方式不同；</br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fstat(int fields, struct stst *buf);</span><br><span class="line">int stat(const char *path, struct stat *buf)</span><br><span class="line">int lstat(const char *path, struct stat *buf)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.fstat区别于另外两个系统调用的地方在于：fstat系统调用接受的是一个“文件描述符”， 而另外两个则直接接受“文件全路径”。</br><br>2.stat与lstat的区别在于：当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；而stat返回的是该链接指向的文件的信息。</br></p>
</blockquote>
<h5 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tailf logfile #动态跟踪日志文件logfile，最初的时候打印文件的最后十行的内容</span><br></pre></td></tr></table></figure>
<h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n, --lines NUMBER #输出最后行数</span><br><span class="line">-V, --version #输出版本信息并退出</span><br><span class="line">-h, --help #显示帮助并退出</span><br></pre></td></tr></table></figure>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tailf -n 5 logfile.log #显示文件最后五行的内容</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> twilight2017
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="瑟兰迪尔"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E8%AF%BB%E4%B9%A6">读书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/travels">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E9%9A%8F%E7%AC%94">随笔</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>