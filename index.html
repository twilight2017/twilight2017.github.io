<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     瑟兰迪尔
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">瑟兰迪尔</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['竹杖芒鞋轻胜马', '谁怕？', '一蓑烟雨任平生'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: false
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-HTTP协议概览"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/03/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A7%88/"
    >HTTP协议概览</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/03/03/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A7%88/" class="article-date">
  <time datetime="2023-03-03T09:02:52.000Z" itemprop="datePublished">2023-03-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="一-使用HTTP协议访问Web"><a href="#一-使用HTTP协议访问Web" class="headerlink" title="一.使用HTTP协议访问Web"></a>一.使用HTTP协议访问Web</h2><blockquote>
<p>基本工作方式：Web浏览器地址栏中指定URL，Web浏览器从Web服务器端获取文件资源(resource)等信息，从而显示出Web页面。这种通过发送请求获取服务器资源的Web浏览器等，都可以称为客户端(client)。</p>
</blockquote>
<p>Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程。可以说：<b>Web是建立在HTTP协议上通信的。</b></p>
<h2 id="二-网络基础TCP-IP"><a href="#二-网络基础TCP-IP" class="headerlink" title="二.网络基础TCP/IP"></a>二.网络基础TCP/IP</h2><blockquote>
<p>通常使用的网络(包括互联网)是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。</p>
</blockquote>
<h3 id="2-1-TCP-IP协议族"><a href="#2-1-TCP-IP协议族" class="headerlink" title="2.1 TCP/IP协议族"></a>2.1 TCP/IP协议族</h3><blockquote>
<p>TCP/IP是互联网相关的各类协议族的总称，其家族成员包括：IP、ICMP、IEEEE802.3、FDDI、TCP、FTP、SNMP、HTTP、DNS、UDP等。</p>
</blockquote>
<p>协议中存在着各式各样的内容，从电缆的规格到IP地址的选定方法，寻找异地用户的方法、双方建立通信的顺序、以及Web页面显示需要处理的步骤。</br><br>TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分为以下4层：应用层、传输层、网络层和数据链路层</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。比如：FTP(File Transfer Protocol， 文件传输协议)和DNS(DOmain Name System， 域名系统)服务就是其中的两类。HTTP协议也处于该层。</li>
<li>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP(Transmission COntrol Protocol，传输控制协议)和UDP(User Data protocol， 用户数据报协议)。</li>
<li>网络层：用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位，该层规定了通过怎样的路径到达对方计算机，并把数据包发送给对方。</li>
<li>链路层：又名数据链路层，网络接口层。用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC网卡，及光纤等物理可见部分。</li>
</ul>
<p>举例：</br><br>&emsp;&emsp;首先作为发送端的客户端在应用层(HTTP协议)发出一个想看某个Web页面的HTTP请求。接着，为了传输方便，在传输层(TCP)协议把从应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文上打上标记符号及端口号后转发给网络层。</br><br>&emsp;&emsp;在网络层(IP)协议，增加作为通信目的地的MAC地址后转发给链路层，这样一来，发往网络的通信请求就准备齐全了。</br><br>&emsp;&emsp;接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。</br><br>&emsp;&emsp;发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层会把对应的首部消去。这种把数据信息包装起来的做法称为封装(en-capsilate)。</p>
<h3 id="2-2-与HTTP关系密切的协议：IP、TCP和DNS"><a href="#2-2-与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="2.2 与HTTP关系密切的协议：IP、TCP和DNS"></a>2.2 与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="2-2-1-负责传输的IP协议"><a href="#2-2-1-负责传输的IP协议" class="headerlink" title="2.2.1 负责传输的IP协议"></a>2.2.1 负责传输的IP协议</h4><blockquote>
<p>按层次分，IP网络协议位于网络层。</p>
</blockquote>
<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。简单来说，MAC地址标记了计算机的物理地址。</p>
<ul>
<li>ARP协议凭借MAC地址进行通信：Address Resolution Protocol。一种用于解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。<h4 id="2-2-2-确保可靠性的TCP协议"><a href="#2-2-2-确保可靠性的TCP协议" class="headerlink" title="2.2.2 确保可靠性的TCP协议"></a>2.2.2 确保可靠性的TCP协议</h4><blockquote>
<p>按层次分，TCP位于传输层，提供可靠的字节流服务。所谓的字节流服务(Byte Stream Service)是指，为了方便传输，将大块数据分割成以报文段(segment)为单位的数据包进行管理，而可靠的传输服务是指，能够把数据准确可靠地传给对方。</p>
</blockquote>
</li>
<li>确保数据能到达目标：三次握手策略<h4 id="2-2-3-负责域名解析的DNS服务"><a href="#2-2-3-负责域名解析的DNS服务" class="headerlink" title="2.2.3 负责域名解析的DNS服务"></a>2.2.3 负责域名解析的DNS服务</h4><blockquote>
<p>DNS(Domain Name System)服务适合HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。</p>
</blockquote>
</li>
</ul>
<p>用户通常使用主机名或域名来访问对方的计算机，而非直接通过IP地址访问。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。</p>
<h2 id="三-深入理解HTTP协议"><a href="#三-深入理解HTTP协议" class="headerlink" title="三.深入理解HTTP协议"></a>三.深入理解HTTP协议</h2><blockquote>
<p>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一段是客户端，另一端则是服务器端。有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的。而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。</p>
</blockquote>
<p>下面是从客户端发送给某个HTTP服务器端的请求报文中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.htm HTTP&#x2F;1.1</span><br><span class="line">Host:hacker.jp</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;起始行开头的GET表示请求访问服务器的类型。称为方法(method)。随后的字符串<code>/index.htm</code>指明了请求访问的资源对象，也叫做请求URI。最后的<code>HTTP/1.1</code>，即HTTP的版本号，用来提示客户端使用的HTTP协议功能。</br><br>&emsp;&emsp;综合来看，这段请求的含义是：请求访问某台HTTP服务器上的/index.htm页面资源。</br><br>&emsp;&emsp;请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</br><br>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text&#x2F;html</span><br></pre></td></tr></table></figure>
<ul>
<li>起始行开头的HTTP/1.1表示服务器对应的HTTP版本</li>
<li>200 OK表示请求结果的状态码和原因短语。下一行显示了创建响应的日期时间，是首部字段内的一个属性。</li>
</ul>
<p>响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成</p>
<h3 id="3-1-不保存状态的HTTP协议"><a href="#3-1-不保存状态的HTTP协议" class="headerlink" title="3.1 不保存状态的HTTP协议"></a>3.1 不保存状态的HTTP协议</h3><blockquote>
<p>HTTP是一种无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存，也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计的如此简单的。</p>
</blockquote>
<p>HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能。于是引入了Cookie技术。有了Cookie技术再用HTTP协议通信，就可以管理状态了</p>
<h3 id="3-2-介绍HTTP-1-1中可使用的方法"><a href="#3-2-介绍HTTP-1-1中可使用的方法" class="headerlink" title="3.2 介绍HTTP/1.1中可使用的方法"></a>3.2 介绍HTTP/1.1中可使用的方法</h3><h4 id="3-2-1-GET"><a href="#3-2-1-GET" class="headerlink" title="3.2.1 GET"></a>3.2.1 GET</h4><blockquote>
<p>用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容</p>
</blockquote>
<h4 id="3-2-2-POST"><a href="#3-2-2-POST" class="headerlink" title="3.2.2 POST"></a>3.2.2 POST</h4><blockquote>
<p>用来传输实体的主体</p>
</blockquote>
<h4 id="3-2-3-PUT"><a href="#3-2-3-PUT" class="headerlink" title="3.2.3 PUT"></a>3.2.3 PUT</h4><blockquote>
<p>用于传输文件。</p>
</blockquote>
<p>但是，鉴于HTTP/1.1方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST标准的同类Web网站，就可能会开放使用PUT方法。</p>
<h4 id="3-2-4-HEAD"><a href="#3-2-4-HEAD" class="headerlink" title="3.2.4 HEAD"></a>3.2.4 HEAD</h4><blockquote>
<p>获取报文首部。HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p>
</blockquote>
<h4 id="3-2-5-DELETE"><a href="#3-2-5-DELETE" class="headerlink" title="3.2.5 DELETE"></a>3.2.5 DELETE</h4><blockquote>
<p>删除文件。是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。</p>
</blockquote>
<p>但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。</p>
<h4 id="3-2-6-OPTIONS"><a href="#3-2-6-OPTIONS" class="headerlink" title="3.2.6 OPTIONS"></a>3.2.6 OPTIONS</h4><blockquote>
<p>查询针对请求URI指定的资源支持的方法<br>请求</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure>
<p>响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Allow: GET、POST、HEAD、OPTIONS</span><br></pre></td></tr></table></figure>
<h3 id="3-3-持久连接"><a href="#3-3-持久连接" class="headerlink" title="3.3 持久连接"></a>3.3 持久连接</h3><blockquote>
<p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。随着请求量增大，每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。</p>
</blockquote>
<p>未解决上述TCP连接的问题，想出了HTTP持久连接即HTTP keep-alive的方法。持久连接的特点是，只要任意一段没有明确提出断开连接，则保持TCP连接状态</p>
<h4 id="3-3-1-使用Cookie的状态管理"><a href="#3-3-1-使用Cookie的状态管理" class="headerlink" title="3.3.1 使用Cookie的状态管理"></a>3.3.1 使用Cookie的状态管理</h4><blockquote>
<p>HTTP是无状态协议，不对之前发生过的请求和响应进行管理。假设要求登录认证的Web页面本身无法进行状态的管理，就要在每次请求报文中附加参数来管理登录状态。于是引入了Cookie技术</p>
</blockquote>
<h5 id="Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态"><a href="#Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态" class="headerlink" title="Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态"></a>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态</h5><p>&emsp;&emsp;Cookie会根据从服务器端发出的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</br><br>&emsp;&emsp;服务器端发现客户端发从过来的Cookie后，会去检查究竟是从哪一个客户端发送过来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。<br>下述报文描述了Cookie报文交互的情景<br>请求报文（没有Cookie信息的状态）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;reader&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">* 首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure>
<p>响应报文（服务器端生成Cookie信息）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server:Apache</span><br><span class="line">&lt;Set-Cookie: sid&#x3D;1236987890;path&#x3D;,</span><br><span class="line">;expired&#x3D;Wed,</span><br><span class="line">10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-type: text&#x2F;plain;charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure>
<p>请求报文（自动发送保存着的Cookie信息）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;image&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid&#x3D;1236987890</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-HTTP状态码"><a href="#3-3-2-HTTP状态码" class="headerlink" title="3.3.2 HTTP状态码"></a>3.3.2 HTTP状态码</h4><h5 id="状态码告知从服务器端返回的请求结果"><a href="#状态码告知从服务器端返回的请求结果" class="headerlink" title="状态码告知从服务器端返回的请求结果"></a>状态码告知从服务器端返回的请求结果</h5><blockquote>
<p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Rediction(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<ul>
<li>200 OK:从客户端发来的请求在服务器端被正常处理了</li>
<li>204 No Content:在返回的响应报文中不含实体的主体部分</li>
<li>206 Partial Content:客户端进行了范围请求，响应报文中包含由Content-Range指定范围的实体内容。</li>
<li>301 Moved Permanently:请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI</li>
<li>302 Found:表示请求的资源已经被分配了新的URI，希望用户本次能使用新的URI访问</li>
<li>303 See Other:请求对应的资源存在着另一个URI，应使用<b>GET方法</b>定向获取请求的资源</li>
<li>304 Not Modified:客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。</li>
<li>307 Temporary Redirect:与302 Found有着相同的含义</li>
<li>400 Bad Request:请求报文中存在语法错误</li>
<li>401 Unauthorized:发送的请求必须有通过HTTP认证的认证信息</li>
<li>403 Forbidden:请求资源的访问被服务器拒绝了</li>
<li>404 Not Found: 服务器上无法找到请求的资源</li>
<li>500 Internal Server Error:服务器端在执行请求时发生了错误</li>
<li>503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求<h3 id="3-4-通信数据转发程序：代理、网关、隧道"><a href="#3-4-通信数据转发程序：代理、网关、隧道" class="headerlink" title="3.4 通信数据转发程序：代理、网关、隧道"></a>3.4 通信数据转发程序：代理、网关、隧道</h3><h4 id="3-4-1-代理"><a href="#3-4-1-代理" class="headerlink" title="3.4.1 代理"></a>3.4.1 代理</h4><blockquote>
<p>资源中转站</p>
</blockquote>
</li>
</ul>
<p>在HTTP通信过程中，可以级联多台代理服务器，请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。使用代理服务器的理由有：</p>
<ul>
<li>利用缓存技术减少网络带宽的流量</li>
<li>组织内部针对特定网站的访问控制</li>
<li>以获取访问日志为主要目的</li>
</ul>
<p>代理有多种使用方式，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p>
<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。当代理再次接收到相对资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p>
<h5 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h5><p>转发请求或响应时，不对报文做任何加工的代理。对报文内容进行加工的代理被称为非透明代理</p>
<h4 id="3-4-2-网关"><a href="#3-4-2-网关" class="headerlink" title="3.4.2 网关"></a>3.4.2 网关</h4><blockquote>
<p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p>
</blockquote>
<h4 id="3-4-3-隧道"><a href="#3-4-3-隧道" class="headerlink" title="3.4.3 隧道"></a>3.4.3 隧道</h4><p>&emsp;&emsp;隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</br><br>&emsp;&emsp;隧道本身不会去解析HTTP请求。也就是说，请求保持鸳鸯中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<h3 id="3-5-HTTP首部"><a href="#3-5-HTTP首部" class="headerlink" title="3.5 HTTP首部"></a>3.5 HTTP首部</h3><blockquote>
<p>HTTP协议的请求和响应报文中必定包含HTTP首部，只是我们平常在使用Web的时候感受不到它，这一部分重点讨论这部分内容。报文首部在客户端和服务器处理时起到至关重要的作用。<br>下面是一段HTTP请求报文的示例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host:hackr.jp</span><br><span class="line">User-Agent:Mozilla&#x2F;5.0 (Windows NT 6.1;WOW64;rv:13.0) Gecko&#x2F;20100101 Firefox&#x2F;13.0</span><br><span class="line">Accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language:ja，en-usq。3</span><br><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line">DNT:1</span><br><span class="line">Connection-keep-alive</span><br><span class="line">If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class="line">IF-None-Match: &quot;45bae1-16a-46d776ed&quot;</span><br><span class="line">Cache-Control:max-age&#x3D;0</span><br></pre></td></tr></table></figure>
<p>下面是一段HTTP响应报文示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 304 Not Modified</span><br><span class="line">Date: Thu, 07 Jun 2012 07:12:36 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Connection: close</span><br><span class="line">Etag: &quot;45bae1-16a-46d6787&quot;</span><br></pre></td></tr></table></figure>
<p>首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。HTTP首部字段是构成HTTP报文的要素之一。在客户端和服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。</p>
<h4 id="3-5-1-HTTP-1-1-通用首部字段"><a href="#3-5-1-HTTP-1-1-通用首部字段" class="headerlink" title="3.5.1 HTTP/1.1 通用首部字段"></a>3.5.1 HTTP/1.1 通用首部字段</h4><ul>
<li><p>Cache-Control：操作缓存的工作机制</p>
</li>
<li><p>Connection：控制不再转发给代理的首部字段；管理持久连接（HTTP/1.1版本的默认连接都是持久连接）</p>
</li>
<li><p>Date：创建HTTP报文的日期和时间</p>
</li>
<li><p>Transfer-Encoing：传输报文主体时采用的编码方式</p>
</li>
<li><p>Upgrade:检测HTTP协议以及其他协议是否可使用更高的版本进行通信。</p>
</li>
<li><p>Via:追踪客户端和服务器之间的请求和响应报文的传输路径。当报文经过代理或者网关时，会先在首部字段Via中附加该服务器信息，然后再进行转发。还可以避免请求回环的发生。所以必须在经过代理时附加该首部字段的内容</p>
</li>
<li><p>Warning：通常会告知用户一些与缓存相关的问题的警告</p>
<h4 id="3-5-2-请求首部字段"><a href="#3-5-2-请求首部字段" class="headerlink" title="3.5.2 请求首部字段"></a>3.5.2 请求首部字段</h4><blockquote>
<p>请求首部字段是从客户端发往服务器端发送的请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
</blockquote>
</li>
<li><p>Accept：通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。若想要给显示的媒体类型增加优先级，则使用<code>q=</code>字段来额外表示权重，权重范围是0~1。</p>
</li>
<li><p>Accept-Charset：通知服务器用户代理支持的字符集及字符集的相对优先顺序</p>
</li>
<li><p>Accept-Encoding：告知服务器用户代理支持的内容编码及内容编码的优先级顺序。</p>
</li>
<li><p>Accept-Language：告知服务器用户代理能够处理的自然语言集以及自然语言集的相对优先级</p>
</li>
<li><p>Authorization：告知服务器，用户代理的认证信息</p>
</li>
<li><p>From：告知服务器使用用户代理的用户的电子邮件地址</p>
</li>
<li><p>Host：告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段</p>
</li>
<li><p>If-Match：条件请求字段，服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>
</li>
<li><p>Proxy-Authorization：从代理服务器发送来的认证质询。这个认证过程发生在客户端和代理之间</p>
</li>
<li><p>User-Agent：会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>
<h4 id="3-5-3-响应首部字段"><a href="#3-5-3-响应首部字段" class="headerlink" title="3.5.3 响应首部字段"></a>3.5.3 响应首部字段</h4><blockquote>
<p>是由服务器端向客户端返回响应报文中所使用的字段。用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息</p>
</blockquote>
</li>
<li><p>Retry-After：告知客户端应该在多久之后再次发送请求</p>
</li>
<li><p>Server：告知客户端当前服务器上安装的HTTP服务器应用程序的信息。</p>
</li>
<li><p>Vary：可对缓存进行控制</p>
</li>
<li><p>WWW-Authentication：用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案(Basic或是Digest)</p>
<h4 id="3-5-3-实体首部字段"><a href="#3-5-3-实体首部字段" class="headerlink" title="3.5.3 实体首部字段"></a>3.5.3 实体首部字段</h4><blockquote>
<p>包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p>
</blockquote>
</li>
<li><p>Allow-通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器接收到不支持的HTTP方法时，会以状态码<code>405 Method Not Allowed</code>作为响应返回。</p>
</li>
<li><p>Content-Encoding：告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。(可选：gzip、compress、deflate、identity)</p>
</li>
<li><p>Content-Language：告知客户端，实体主体使用的自然语言</p>
</li>
<li><p>Content-Length：实体主体部分的大小(单位：字节)</p>
</li>
<li><p>Content-Location：与报文主体部分相对应的URI</p>
</li>
<li><p>Content-MD5：一串由MD5算法生成的值，目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达</p>
</li>
<li><p>Content-Type：实体主体内对象的媒体类型</p>
</li>
<li><p>Expires：将资源的失效日期告知客户端。在Expires字段指定的时间之前，响应的副本会一直以缓存的形式保存</p>
<h4 id="3-5-4-为Cookie服务的首部字段"><a href="#3-5-4-为Cookie服务的首部字段" class="headerlink" title="3.5.4 为Cookie服务的首部字段"></a>3.5.4 为Cookie服务的首部字段</h4><blockquote>
<p>Cookie的工作机制是用户识别及状态管理。调用Cookie时，由于可校验Cookie的有效期、以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。</p>
</blockquote>
<h2 id="四-确保Web安全的HTTPS"><a href="#四-确保Web安全的HTTPS" class="headerlink" title="四.确保Web安全的HTTPS"></a>四.确保Web安全的HTTPS</h2><blockquote>
<p>在HTTP协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。</p>
</blockquote>
<h3 id="4-1-HTTP的缺点"><a href="#4-1-HTTP的缺点" class="headerlink" title="4.1 HTTP的缺点"></a>4.1 HTTP的缺点</h3><p>事物兼具两面性，HTTP协议具有以下不足之处：</p>
</li>
<li><p>通信使用明文(不加密)，内容可能会被窃听</p>
</li>
<li><p>不验证通信方的身份，因此有可能遭遇伪装</p>
</li>
<li><p>无法证明报文的完整性，所以有可能已遭篡改</p>
</li>
</ul>
<p>这些问题不仅在HTTP上出现，其他未加密的协议中也会存在这类问题。HTTP协议中没有加密机制，但可以通过和SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer, Security，安全层传输协议)的组合使用，加密HTTP的通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS。</br></p>
<h3 id="4-2-不验证通信方的身份就可能遭遇伪装"><a href="#4-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="4.2 不验证通信方的身份就可能遭遇伪装"></a>4.2 不验证通信方的身份就可能遭遇伪装</h3><blockquote>
<p>常说的证书用于通信双方的权限验证。虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段。</p>
</blockquote>
<p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常苦难的。所以只要能够确认通信方（客户端或者服务器端）持有的证书，即可判断通信方的真实身份</p>
<h3 id="4-3-HTTP-加密-认证-完整性保护-HTTPS"><a href="#4-3-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="4.3 HTTP+加密+认证+完整性保护=HTTPS"></a>4.3 HTTP+加密+认证+完整性保护=HTTPS</h3><blockquote>
<p>&emsp;&emsp;<br>HTTPS并非是应用层的一个新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。通常情况下，HTTP直接和TCP通信。当使用SSL时，变成HTTP先和SSL通信，再由SSL和TCP通信。HTTPS就是身披SSL协议这层外壳的HTTP。在采用SSL之后，HTTPS就拥有了HTTPS的加密、整数和完整性保护这些功能。。</br><br>&emsp;&emsp;SSL本身独立于HTTP协议，其他运行在应用层的SMTP、Telnet等协议均可配合SSL协议使用，SSL是当今世界应用最为广泛的网络安全技术。</br><br>&emsp;&emsp;HTTPS的通信速度可能比HTTP慢2-100倍。除去和TCP建立连接的部分，更重要的是SSL必须进行加密处理。在服务器端和客户端都必须进行加解密处理，这会更多的消耗服务器端和客户端的硬件资源，导致负载增强。</p>
</blockquote>
<h2 id="五-确认访问用户身份的认证"><a href="#五-确认访问用户身份的认证" class="headerlink" title="五.确认访问用户身份的认证"></a>五.确认访问用户身份的认证</h2><p>HTTP使用的认证方式：</p>
<ul>
<li>BASIC认证(基本认证)</li>
<li>DIGEST认证(摘要认证)</li>
<li>SSL客户端认证</li>
<li>FormBase认证(基于表单认证)<h3 id="5-1-BASIC认证"><a href="#5-1-BASIC认证" class="headerlink" title="5.1 BASIC认证"></a>5.1 BASIC认证</h3><blockquote>
<p>当请求的资源需要BASIC认证时，服务器会随状态码<code>401 Authorization Required</code>，返回带<code>WWW-Authenticate</code>首部字段的响应。该字段内涵盖了认证的方式(BASIC)及Request-URI安全域字符串(realm)。</p>
</blockquote>
</li>
</ul>
<p>BASIC认证采用的是Base64的编码方式，但这不是加密处理。发送的还是用户的明文密码</p>
<h3 id="5-2-DIGEST认证"><a href="#5-2-DIGEST认证" class="headerlink" title="5.2 DIGEST认证"></a>5.2 DIGEST认证</h3><h3 id="5-3-SSL客户端认证"><a href="#5-3-SSL客户端认证" class="headerlink" title="5.3 SSL客户端认证"></a>5.3 SSL客户端认证</h3><ul>
<li>1.接收到需要认证资源的请求，服务器会先发送<code>Certificate Request</code>报文，要求客户端提供客户端证书。</li>
<li>用户选择将发送的客户端证书后，客户端会把客户端证书以<code>Client Certificate</code>报文方式发送给服务器。</li>
<li>服务器验证客户端证书验证通过后可以领取证书内客户端的公开密钥，然后开始HTTPS请求<h3 id="5-4-基于表单的认证方式"><a href="#5-4-基于表单的认证方式" class="headerlink" title="5.4 基于表单的认证方式"></a>5.4 基于表单的认证方式</h3><blockquote>
<p>应用自己的代码实现用户登录验证，将客户端发送来的用户ID和密码与之前登陆过的信息做匹配来进行认证</p>
</blockquote>
<h4 id="5-4-1-使用Cookie管理Session"><a href="#5-4-1-使用Cookie管理Session" class="headerlink" title="5.4.1 使用Cookie管理Session"></a>5.4.1 使用Cookie管理Session</h4></li>
<li>1.客户端把用户ID和密码等登录信息放入报文实体部分，通常采用POST方法把请求发送给服务器。这时会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。</li>
<li>2.服务器会发方用以识别用户的<code>Session ID</code>。然后验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。(会在首部字段<code>Set-Cookie</code>内写入<code>Session ID</code>)</li>
<li>客户端接收到从服务器端发来的<code>Session ID</code>后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie。所以Session ID也随之发送到服务器。服务器端可以通过验证接收到的Session ID识别用户和其认证状态</li>
<li></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Docker基础知识查漏补缺"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/22/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"
    >Docker基础知识查漏补缺</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/02/22/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" class="article-date">
  <time datetime="2023-02-22T13:37:03.000Z" itemprop="datePublished">2023-02-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker基础知识查漏补缺"><a href="#Docker基础知识查漏补缺" class="headerlink" title="Docker基础知识查漏补缺"></a>Docker基础知识查漏补缺</h1><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote>
<p>docker-compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。日常工作中，我们经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;Compose&#96;&#96;&#96;中有两个重要的概念：</span><br><span class="line">- 服务(service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</span><br><span class="line">- 项目(project)：由一组关联的应用容器组成的一个完整业务单元，在&#96;&#96;&#96;docker-compose.yml&#96;&#96;&#96;文件中定义。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;Compose&#96;&#96;&#96;的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理</span><br><span class="line">### 使用:Compose面向项目进行管理</span><br><span class="line">安装方法见教程</span><br><span class="line">当能打印以下版本信息时，说明&#96;&#96;&#96;docker-compose&#96;&#96;&#96;安装成功</span><br></pre></td></tr></table></figure>
<p>[root@localhost ~]# docker-compose –version<br>docker-compose version 1.27.4, build 40524192</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">### 重要命令说明</span><br><span class="line">#### docker-compose命令选项</span><br><span class="line">- &#96;&#96;&#96;-f&#96;&#96;&#96;指定使用的Compose模板文件，默认为&#96;&#96;&#96;docker-compose.yml&#96;&#96;&#96;，可以多次指定</span><br><span class="line">- &#96;&#96;&#96;-p&#96;&#96;&#96;指定项目名称，默认使用所在目录名称</span><br><span class="line">- &#96;&#96;&#96;--verbose&#96;&#96;&#96;输出更多调试信息</span><br><span class="line">- &#96;&#96;&#96;-v&#96;&#96;&#96;打印版本并退出</span><br><span class="line"></span><br><span class="line">###### up</span><br><span class="line">该命令的完整格式为：</span><br></pre></td></tr></table></figure>
<p>docker-compose up [options] [SERVICE…]</p>
<p><code> 其功能十分强大，它将尝试自动完成包括构建镜像、（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。&lt;/br&gt; 链接的服务都将被自动启动，除非已经处于运行状态。&lt;b&gt;大部分时候都可以直接通过该命令来启动一个项目&lt;/b&gt;&lt;/br&gt; 如果使用</code>docker-compose up -d```将会在后台启动并运行所有的容器，一般推荐在生产环境下使用该选项</p>
<h2 id="Docker安全"><a href="#Docker安全" class="headerlink" title="Docker安全"></a>Docker安全</h2><h3 id="Linux-Namespace简介"><a href="#Linux-Namespace简介" class="headerlink" title="Linux Namespace简介"></a>Linux Namespace简介</h3><blockquote>
<p>Linux namespce提供的是一种内核级别的隔离系统资源的方法。不同的Namespace程序，可以享有一份独立的系统资源。目前Linux提供了六类系统资源的隔离机制，分别是：</p>
</blockquote>
<ul>
<li>Mount: 隔离文件系统挂载点</li>
<li>UTS: 隔离主机名和域名信息</li>
<li>IPC： 隔离进程间通信</li>
<li>PID： 隔离进程的PID</li>
<li>Network: 隔离网络资源</li>
<li>User: 隔离用户和用户组的ID<h3 id="Docker的安全隔离机制"><a href="#Docker的安全隔离机制" class="headerlink" title="Docker的安全隔离机制"></a>Docker的安全隔离机制</h3>当我们用<code>docker run</code>启动一个容器时，在后台Docker为容器创建了一个独立的命名空间和控制组结合。命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其他容器发现和作用。</br><br>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样<h2 id="Docker的底层实现"><a href="#Docker的底层实现" class="headerlink" title="Docker的底层实现"></a>Docker的底层实现</h2>&emsp;Docker的底层核心技术包括Linux上的命名空间(Namespace)、控制组(COntrol groups)、Union文件系统(Union file systems)和容器格式(Container format)。</br><br>&emsp;Docker的实现基于Linux的命名空间机制，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境(例如一些系统命令和一些系统库)，但是彼此却看不到，都以为系统中只有自己存在。</br><br>&emsp;&emsp;这种机制就是容器(Container)，利用命名空间来做权限的隔离控制，利用cgroups来做资源分配。<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3>&emsp;&emsp;Docker采用了<code>C/S</code>架构。Docker守护进程(Daemon)作为服务端接收来自客户端的请求，并处理这些请求(创建、运行、分发容器)。</br><br>&emsp;&emsp;客户端和服务端既可以运行在一台机器上，也可以通过<code>socket</code>或者<code>RESTful API</code>来进行通信。</br><br>&emsp;&emsp;Docker守护进程一般在宿主机后台运行，等待接收来自客户端的消息。Docker客户端则为用户提供一系列可执行命令，用户用这些命令实现和Docker守护进程交互。<h3 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h3>&emsp;&emsp;联合文件系统时一种分层、轻量级且高性能的文件系统。支持对文件系统的修改作为一次提交来一层层的进行叠加。同时可以将不同的目录挂载到同一个虚拟文件系统下。</br><br>&emsp;&emsp;联合文件系统就是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</br><br>&emsp;&emsp;不同Docker容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。<h3 id="网络实现"><a href="#网络实现" class="headerlink" title="网络实现"></a>网络实现</h3>Docker创建一个容器时，会执行以下操作：</li>
<li>创建一对虚拟接口，分别放到本地主机和新容器中。</li>
<li>本地主机一段桥接到默认的docker0或指定网桥上，并且具有一个唯一的名字。</li>
<li>容器一段放到新容器中，并修改名字作为eth0，这个接口只在容器的命名空间可见。</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的eth0，并且配置默认路由到桥接网卡。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-利用docker commit理解镜像构成"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/17/%E5%88%A9%E7%94%A8docker%20commit%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E6%9E%84%E6%88%90/"
    >利用docker commit理解镜像构成</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/02/17/%E5%88%A9%E7%94%A8docker%20commit%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E6%9E%84%E6%88%90/" class="article-date">
  <time datetime="2023-02-17T11:15:03.000Z" itemprop="datePublished">2023-02-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="利用docker-commit-理解镜像构成"><a href="#利用docker-commit-理解镜像构成" class="headerlink" title="利用docker commit 理解镜像构成"></a>利用docker commit 理解镜像构成</h1><blockquote>
<p>不要使用<code>docker commit</code>来定制镜像，定制镜像的工作应该由Dockerfile构成。镜像是多层存储，每一层是在前一层的基础上进行修改。容器同样也是多层存储，是以镜像为基础层，在其基础上加一层来作为容器运行时的存储层。</p>
</blockquote>
<h2 id="镜像构建实例"><a href="#镜像构建实例" class="headerlink" title="镜像构建实例"></a>镜像构建实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>首先第一条命令用Nginx镜像启动一个容器，命名为webserver，并且映射了80端口。此时通过浏览器访问<code>http://localhost</code>可以看到nginx欢迎页面。假设现在我没希望更改nginx欢迎页面上的文字为欢迎Docker的文字，我们可以使用<code>docker exec</code>命令进入容器，并执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it webserver bash</span><br><span class="line">echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面这些执行的意思是，我们以交互终端的方式进入了webserver容器，用新的html内容覆盖了原有的nginx欢迎页面，此时再刷新浏览器，可以看到欢迎页面的字样改变了。</br><br>&emsp;&emsp;我们修改了容器的文件，也就是改动了容器的存储层，我们可以通过<code>docker diff</code>命令来查看这种改动。</br><br>&emsp;&emsp;现在我们定制好了变化，希望能将其保存下来形成镜像。</p>
<blockquote>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里面。Docker为我们提供了一个<code>docker commit</code>命令，可以将容器的存储层保存下来成为镜像。换句话说，<b>就是再原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像，以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</b></p>
</blockquote>
<h3 id="docker-commit-构建基础知识"><a href="#docker-commit-构建基础知识" class="headerlink" title="docker commit 构建基础知识"></a>docker commit 构建基础知识</h3><figure class="highlight docker"><figcaption><span>commit```的语法格式为</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure>
<p>我们现在来尝试运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker commit \</span><br><span class="line">  --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \</span><br><span class="line">  --message &quot;modify origin page&quot; \</span><br><span class="line">  webserver \</span><br><span class="line">  nginx:v2</span><br></pre></td></tr></table></figure>
<p>解读：其中<code>--author</code>是指定修改的作者，<code>--message</code>则是记录本次修改的内容，这点和Git的使用方法是一致的。</br><br>这时候我们就可以通过<code>docker images</code>命令在镜像列表查看到新构建的这个镜像</p>
<h3 id="构建验证"><a href="#构建验证" class="headerlink" title="构建验证"></a>构建验证</h3><p>我们用以下命令来运行这个镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure>
<p>这里我们将新的服务web2映射到81端口，我们可以通过访问<code>http://localhost:81</code>看到结果</p>
<h3 id="慎用docker-commit"><a href="#慎用docker-commit" class="headerlink" title="慎用docker commit"></a>慎用docker commit</h3><p>我们通过使用<code>docker commit</code>命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是在实际环境中并不这样使用。</br><br>首先，如果我们仔细观察之前<code>docker diff webserver</code>的结果，会发现除了真正想要的一条echo命令，很多其他的文件被改动或者添加了。这还只是针对最简单的操作，如果是安装软件包、编译构建，那会有大量无关内容被添加进来，会导致镜像变得极为臃肿。</br><br>此外，使用<code>docker commit</code>意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<b>黑箱镜像</b>，就是说除了制作镜像的人知道自己执行过什么命令，怎么生成的镜像，别人是无从得知的。这种镜像的维护工作是非常耗费精力的。</br><br>最后，<code>docker commit</code>修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果我们全都依靠<code>docker commit</code>来定制镜像的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
<h1 id="镜像构建上下文"><a href="#镜像构建上下文" class="headerlink" title="镜像构建上下文"></a>镜像构建上下文</h1><p>一般我们常用的用来构建镜像的命令<code>docker build</code>命令最后有一个<code>.</code>。这不是在指定Dockerfile所在的路径，而是在指定docker的上下文路径。</p>
<h3 id="docker-build的工作原理"><a href="#docker-build的工作原理" class="headerlink" title="docker build的工作原理"></a>docker build的工作原理</h3><p>Docker在运行时分为Docker引擎(也就是服务端守护进程)和客户端工具。Docker引擎提供了一组REST API，被称为<code>Docker Remote API</code>，而如<code>docker</code>命令这样的客户端工具，是通过这组API和docker引擎交互，从而完成各种功能。</br><br>因此在表面上，我们好像是在本机执行各种<code>docker</code>命令，而实际上一切都是使用的远程调用形式在服务端(Docker引擎)完成的。也因为这种C/S的设计，让我们操作远程服务器的Docker引擎变得轻而易举。</br><br>根据上文的知识点，<code>docker build</code>命令构建镜像，并非是在本地进行构建的，而是在服务器端。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</br><br>这就引入了上下文的概念。构建时，用户会指定构建镜像上下文的路径，<code>docker build</code>命令在得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需要的一切文件。</br><br>如果我们在Dockerfile中这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY .&#x2F;package.json &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure>
<p>这并不是要复制执行<code>docker build</code>命令所在目录下的package.json，也不是复制Dockerfile所在目录下的package.json，而是复制上下文目录下的package.json</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Jedis学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/08/Jedis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >Jedis学习笔记</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/02/08/Jedis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-02-08T09:51:52.000Z" itemprop="datePublished">2023-02-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Jedis学习指南"><a href="#Jedis学习指南" class="headerlink" title="Jedis学习指南"></a>Jedis学习指南</h1><blockquote>
<p>前言：从Java的旧日阴影中站起来，重新学习java</p>
</blockquote>
<h2 id="1-Jedis定义"><a href="#1-Jedis定义" class="headerlink" title="1.Jedis定义"></a>1.Jedis定义</h2><blockquote>
<p>Jedis是Redis官方推荐的java连接开发工具。使用Java操作Redis中间件。 </p>
</blockquote>
<h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2.实践"></a>2.实践</h2><h4 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h4><blockquote>
<p>磨刀不误砍柴工，先把基础的东西都设置好</p>
</blockquote>
<h6 id="1-sout"><a href="#1-sout" class="headerlink" title="(1)sout"></a>(1)sout</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;&quot;)</span><br></pre></td></tr></table></figure>
<h6 id="2-psvm"><a href="#2-psvm" class="headerlink" title="(2)psvm"></a>(2)psvm</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String [] args)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-fori"><a href="#3-fori" class="headerlink" title="(3)fori"></a>(3)fori</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;;i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h4><p>&emsp;&emsp;首先确定项目的目录结构。例如：<code>src</code>目录存放java源码，<code>resources</code>目录存放配置文件，<code>bin</code>目录存放编译生成的<code>.class</code>文件。</br><br>&emsp;&emsp;此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</br><br>&emsp;&emsp;最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能够通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</br><br>&emsp;&emsp;这些工作难度不大，但非常琐碎且耗时。如果每个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</br><br>&emsp;&emsp;Maven就是是专门为Java项目打造的管理和构建工具。它的主要功能有：</p>
<ul>
<li>提供了一套标准化的项目结构。</li>
<li>提供了一套标准化的构建流程(编译，测试，打包，发布……);</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<p>一个Maven工程就是由：<code>groupId, artifactId和version</code>作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量进行确定。</p>
<h4 id="maven之pom-xml配置文件详解"><a href="#maven之pom-xml配置文件详解" class="headerlink" title="maven之pom.xml配置文件详解"></a>maven之pom.xml配置文件详解</h4><h5 id="1-pom的定义"><a href="#1-pom的定义" class="headerlink" title="(1)pom的定义"></a>(1)pom的定义</h5><p>pom代表项目对象模型，它是Maven中工作的基本组成单位。它是一个XML文件，始终保存在项目的基本目录中的pom.xml文件中。pom包含的对象是使用maven来构建的，pom.xml文件包含了项目的各种配置信息。创建一个项目前，应该要先决定项目组(groupId)，项目名(artifactId)和版本(version)，因为这些属性在项目仓库是唯一标识的。需要特别注意，每个项目都只有一个pom.xml文件。</p>
<h5 id="2-pom中的节点分布如下："><a href="#2-pom中的节点分布如下：" class="headerlink" title="(2)pom中的节点分布如下："></a>(2)pom中的节点分布如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0</span><br><span class="line">            http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 基本配置 --&gt;</span><br><span class="line">    &lt;groupId&gt;...&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;...&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;...&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;packaging&gt;...&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 依赖配置 --&gt;</span><br><span class="line">    &lt;dependencies&gt;...&lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;parent&gt;...&lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;...&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line">    &lt;modules&gt;...&lt;&#x2F;modules&gt;</span><br><span class="line">    &lt;properties&gt;...&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 构建配置 --&gt;</span><br><span class="line">    &lt;build&gt;...&lt;&#x2F;build&gt;</span><br><span class="line">    &lt;reporting&gt;...&lt;&#x2F;reporting&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 项目信息 --&gt;</span><br><span class="line">    &lt;name&gt;...&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;...&lt;&#x2F;description&gt;</span><br><span class="line">    &lt;url&gt;...&lt;&#x2F;url&gt;</span><br><span class="line">    &lt;inceptionYear&gt;...&lt;&#x2F;inceptionYear&gt;</span><br><span class="line">    &lt;licenses&gt;...&lt;&#x2F;licenses&gt;</span><br><span class="line">    &lt;organization&gt;...&lt;&#x2F;organization&gt;</span><br><span class="line">    &lt;developers&gt;...&lt;&#x2F;developers&gt;</span><br><span class="line">    &lt;contributors&gt;...&lt;&#x2F;contributors&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 环境设置 --&gt;</span><br><span class="line">    &lt;issueManagement&gt;...&lt;&#x2F;issueManagement&gt;</span><br><span class="line">    &lt;ciManagement&gt;...&lt;&#x2F;ciManagement&gt;</span><br><span class="line">    &lt;mailingLists&gt;...&lt;&#x2F;mailingLists&gt;</span><br><span class="line">    &lt;scm&gt;...&lt;&#x2F;scm&gt;</span><br><span class="line">    &lt;prerequisites&gt;...&lt;&#x2F;prerequisites&gt;</span><br><span class="line">    &lt;repositories&gt;...&lt;&#x2F;repositories&gt;</span><br><span class="line">    &lt;pluginRepositories&gt;...&lt;&#x2F;pluginRepositories&gt;</span><br><span class="line">    &lt;distributionManagement&gt;...&lt;&#x2F;distributionManagement&gt;</span><br><span class="line">    &lt;profiles&gt;...&lt;&#x2F;profiles&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-各节点解释说明"><a href="#3-各节点解释说明" class="headerlink" title="(3)各节点解释说明"></a>(3)各节点解释说明</h5><p>以如下的基本配置信息为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;&gt;</span><br><span class="line">   xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation&#x3D;&quot;http:&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0</span><br><span class="line">   http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">   &lt;!--pom模型版本，maven2和3都只能为4.0.0--&gt;</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">   &lt;!--项目的组ID，用于maven定位--&gt;</span><br><span class="line">   &lt;groupId&gt;com.company.bank&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;!--项目ID，通常是项目的名称，唯一标识符--&gt;</span><br><span class="line">   &lt;artifactId&gt;parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;!--项目的版本--&gt;</span><br><span class="line">   &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;!--项目的打包方式--&gt;</span><br><span class="line">   &lt;packing&gt;war&lt;&#x2F;packing&gt;</span><br><span class="line">&lt;project&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>节点</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>modelVersion</td>
<td>pom模型版本，maven2和3只能为4.0.0</td>
</tr>
<tr>
<td>groupId</td>
<td>这是项目组的编号，这在组织或项目中通常是独一无二的。例如，一家银行集团com.company.bank拥有所有银行相关项目。</td>
</tr>
<tr>
<td>artifact</td>
<td>这是项目的ID。这通常是项目的名称。例如：consumer-banking。除了groupId之外，artifactId还定义了artifact在存储库中的位置。</td>
</tr>
<tr>
<td>version</td>
<td>这是项目的版本。与groupId一起使用，artifact在存储库中用于将版本彼此分离。</td>
</tr>
<tr>
<td>packing</td>
<td>项目打包方式，有以下值：pom, jar, maven-plugin, ejb, war, ear, rar, par</td>
</tr>
</tbody></table>
<h6 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h6><p>1&gt; dependencies</br><br>项目相关依赖配置。如果在父项目写的依赖，会被子项目引用。一般会在父项目中定义子项目中所有共用的依赖。<br></br><br>2&gt; parent</br><br>用于确定父项目的坐标位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.learnPro&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;SIP-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;relativePath&gt;&lt;&#x2F;relativePath&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>groupId: 父项目的组Id标识符</li>
<li>artifactId: 父项目的唯一标识符</li>
<li>relativePath: Maven首先在当前仓库中找父项目的pom，然后在文件系统的这个位置(relativePath)，然后在本地仓库，再在远程仓库找。</li>
<li>version: 父项目的版本</li>
</ul>
<p>3&gt; modules</br><br>有些maven项目会做成多模块的，这个标签用于指定当前项目所包含的所有模块。之后对这个项目进行的maven操作，会让所有子模块也进行相同操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">   &lt;module&gt;com-a&lt;&#x2F;&gt;</span><br><span class="line">   &lt;module&gt;com-b&lt;&#x2F;&gt;</span><br><span class="line">   &lt;module&gt;com-c&lt;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;modules&gt;</span><br></pre></td></tr></table></figure>
<p>4&gt;properties常量</br><br>用于定义pom常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>
<p>上面这个常量可以在pom文件的任意地方通过${java.version}来引用<br>5&gt; dependencyManagement<br>配置写法同dependencies</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">   ......</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependenctManagement&gt;</span><br></pre></td></tr></table></figure>
<p>在父模块中完成定义后，子模块不会直接使用对应依赖，但是在使用相同依赖时可以不加上版本号。这样的好处是，父项目统一了版本，而且子项目可以在需要的时候才引用对应的依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父项目：</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">子项目：</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h5 id="4-构建配置"><a href="#4-构建配置" class="headerlink" title="(4)构建配置"></a>(4)构建配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </span><br><span class="line">    &lt;sourceDirectory&#x2F;&gt;    </span><br><span class="line">    &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;    </span><br><span class="line">  &lt;scriptSourceDirectory&#x2F;&gt;    </span><br><span class="line">  &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </span><br><span class="line">  &lt;testSourceDirectory&#x2F;&gt;    </span><br><span class="line">  &lt;!--被编译过的应用程序class文件存放的目录。--&gt;    </span><br><span class="line">  &lt;outputDirectory&#x2F;&gt;    </span><br><span class="line">  &lt;!--被编译过的测试class文件存放的目录。--&gt;    </span><br><span class="line">  &lt;testOutputDirectory&#x2F;&gt;    </span><br><span class="line">  &lt;!--使用来自该项目的一系列构建扩展--&gt;    </span><br><span class="line">  &lt;extensions&gt;    </span><br><span class="line">   &lt;!--描述使用到的构建扩展。--&gt;    </span><br><span class="line">   &lt;extension&gt;    </span><br><span class="line">    &lt;!--构建扩展的groupId--&gt;    </span><br><span class="line">    &lt;groupId&#x2F;&gt;    </span><br><span class="line">    &lt;!--构建扩展的artifactId--&gt;    </span><br><span class="line">    &lt;artifactId&#x2F;&gt;    </span><br><span class="line">    &lt;!--构建扩展的版本--&gt;    </span><br><span class="line">    &lt;version&#x2F;&gt;    </span><br><span class="line">   &lt;&#x2F;extension&gt;    </span><br><span class="line">  &lt;&#x2F;extensions&gt;    </span><br><span class="line">  &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;    </span><br><span class="line">  &lt;defaultGoal&#x2F;&gt;    </span><br><span class="line">  &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;    </span><br><span class="line">  &lt;resources&gt;    </span><br><span class="line">   &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;    </span><br><span class="line">   &lt;resource&gt;    </span><br><span class="line">    &lt;!-- 描述了资源的目标路径。该路径相对target&#x2F;classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org&#x2F;apache&#x2F;maven &#x2F;messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;    </span><br><span class="line">    &lt;targetPath&#x2F;&gt;    </span><br><span class="line">    &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;    </span><br><span class="line">    &lt;filtering&#x2F;&gt;    </span><br><span class="line">    &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;    </span><br><span class="line">    &lt;directory&#x2F;&gt;    </span><br><span class="line">    &lt;!--包含的模式列表，例如**&#x2F;*.xml.--&gt;    </span><br><span class="line">    &lt;includes&#x2F;&gt;    </span><br><span class="line">    &lt;!--排除的模式列表，例如**&#x2F;*.xml--&gt;    </span><br><span class="line">    &lt;excludes&#x2F;&gt;    </span><br><span class="line">   &lt;&#x2F;resource&gt;    </span><br><span class="line">  &lt;&#x2F;resources&gt;    </span><br><span class="line">  &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;    </span><br><span class="line">  &lt;testResources&gt;    </span><br><span class="line">   &lt;!--这个元素描述了测试相关的所有资源路径，参见build&#x2F;resources&#x2F;resource元素的说明--&gt;    </span><br><span class="line">   &lt;testResource&gt;    </span><br><span class="line">    &lt;targetPath&#x2F;&gt;&lt;filtering&#x2F;&gt;&lt;directory&#x2F;&gt;&lt;includes&#x2F;&gt;&lt;excludes&#x2F;&gt;    </span><br><span class="line">   &lt;&#x2F;testResource&gt;    </span><br><span class="line">  &lt;&#x2F;testResources&gt;    </span><br><span class="line">  &lt;!--构建产生的所有文件存放的目录--&gt;    </span><br><span class="line">  &lt;directory&#x2F;&gt;    </span><br><span class="line">  &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt;    </span><br><span class="line">  &lt;finalName&#x2F;&gt;    </span><br><span class="line">  &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;    </span><br><span class="line">  &lt;filters&#x2F;&gt;    </span><br><span class="line">  &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;    </span><br><span class="line">  &lt;pluginManagement&gt;    </span><br><span class="line">   &lt;!--使用的插件列表 。--&gt;    </span><br><span class="line">   &lt;plugins&gt;    </span><br><span class="line">    &lt;!--plugin元素包含描述插件所需要的信息。--&gt;    </span><br><span class="line">    &lt;plugin&gt;    </span><br><span class="line">     &lt;!--插件在仓库里的group ID--&gt;    </span><br><span class="line">     &lt;groupId&#x2F;&gt;    </span><br><span class="line">     &lt;!--插件在仓库里的artifact ID--&gt;    </span><br><span class="line">     &lt;artifactId&#x2F;&gt;    </span><br><span class="line">     &lt;!--被使用的插件的版本（或版本范围）--&gt;    </span><br><span class="line">     &lt;version&#x2F;&gt;    </span><br><span class="line">     &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;    </span><br><span class="line">     &lt;extensions&#x2F;&gt;    </span><br><span class="line">     &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;    </span><br><span class="line">     &lt;executions&gt;    </span><br><span class="line">      &lt;!--execution元素包含了插件执行需要的信息--&gt;    </span><br><span class="line">      &lt;execution&gt;    </span><br><span class="line">       &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;    </span><br><span class="line">       &lt;id&#x2F;&gt;    </span><br><span class="line">       &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;    </span><br><span class="line">       &lt;phase&#x2F;&gt;    </span><br><span class="line">       &lt;!--配置的执行目标--&gt;    </span><br><span class="line">       &lt;goals&#x2F;&gt;    </span><br><span class="line">       &lt;!--配置是否被传播到子POM--&gt;    </span><br><span class="line">       &lt;inherited&#x2F;&gt;    </span><br><span class="line">       &lt;!--作为DOM对象的配置--&gt;    </span><br><span class="line">       &lt;configuration&#x2F;&gt;    </span><br><span class="line">      &lt;&#x2F;execution&gt;    </span><br><span class="line">     &lt;&#x2F;executions&gt;    </span><br><span class="line">     &lt;!--项目引入插件所需要的额外依赖--&gt;    </span><br><span class="line">     &lt;dependencies&gt;    </span><br><span class="line">      &lt;!--参见dependencies&#x2F;dependency元素--&gt;    </span><br><span class="line">      &lt;dependency&gt;    </span><br><span class="line">       ......    </span><br><span class="line">      &lt;&#x2F;dependency&gt;    </span><br><span class="line">     &lt;&#x2F;dependencies&gt;         </span><br><span class="line">     &lt;!--任何配置是否被传播到子项目--&gt;    </span><br><span class="line">     &lt;inherited&#x2F;&gt;    </span><br><span class="line">     &lt;!--作为DOM对象的配置--&gt;    </span><br><span class="line">     &lt;configuration&#x2F;&gt;    </span><br><span class="line">    &lt;&#x2F;plugin&gt;    </span><br><span class="line">   &lt;&#x2F;plugins&gt;    </span><br><span class="line">  &lt;&#x2F;pluginManagement&gt;    </span><br><span class="line">  &lt;!--使用的插件列表--&gt;    </span><br><span class="line">  &lt;plugins&gt;    </span><br><span class="line">   &lt;!--参见build&#x2F;pluginManagement&#x2F;plugins&#x2F;plugin元素--&gt;    </span><br><span class="line">   &lt;plugin&gt;    </span><br><span class="line">    &lt;groupId&#x2F;&gt;&lt;artifactId&#x2F;&gt;&lt;version&#x2F;&gt;&lt;extensions&#x2F;&gt;    </span><br><span class="line">    &lt;executions&gt;    </span><br><span class="line">     &lt;execution&gt;    </span><br><span class="line">      &lt;id&#x2F;&gt;&lt;phase&#x2F;&gt;&lt;goals&#x2F;&gt;&lt;inherited&#x2F;&gt;&lt;configuration&#x2F;&gt;    </span><br><span class="line">     &lt;&#x2F;execution&gt;    </span><br><span class="line">    &lt;&#x2F;executions&gt;    </span><br><span class="line">    &lt;dependencies&gt;    </span><br><span class="line">     &lt;!--参见dependencies&#x2F;dependency元素--&gt;    </span><br><span class="line">     &lt;dependency&gt;    </span><br><span class="line">      ......    </span><br><span class="line">     &lt;&#x2F;dependency&gt;    </span><br><span class="line">    &lt;&#x2F;dependencies&gt;    </span><br><span class="line">    &lt;goals&#x2F;&gt;&lt;inherited&#x2F;&gt;&lt;configuration&#x2F;&gt;    </span><br><span class="line">   &lt;&#x2F;plugin&gt;    </span><br><span class="line">  &lt;&#x2F;plugins&gt;    </span><br><span class="line"> &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>
<h5 id="5-项目信息"><a href="#5-项目信息" class="headerlink" title="(5)项目信息"></a>(5)项目信息</h5><ul>
<li>name:给用户提供更为友好的项目名</li>
<li>description:项目描述，maven文档中保存</li>
<li>url：主页的URL，maven文档中保存</li>
<li>inceptionYear:项目创建年份，4位数字。当产生版权信息时需要使用这个值。</li>
<li>licenses：该元素描述了项目所有License列表</li>
<li>organization: 1.name组织名 2.url 组织主页url</li>
<li>developers：项目开发人员列表</li>
<li>contributors:项目其他贡献者列表<h4 id="2-1-导入对应的依赖"><a href="#2-1-导入对应的依赖" class="headerlink" title="2.1 导入对应的依赖"></a>2.1 导入对应的依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--导入jedis的包--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.3.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--fastjson--&gt;</span><br><span class="line">    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;fastjson --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.23&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-连接测试"><a href="#2-2-连接测试" class="headerlink" title="2.2 连接测试"></a>2.2 连接测试</h4></li>
<li>1.连接数据库</li>
<li>2.操作命令</li>
<li>3.断开连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.redis;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class TestPing &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;1. new Jedis对象</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-常用的API"><a href="#2-3-常用的API" class="headerlink" title="2.3 常用的API"></a>2.3 常用的API</h4><h5 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TestKey &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;清空数据：&quot;+ jedis.flushDB());</span><br><span class="line">        System.out.println(&quot;判断某个键是否存在&quot; + jedis.exists(&quot;username&quot;));</span><br><span class="line">        System.out.println(&quot;新增&lt;&#39;username&#39;&gt;, &#39;lzx&#39;:&quot; + jedis.set(&quot;username&quot;, &quot;lzx&quot;));</span><br><span class="line">        System.out.println(&quot;新增&lt;password&gt;, &#39;123456&#39;: &quot; +jedis.set(&quot;password&quot;, &quot;123456&quot;));</span><br><span class="line">        System.out.println(&quot;系统中所有键如下：&quot;);</span><br><span class="line">        Set&lt;String&gt; keys &#x3D; jedis.keys(&quot;*&quot;);</span><br><span class="line">        System.out.println(&quot;删除键password:&quot; + jedis.del(&quot;password&quot;));</span><br><span class="line">        System.out.println(&quot;判断键password是否存在：&quot;+ jedis.exists(&quot;password&quot;));</span><br><span class="line">        System.out.println(&quot;判断键username所存储的值的类型:&quot; + jedis.type(&quot;password&quot;));</span><br><span class="line">        System.out.println(&quot;随机返回key空间的一个：&quot;+ jedis.randomKey());</span><br><span class="line">        System.out.println(&quot;重命名key username:&quot; + jedis.rename(&quot;username&quot;, &quot;name&quot;));</span><br><span class="line">        System.out.println(&quot;取出改后的Name:&quot;+ jedis.get(&quot;name&quot;));</span><br><span class="line">        System.out.println(&quot;按索引进行查询：&quot;+jedis.select(0));</span><br><span class="line">        System.out.println(&quot;删除当前数据库中所有数据：&quot;+jedis.flushDB());</span><br><span class="line">        System.out.println(&quot;返回当前数据库中所有key的数目&quot;+jedis.dbSize());</span><br><span class="line">        System.out.println(&quot;删除所有数据库中的所有key:&quot;+jedis.flushAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class TestString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;增加数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        System.out.println(jedis.set(&quot;key1&quot;, &quot;value1&quot;));</span><br><span class="line">        System.out.println(jedis.set(&quot;key2&quot;, &quot;value2&quot;));</span><br><span class="line">        System.out.println(jedis.set(&quot;key3&quot;, &quot;value3&quot;));</span><br><span class="line">        System.out.println(&quot;删除键key2&quot;+ jedis.del(&quot;key2&quot;));</span><br><span class="line">        System.out.println(&quot;获取键key2&quot; + jedis.get(&quot;key2&quot;));</span><br><span class="line">        System.out.println(&quot;修改key1&quot;+ jedis.set(&quot;key1&quot;, &quot;value1changed&quot;));</span><br><span class="line">        System.out.println(&quot;获取修改后的key1的值&quot; + jedis.get(&quot;key1&quot;));</span><br><span class="line">        System.out.println(&quot;在key3后面加上值:&quot; + jedis.append(&quot;key3&quot;, &quot;End&quot;));</span><br><span class="line">        System.out.println(&quot;获取key3的值:&quot; + jedis.get(&quot;key3&quot;));</span><br><span class="line">        System.out.println(&quot;增加多个键值对:&quot; + jedis.mset(&quot;key01&quot;, &quot;values01&quot;, &quot;key02&quot;, &quot;values02&quot;, &quot;key03&quot;, &quot;values03&quot;));</span><br><span class="line">        System.out.println(&quot;获取多个键值对:&quot; + jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot;));</span><br><span class="line">        System.out.println(&quot;获取多个键值对:&quot; + jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot;, &quot;key04&quot;));</span><br><span class="line">        System.out.println(&quot;删除多个键值对：&quot;+ jedis.del(&quot;key01&quot;, &quot;key02&quot;));</span><br><span class="line">        System.out.println(&quot;获取多个键值对：&quot;+ jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot;));</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增键值对防止覆盖原先值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        &#x2F;&#x2F; 分布式锁，不存在的时候才进行添加</span><br><span class="line">        System.out.println(jedis.setnx(&quot;key1&quot;, &quot;value1&quot;));</span><br><span class="line">        System.out.println(jedis.setnx(&quot;key2&quot;, &quot;value2&quot;));</span><br><span class="line">        System.out.println(jedis.setnx(&quot;key2&quot;, &quot;value2-new&quot;));</span><br><span class="line">        System.out.println(jedis.get(&quot;key1&quot;));</span><br><span class="line">        System.out.println(jedis.get(&quot;key2&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增键值对并设置有效时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        System.out.println(jedis.setex(&quot;key3&quot;, 2, &quot;values3&quot;));</span><br><span class="line">        System.out.println(jedis.get(&quot;key3&quot;));</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(jedis.get(&quot;key3&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取原值，更新为新值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        System.out.println(jedis.getSet(&quot;key2&quot;, &quot;key2GetSet&quot;));</span><br><span class="line">        System.out.println(jedis.get(&quot;key2&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;获得key2的值的字符串：&quot;+ jedis.getrange(&quot;key2&quot;, 2, 4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
控制台输出如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;增加数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">删除键key21</span><br><span class="line">获取键key2null</span><br><span class="line">修改key1OK</span><br><span class="line">获取修改后的key1的值value1changed</span><br><span class="line">在key3后面加上值:9</span><br><span class="line">获取key3的值:value3End</span><br><span class="line">增加多个键值对:OK</span><br><span class="line">获取多个键值对:[values01, values02, values03]</span><br><span class="line">获取多个键值对:[values01, values02, values03, null]</span><br><span class="line">删除多个键值对：2</span><br><span class="line">获取多个键值对：[null, null, values03]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增键值对防止覆盖原先值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增键值对并设置有效时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">OK</span><br><span class="line">values3</span><br><span class="line">null</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取原值，更新为新值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">value2</span><br><span class="line">key2GetSet</span><br><span class="line">获得key2的值的字符串：y2G</span><br></pre></td></tr></table></figure>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class TestList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;添加一个list&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;ArrayList&quot;, &quot;Vector&quot;, &quot;Stack&quot;, &quot;HashMap&quot;, &quot;WeakHashMap&quot;, &quot;LinkedHashMap&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;HashSet&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;TreaSet&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;TreaMap&quot;);</span><br><span class="line">        System.out.println(&quot;collections的内容：&quot;+ jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;collections区间0-3的内容：&quot;+ jedis.lrange(&quot;collections&quot;, 0, 3));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;删除列表指定的值，第二个参数为删除的个数(有重复时)，后add进去的值先被删除，类似于出栈</span><br><span class="line">        System.out.println(&quot;删除指定元素个数：&quot;+ jedis.lrem(&quot;collections&quot;, 2, &quot;HashMap&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;删除下表0-3区间之外的元素&quot;+jedis.ltrim(&quot;collections&quot;, 0, 3));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;collections元素出栈(左端)&quot; + jedis.lpop(&quot;collections&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;collections元素出栈(右端)&quot; + jedis.rpop(&quot;collections&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;修改collections指定下标1的内容&quot; + jedis.lset(&quot;collections&quot;, 1, &quot;LinkArrayList&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        System.out.println(&quot;获取collections的长度&quot;+ jedis.llen(&quot;collections&quot;));</span><br><span class="line">        System.out.println(&quot;获取collections的下标为2的元素&quot; + jedis.lindex(&quot;collections&quot;, 2));</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        jedis.lpush(&quot;sortedList&quot;, &quot;3&quot;, &quot;6&quot;, &quot;2&quot;, &quot;0&quot;, &quot;7&quot;, &quot;4&quot;);</span><br><span class="line">        System.out.println(&quot;sorted排序前&quot;+jedis.lrange(&quot;sortedList&quot;, 0, -1));</span><br><span class="line">        System.out.println(jedis.sort(&quot;sortedList&quot;));</span><br><span class="line">        System.out.println(&quot;sorted排序后&quot;+ jedis.lrange(&quot;sortedList&quot;, 0, -1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class TestList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;添加一个list&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;ArrayList&quot;, &quot;Vector&quot;, &quot;Stack&quot;, &quot;HashMap&quot;, &quot;WeakHashMap&quot;, &quot;LinkedHashMap&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;HashSet&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;TreaSet&quot;);</span><br><span class="line">        jedis.lpush(&quot;collections&quot;, &quot;TreaMap&quot;);</span><br><span class="line">        System.out.println(&quot;collections的内容：&quot;+ jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;collections区间0-3的内容：&quot;+ jedis.lrange(&quot;collections&quot;, 0, 3));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;删除列表指定的值，第二个参数为删除的个数(有重复时)，后add进去的值先被删除，类似于出栈</span><br><span class="line">        System.out.println(&quot;删除指定元素个数：&quot;+ jedis.lrem(&quot;collections&quot;, 2, &quot;HashMap&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;删除下表0-3区间之外的元素&quot;+jedis.ltrim(&quot;collections&quot;, 0, 3));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;collections元素出栈(左端)&quot; + jedis.lpop(&quot;collections&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;collections元素出栈(右端)&quot; + jedis.rpop(&quot;collections&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line">        System.out.println(&quot;修改collections指定下标1的内容&quot; + jedis.lset(&quot;collections&quot;, 1, &quot;LinkArrayList&quot;));</span><br><span class="line">        System.out.println(&quot;collections的内容&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        System.out.println(&quot;获取collections的长度&quot;+ jedis.llen(&quot;collections&quot;));</span><br><span class="line">        System.out.println(&quot;获取collections的下标为2的元素&quot; + jedis.lindex(&quot;collections&quot;, 2));</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        jedis.lpush(&quot;sortedList&quot;, &quot;3&quot;, &quot;6&quot;, &quot;2&quot;, &quot;0&quot;, &quot;7&quot;, &quot;4&quot;);</span><br><span class="line">        System.out.println(&quot;sorted排序前&quot;+jedis.lrange(&quot;sortedList&quot;, 0, -1));</span><br><span class="line">        System.out.println(jedis.sort(&quot;sortedList&quot;));</span><br><span class="line">        System.out.println(&quot;sorted排序后&quot;+ jedis.lrange(&quot;sortedList&quot;, 0, -1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class TestHash &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">        map.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">        map.put(&quot;key3&quot;, &quot;value3&quot;);</span><br><span class="line">        map.put(&quot;key4&quot;, &quot;value4&quot;);</span><br><span class="line">        &#x2F;&#x2F;添加名称为hash(key)的hash元素</span><br><span class="line">        jedis.hmset(&quot;hash&quot;, map);</span><br><span class="line">        &#x2F;&#x2F;向名称为hash的hash中添加key</span><br><span class="line">        jedis.hset(&quot;hash&quot;, &quot;key5&quot;, &quot;value5&quot;);</span><br><span class="line">        System.out.println(&quot;散列hash的所有键值对为：&quot;+ jedis.hgetAll(&quot;hash&quot;)); &#x2F;&#x2F;return Map&lt;string&gt;&lt;string&gt;</span><br><span class="line">        System.out.println(&quot;散列hash的所有键为:&quot; + jedis.hkeys(&quot;hash&quot;)); &#x2F;&#x2F; return Set&lt;string&gt;</span><br><span class="line">        System.out.println(&quot;散列hash的所有值为：&quot; + jedis.hvals(&quot;hash&quot;)); &#x2F;&#x2F; return List&lt;String&gt;</span><br><span class="line">        System.out.println(&quot;散列hash中的键值对个数：&quot;+ jedis.hlen(&quot;hash&quot;));</span><br><span class="line">        System.out.println(&quot;获取hash中的值：&quot;+ jedis.hget(&quot;hash&quot;, &quot;key3&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h5><h2 id="3-Jedis事务"><a href="#3-Jedis事务" class="headerlink" title="3.Jedis事务"></a>3.Jedis事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line"></span><br><span class="line">import org.json.JSONObject;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line">public class TestTX &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">        jsonObject.put(&quot;name&quot;, &quot;lzx&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;开启事务</span><br><span class="line">        Transaction multi &#x3D; jedis.multi();&#x2F;&#x2F;开启事务</span><br><span class="line">        String result &#x3D; jsonObject.toString();</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            multi.set(&quot;user1&quot;, result);</span><br><span class="line">            multi.set(&quot;user2&quot;, result);</span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            multi.discard();&#x2F;&#x2F;放弃事务</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            jedis.close();&#x2F;&#x2F;close connection</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="1-Redis配置文件详解"><a href="#1-Redis配置文件详解" class="headerlink" title="1.Redis配置文件详解"></a>1.Redis配置文件详解</h3><blockquote>
<p>启动的时候就是按conf文件进行启动的</p>
</blockquote>
</li>
<li>配置文件 unit单位 对大小写不敏感<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">redis.windows.conf</span><br><span class="line"># Redis configuration file example</span><br><span class="line"></span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k &#x3D;&gt; 1000 bytes</span><br><span class="line"># 1kb &#x3D;&gt; 1024 bytes</span><br><span class="line"># 1m &#x3D;&gt; 1000000 bytes</span><br><span class="line"># 1mb &#x3D;&gt; 1024*1024 bytes</span><br><span class="line"># 1g &#x3D;&gt; 1000000000 bytes</span><br><span class="line"># 1gb &#x3D;&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line"># 可以把多个配置文件包含进来</span><br><span class="line"># include .\path\to\local.conf</span><br><span class="line"># include c:\path\to\other.conf</span><br><span class="line"></span><br><span class="line">################################ GENERAL  #####################################</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 绑定的ip</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 默认数据库数量</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 持久化出错，是否需要继续工作</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">#是否压缩rdb文件（持久化文件，需要消耗一些cpu资源）</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否校验rdb文件</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># rdb文件保存的目录，默认当前目录</span><br><span class="line">dir .&#x2F;</span><br><span class="line"></span><br><span class="line"># 主从复制</span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line"></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"></span><br><span class="line">################################### LIMITS ####################################</span><br><span class="line"></span><br><span class="line"># AOF配置</span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"></span><br><span class="line"># 默认不开启aof模式，默认使用rdb方式持久化，因为大部分情况下rdb可以满足使用需求</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 每秒进行同步</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">################################ LUA SCRIPTING  ###############################</span><br><span class="line"></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER  ###############################</span><br><span class="line"></span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line"></span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">############################# Event notification ##############################</span><br><span class="line"></span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-Redis持久化"><a href="#2-Redis持久化" class="headerlink" title="2.Redis持久化"></a>2.Redis持久化</h3><blockquote>
<p>redis是内存数据库，如果不讲内存中的数据保存到磁盘，会断电即失。持久化相当于数据快照.</p>
</blockquote>
<h4 id="2-1-rdb方式"><a href="#2-1-rdb方式" class="headerlink" title="2.1 rdb方式"></a>2.1 rdb方式</h4><blockquote>
<p>rdb保存的文件是dump.rdb,原理是会单独fork一个子进程进行持久化。在主从复制中，rdb就是做备份用，aof我们几乎不使用。rdb是一种时间点快照。</p>
</blockquote>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6></li>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6></li>
<li>需要一定的时间间隔进行操作。如果redis意外宕机了，最后一次进行修改的数据就没有了。</li>
<li>fork进程的时候，会占用一定的内容空间。<h4 id="2-2-AOF-Append-Only-File"><a href="#2-2-AOF-Append-Only-File" class="headerlink" title="2.2 AOF(Append Only File)"></a>2.2 AOF(Append Only File)</h4><blockquote>
<p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍。以日志的形式来记录每个写操作（读操作不记录）， redis启动之后要读取文件从头进行构建，这样效率很慢。aof的重写规则说明：如果aof文件大于64mb,太大了，会fork一个新的进程来将文件进行重写。</p>
</blockquote>
</li>
</ul>
<p>appendonly.aof是以日志级别记录所有的写操作 如果aof文件有错误，redis是启动不起来的，redis提供了一个工具：<code>redis-check-aof --fix</code></p>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul>
<li>每一次修改都同步，文件的完整性会更加好</li>
<li>默认开启的是每秒同步一次，可能会丢失这一秒的数据</li>
<li>从不同步<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6></li>
<li>相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</li>
<li>aof运行效率也要比rdb慢，所以我们redis的配置就是rdb持久化<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4>建议阅读文章《Redis专题：万字长文详解持久化原理》<h3 id="3-Redis的发布与订阅"><a href="#3-Redis的发布与订阅" class="headerlink" title="3.Redis的发布与订阅"></a>3.Redis的发布与订阅</h3><blockquote>
<p>这是一种消息通信模式，发送者(pub)发送消息，订阅者(sub)接收消息<br>redis客户端可以订阅任意数量的频道<br>订阅频道的命令：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel</span><br></pre></td></tr></table></figure>
发送消息的命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel messgae</span><br></pre></td></tr></table></figure>
测试结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;lzx&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;lzx&quot;</span><br><span class="line">3) &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4></li>
<li>实时消息系统</li>
<li>实时聊天<br>稍微复杂的场景会使用消息中间件MQ来做。<h3 id="4-Redis主从复制"><a href="#4-Redis主从复制" class="headerlink" title="4.Redis主从复制"></a>4.Redis主从复制</h3>查看当前库的信息命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>
打印结果如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master # 角色</span><br><span class="line">connected_slaves:0 # 连接的从机</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>
复制三个配置文件，然后修改对应的信息</li>
<li>端口</li>
<li>pid名字</li>
<li>log文件名字</li>
<li>dump.rdb名字<br>启动所有服务，可以实现redis单机多集群<h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4></li>
<li>默认情况下，每台Redis服务器都是主节点</li>
<li>一般情况下，只用配置从机就好了<br>使用的命令为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 127.0.0.1 port</span><br></pre></td></tr></table></figure></li>
</ul>
<p>127.0.0.1指定的是主机redis服务器所在服务器地址</p>
<ul>
<li>主机负责写，从机负责读</li>
<li>主机断开连接，从机依旧是连接到主机的，但是没有写操作了。如果主机回来了，从机依旧可以直接获取到主机写的信息</li>
<li>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机。如果变回从机，数据会立马从主机中获取值（因为这里存在全量复制机制）<h2 id="5-Redis哨兵模式"><a href="#5-Redis哨兵模式" class="headerlink" title="5.Redis哨兵模式"></a>5.Redis哨兵模式</h2><blockquote>
<p>原理：配置一个独立的哨兵进程，通过发送命令来监控redis服务器的死活</p>
</blockquote>
<h4 id="配置哨兵监控文件"><a href="#配置哨兵监控文件" class="headerlink" title="配置哨兵监控文件"></a>配置哨兵监控文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor 被监控的名称 host port 1</span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>
<h4 id="启动哨兵-从配置文件启动即可"><a href="#启动哨兵-从配置文件启动即可" class="headerlink" title="启动哨兵(从配置文件启动即可)"></a>启动哨兵(从配置文件启动即可)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel kconfig&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure>
如果主节点宕机之后，这个时候哨兵就会从从机中随机选择一个服务器(redis源码这里面有一个投票算法)<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4></li>
<li>哨兵集群，基于主从复制模式，所有的主从复制优点，它全有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>Redis不好在线扩容，容量达到上线时，不好自动扩容</li>
<li>实际开发场景下，哨兵模式的配置其实是很麻烦的<h2 id="6-Redis缓存穿透与雪崩"><a href="#6-Redis缓存穿透与雪崩" class="headerlink" title="6.Redis缓存穿透与雪崩"></a>6.Redis缓存穿透与雪崩</h2></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python模块学习之timeit"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/30/Python%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E4%B9%8Btimeit/"
    >Python模块学习之timeit</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/01/30/Python%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E4%B9%8Btimeit/" class="article-date">
  <time datetime="2023-01-30T12:21:52.000Z" itemprop="datePublished">2023-01-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="timeit—计算小段Python代码的运行时间"><a href="#timeit—计算小段Python代码的运行时间" class="headerlink" title="timeit—计算小段Python代码的运行时间"></a>timeit—计算小段Python代码的运行时间</h1><blockquote>
<p>前言：<code>timeit</code>模块提供了一个简单的接口来测量一小段Python代码的执行时间。它使用平台相关的时间函数来提供尽可能精确的时间计算，并通过反复执行代码来减少启动或关闭的开销对时间计算的影响。</p>
</blockquote>
<h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><p>&emsp;&emsp;<code>timeit</code>定义了一个公共类<code>Timer</code>。<code>Timer</code>的构造函数接受要计时的语句和设置语句(例如，要初始化变量)。</br><br>&emsp;&emsp;<code>timeit()</code>方法首先执行设置语句一次，然后重复执行被测试语句并返回使用的总时间。传递给<code>timeit()</code>的参数控制语句执行的测试，默认值是1000000.</p>
<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>为了说明如何使用<code>Timer</code>的各种参数，这里有一个简单的示例，在执行每个语句时打印一个标识值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># timeit_example.py</span><br><span class="line"></span><br><span class="line"># using setitem</span><br><span class="line">t &#x3D; timeit.Timer(&quot;print(&#39;main statement&#39;)&quot;, &quot;print(&#39;setup&#39;)&quot;)</span><br><span class="line"></span><br><span class="line">print(&#39;TIMEIT:&#39;)</span><br><span class="line">print(t.timeit(2))</span><br><span class="line"></span><br><span class="line">print(&#39;REPEAT:&#39;)</span><br><span class="line">print(t.repeat(3, 2))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 在字典中存储数据</span><br><span class="line">这个更复杂的示例比较使用不同的方法向字典中填充大量数据所需的时间。首先，需要一些常量来配置&#96;&#96;&#96;Timer&#96;&#96;&#96;。&lt;&#x2F;br&gt;</span><br><span class="line">&#96;&#96;&#96;setup_statement&#96;&#96;&#96;变量初始化包含字符串和整数的元组列表，主语句将使用这些字符串和整数来填充字典，使用字符串作为键，将整数存储为值。</span><br></pre></td></tr></table></figure>
<h1 id="一些常量"><a href="#一些常量" class="headerlink" title="一些常量"></a>一些常量</h1><p>range_size=1000<br>count=1000<br>setup_statement = ‘;’.join([<br>    “l = [(str(x), x) for x in range(1000)]”,<br>    “d={}”,<br>])</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个函数&#96;&#96;&#96;show_results()&#96;&#96;&#96;，格式化并打印输出结果。&#96;&#96;&#96;timeit()&#96;&#96;&#96;方法返回重复执行主语句所需的时间。&#96;&#96;&#96;show_results()&#96;&#96;&#96;将其转化为每次迭代所需的时间，然后进一步缩减为在字典中插入一条数据所需的平均时间。</span><br></pre></td></tr></table></figure>
<p>def show_results(result):<br>    “以微秒为单位打印每轮测试的时间和插入一条数据的时间”<br>    global count, range_size<br>    per_pass = 1000000 * (result/count)<br>    print(‘{:6.2f} usec/pass’.format(per_pass), end=’ ‘)<br>    per_item = per_pass/range_size<br>    print(‘{:6.2f} usec/item’.format(per_item))</p>
<p>print(“{} items”.format(range_size))<br>print(“{} iterations”.format(count))<br>print()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了建立基准测试，第一个测试使用&#96;&#96;&#96;__setitem()__&#96;&#96;&#96;。后续的其他测试都要避免覆盖字典中已经存在的值，所以这个简单的版本应该是速度最快的。&lt;&#x2F;br&gt;</span><br><span class="line">&#96;&#96;&#96;Timer&#96;&#96;&#96;的第一个参数是一个多行字符串，保留空白，以确保能够正确解析执行。第二个参数是一个常量，用来初始化列表和字典。</span><br></pre></td></tr></table></figure>
<h1 id="使用setitem-不检测字典中是否已存在指定的键"><a href="#使用setitem-不检测字典中是否已存在指定的键" class="headerlink" title="使用setitem 不检测字典中是否已存在指定的键"></a>使用<strong>setitem</strong> 不检测字典中是否已存在指定的键</h1><p>print(‘<strong>setitem</strong>:’, end=’ ‘)<br>t = timeit.Timer(<br>    textwrap.dedent(<br>        “””<br>        for s, i in l:<br>            d[s] = i<br>        “””<br>    ),<br>    setup_statement,<br>)<br>show_results(t.timeit(number=count))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以把更复杂的代码定义成函数，然后在命令行中调用。</span><br></pre></td></tr></table></figure>
<h1 id="timeit-setitem-py"><a href="#timeit-setitem-py" class="headerlink" title="timeit_setitem.py"></a>timeit_setitem.py</h1><p>def test_setitem(range_size=1000):<br>    l = [(str(x), x) for x in range(range_size)]<br>    d = {}<br>    for s, i in i:<br>        d[s]=i</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要测试以上函数，只需要将导入模块以及运行函数的语句作为参数。</span><br></pre></td></tr></table></figure>
<p>$ python3 -m timeit<br>“import timeit_setitem; timeit_setitem.test_setitem()”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 直接在文件中进行调用方式</span><br><span class="line">&gt; 以下内容摘自官方文档</span><br><span class="line"></span><br><span class="line">要让&#96;&#96;&#96;timeit&#96;&#96;&#96;模块访问你定义的函数，你可以传递一个包含import语句的setup函数：</span><br></pre></td></tr></table></figure>
<p>def test():<br>    “””Stupid test function”””<br>    L = [i for i in range(100)]</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    import timeit<br>    print(‘timeit.timeit(“test()”, setup=”from <strong>main</strong> import test”)’)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一种选择是将&#96;&#96;&#96;globals()&#96;&#96;&#96;传递给globals参数，这将导致代码在当前的全局命名空间中执行，这比单独指定import更方便。</span><br></pre></td></tr></table></figure>
<p>def f(x):<br>    return x<strong>2<br>def g(x):<br>    return x</strong>4<br>def h(x):<br>    return x**8</p>
<p>import timeit<br>print(timeit.timeit(‘[func(42) for func in (f,g,h)]’, globals=globals()))<br>```</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Django高级使用：三"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/07/Django%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%B8%89/"
    >Django高级使用：三</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/12/07/Django%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%B8%89/" class="article-date">
  <time datetime="2022-12-07T02:08:52.000Z" itemprop="datePublished">2022-12-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Django高级使用：三"><a href="#Django高级使用：三" class="headerlink" title="Django高级使用：三"></a>Django高级使用：三</h1><h2 id="一-Django日志管理"><a href="#一-Django日志管理" class="headerlink" title="一. Django日志管理"></a>一. Django日志管理</h2><blockquote>
<p>前言：当Django项目部署上线之后，我们很难像开发时那样容易的及时发现错误和异常。那么项目上线后开发者应该怎样检查Django程序在生产环境运行时有什么异常和错误？使用日志(log)，这部分内容将重点介绍如何在Django项目中正确配置或管理日志</p>
</blockquote>
<h3 id="1-日志基础"><a href="#1-日志基础" class="headerlink" title="1.日志基础"></a>1.日志基础</h3><blockquote>
<p>日志与我们的软件程序密不可分，它记录了程序的运行情况。可以给我们调试程序和排查故障提供非常有用的信息。每一条日志信息记录了一个事件的发生。具体而言，它包括了：</p>
</blockquote>
<ul>
<li>事件发生时间</li>
<li>事件发生位置</li>
<li>事件的严重程度-日志级别</li>
<li>事件内容<br>日志的级别又分为：</li>
<li>DEBUG: 用于调试目的的低级系统信息</li>
<li>INFO：一般系统信息</li>
<li>WARNING：描述已发生的小问题的警告信息</li>
<li>ERROR：描述已发生的主要问题的错误信息</li>
<li>CRITICAL：描述已发生的严重问题的信息<br>在Django项目中，我们可以针对日志的不同级别设置不同的处理方式。比如INFO级别及以上的日志我们写入到log文件里保存，ERROR级别及以上的日志我们直接通过邮件发送给系统管理员。<h3 id="2-Django的日志模块"><a href="#2-Django的日志模块" class="headerlink" title="2.Django的日志模块"></a>2.Django的日志模块</h3>Django的日志模块其实就是python的<code>logging</code>模块，它由4部分组成：</li>
<li>Logger记录仪：生成和记录每条日志信息及级别</li>
<li>Handler处理程序：根据日志信息级别交由相应处理程序处理(比如生成文件或发送邮件)</li>
<li>Filters过滤器：日志交由处理程序处理前需要满足的过滤条件(比如Debug=True或False)</li>
<li>Formaters格式化程序：决定每条日志的打印输出格式，可以有完整版的，也有简单版的</li>
</ul>
<p>一个<code>logger</code>记录仪的例子如下所示。当程序运行出现错误时，它生成了一条级别为error的日志信息。这条记录产生后就会交由<code>Handler</code>处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"># 获得logger实例</span><br><span class="line">logger &#x3D; logging.getLogger(__name__)</span><br><span class="line">def my_view(request, arg1, arg2):</span><br><span class="line">    ...</span><br><span class="line">    if error_happens:</span><br><span class="line">        # 如发生错误，则记录错误信息</span><br><span class="line">        logger.error(&#39;Something went wrong&#39;)</span><br></pre></td></tr></table></figure>
<p>当<code>Debug=True</code>时，日志默认从<code>console</code>输出。现在我们还需要在django配置文件里配置日志(logging)相关内容，使得当<code>Debug=False</code>时，日志信息会输出到日志文件里或发送给系统管理员。</p>
<h3 id="3-settings-py推荐日志配置"><a href="#3-settings-py推荐日志配置" class="headerlink" title="3.settings.py推荐日志配置"></a>3.settings.py推荐日志配置</h3><p>以下基本配置信息在django cookiecutter推荐使用的logging配置信息上做了修改，可适合大部分项目使用。如果真的希望发送和接收邮件还需在<code>settings.py</code>正确配置电子邮箱Email</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># 给ADMINS发送邮件需配置</span><br><span class="line">ADMINS &#x3D; (</span><br><span class="line"> (&#39;admin_name&#39;, &#39;your@gmail.com&#39;)</span><br><span class="line">)</span><br><span class="line">MANAGERS &#x3D; ADMINS</span><br><span class="line"></span><br><span class="line"># 创建log文件的文件夹</span><br><span class="line">LOG_DIR &#x3D; os.path.join(BASE_DIR, &quot;logs&quot;)</span><br><span class="line">if not os.path.exists(LOG_DIR):</span><br><span class="line">    os.mkdir(LOG_DIR)</span><br><span class="line">    </span><br><span class="line"># 基本配置，可以复用的</span><br><span class="line">LOGGING &#x3D; &#123;</span><br><span class="line">    &quot;version&quot;: 1,</span><br><span class="line">    &quot;disable_existing_loggers&quot;: False # 禁用已经存在的logger实例</span><br><span class="line">    &quot;filters&quot;:&#123;&quot;require_debug_false&quot;: &#123;&quot;()&quot;: &quot;django.utils.log.RequireDebugFalse&quot;&#125;&#125;,</span><br><span class="line">    &quot;formatters&quot;:&#123; # 定义了两种日志格式</span><br><span class="line">        &quot;verbose&quot;:&#123;</span><br><span class="line">            # 详细</span><br><span class="line">            &quot;format&quot;: &quot;%(levelname)s %(asctime)s %(module)s&quot;</span><br><span class="line">            &quot;%(process)d %(thread)d %(message)s&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;simple&quot;:&#123;</span><br><span class="line">            # 简单</span><br><span class="line">            &#39;format&#39;: &#39;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;handlers&quot;:&#123;</span><br><span class="line">        # 定义了三种日志处理方式</span><br><span class="line">        &quot;mail_admins&quot;:&#123;</span><br><span class="line">            # 只有debug&#x3D;False且Error级别以上发邮件给admin</span><br><span class="line">            &quot;level&quot;: &quot;Error&quot;,</span><br><span class="line">            &quot;filters&quot;: [&quot;require_debug_false&quot;],</span><br><span class="line">            &quot;class&quot;: &quot;django.utils.log.AdminEmailHandler&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;file&#39;:&#123;</span><br><span class="line">            # 对INFO级别以上信息以日志文件形式保存</span><br><span class="line">            &#39;level&#39;: &quot;INFO&quot;,</span><br><span class="line">            &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;, #滚动生成日志，切割</span><br><span class="line">            &#39;filename&#39;: os.path.join(LOG_DIR, &#39;django.log&#39;),</span><br><span class="line">            &#39;maxBytes&#39;: 1024*1024*10 #单个日志最大为10M</span><br><span class="line">            &#39;backupCount&#39;:5, # 日志备份文件最大数量</span><br><span class="line">            &#39;formatter&#39;:&#39;simple&#39;, # 简单格式</span><br><span class="line">            &#39;encoding&#39;: &#39;utf-8&#39; # 放置中文乱码</span><br><span class="line">        &#125;，</span><br><span class="line">        &quot;console&quot;：&#123;</span><br><span class="line">            # 打印到终端console</span><br><span class="line">            &quot;level&quot;: &quot;DEBUG&quot;,</span><br><span class="line">            &quot;class&quot;: &quot;logging.StreamHandler&quot;,</span><br><span class="line">            &quot;formatter&quot;: &quot;verbose&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;root&quot;:&#123;&quot;level&quot;:&quot;INFO&quot;, &quot;handlers&quot;:[&quot;console&quot;]&#125;,</span><br><span class="line">    &quot;loggers&quot;:&#123;</span><br><span class="line">        &quot;django.request&quot;:&#123;</span><br><span class="line">            # Django的request发生error会自动记录</span><br><span class="line">            &quot;handlers&quot;: [&quot;mail_admins&quot;],</span><br><span class="line">            &quot;level&quot;:&quot;ERROR&quot;,</span><br><span class="line">            &quot;propagate&quot;: True, # 向不向更高级别的logger传递</span><br><span class="line">        &#125;，</span><br><span class="line">        &quot;django.security.DisallowedHost&quot;:&#123;</span><br><span class="line">            # 对于不在ALLOWED_HOSTS中的请求不发送报错邮件</span><br><span class="line">            &quot;level&quot;: &quot;ERROR&quot;,</span><br><span class="line">            &quot;handlers&quot;: [&quot;console, &quot;mail_admins&quot;],</span><br><span class="line">            &quot;propagate&quot;: True,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上配置中需要我们特别关注的是Python提供的<code>RotatingFileHandler</code>，其作用是滚动生成日志文件，当单个日志文件的大小达到上限时，会生成新的日志文件。当总的日志文件数量超过日志备份最大数量时删除老的日志文件。</p>
<h3 id="4-其他日志管理工具"><a href="#4-其他日志管理工具" class="headerlink" title="4.其他日志管理工具"></a>4.其他日志管理工具</h3><p>在前面日志配置中，我们使用了Django自带的<code>logging</code>模块，另外两个常用的日志管理工具是<code>loguru</code>和<code>sentry</code>。我们将简单演示如何使用</p>
<h4 id="4-1-loguru"><a href="#4-1-loguru" class="headerlink" title="4.1 loguru"></a>4.1 loguru</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install loguru</span><br></pre></td></tr></table></figure>
<p>安装好后在Django项目中可以直接在视图中使用。省去复杂的配置，非常便捷。它定义了日志文件名、每条记录的格式、日志文件的轮替以及过滤级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.add(&quot;django.log&quot;, format&#x3D;&quot;&#123;time:YYYY-MM-DD at HH:mm:ss&#125; | &#123;level&#125; | &#123;message&#125;&quot;, rotation&#x3D;&quot;100MB&quot;, filter&#x3D;&quot;&quot;, level&#x3D;&quot;INFO&quot;, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">def my_view(request, arg1, arg2):</span><br><span class="line">    ...</span><br><span class="line">    if error_happens:</span><br><span class="line">        logger.error(&quot;Something went wrong&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="4-2-sentry"><a href="#4-2-sentry" class="headerlink" title="4.2 sentry"></a>4.2 sentry</h4><p>Sentry为多种语言以及各种框架(包括Django)提供了SDK。只需几行配置，sentry就会监控你的程序运行，自动收集错误以及上下文数据，发送到sentry服务器上，开发者可以通过sentry的web端实时查看错误和异常。</p>
<h2 id="二-Django国际化"><a href="#二-Django国际化" class="headerlink" title="二. Django国际化"></a>二. Django国际化</h2><p>&emsp;&emsp;很多时候我们的读者或客户遍布全球，这时候就需要对网站或APP进行国际化，让其支持多种语言。虽然Django的功能强大，但真正实现国际化，让网站根据用户的语言喜好来显示不同的内容并不是一件容易的事。本文将以一个最简单的例子，教你如何设置让Django支持多语种网站。</br><br>&emsp;&emsp;关于Django的国际化我们需要知道：我们实现了中英对照翻译，但这个翻译不是浏览器翻译的，Django也不会帮你翻译。这个需要你自己事先手动翻译好，存放在专门的翻译文件中，Django只是事后调用而已。</p>
<h3 id="1-修改settings-py配置"><a href="#1-修改settings-py配置" class="headerlink" title="1.修改settings.py配置"></a>1.修改settings.py配置</h3><p>假设我们已经创建了一个<code>mypoject</code>的项目，那么为了支持国际化/多语种，首先应该做如下两件事：</p>
<ul>
<li>在myproject目录下新建<code>locale</code>文件夹，用于保存翻译消息文件(.po和.mo格式的)</li>
<li>修改配置文件<code>settings.py</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">from django.utils.translation import ugettext_lazy as _</span><br><span class="line"></span><br><span class="line"># 默认语言</span><br><span class="line">LANGUAGE_CODE &#x3D; &#39;en-us&#39;</span><br><span class="line"></span><br><span class="line"># 设置I18n和L10N为True</span><br><span class="line">USE_I18N &#x3D; True</span><br><span class="line">USE_L10N &#x3D; True</span><br><span class="line"></span><br><span class="line"># 支持指定语言，这里为了简化只支持简体中文和英文</span><br><span class="line">LANGUAGES &#x3D; (</span><br><span class="line">    (&#39;en&#39;, _(&#39;English&#39;)),</span><br><span class="line">    (&#39;zh-hans&#39;,_(&#39;Simplified Chinese&#39;))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 用于存放django.po和django.mo编译过的翻译文件</span><br><span class="line">PROJECT_ROOT &#x3D; os.path.dirname(os.path.realpath(__name__))</span><br><span class="line">LOCALE_PATHS &#x3D; (</span><br><span class="line">    os.path.join(PROJECT, &#39;locale&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里我们使用了<code>ugettext_lazy</code>这个方法，它的作用是在.py文件中标记需要翻译的字符串，对其进行惰性参照存储，而不是对字符串进行真正的翻译。我们经常会在<code>models.py</code>中定义字段时用到它，也会在<code>views.py</code>中用到它，指定需要翻译的字符串。然而在模板html文件中我们并不能直接使用<code>ugettext_lazy</code>这个方法，而是使用<code>&#123;% trans "string" %&#125;, &#123;% blocktrans %&#125; &#123;% endblocktrans %&#125;这两个标签来标记需要翻译的字符串</code></br><br>&emsp;&emsp;注意：这两个标签也不是对字符串进行真正的翻译，只是标记而已。使用这两个模板标签前需要在模板的最开始地方加入<code>&#123;lload i18n %&#125;</code>。</br><br>&emsp;&emsp;最后别忘了加入<code>LocaleMiddleware</code>这个中间件，它的位置也很重要，应于<code>SessionMiddleware</code>之后，<code>CommonMiddleware</code>之前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    &#39;django.middleware.security.SecurityMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.locale.LocaleMiddleware&#39;, # 新增多语支持</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>其中，i18n是国际化(Internationalization)的缩写， l10n是本地化(localization)的缩写。</p>
<h3 id="2-修改项目的urls-py"><a href="#2-修改项目的urls-py" class="headerlink" title="2.修改项目的urls.py"></a>2.修改项目的urls.py</h3><p>本步动作是为了增加对国际化i18n的支持，具体代码如下所示：<code>i18n_patterns</code>的作用是让每个url前面自动加上所选语言的代码，比如/en/,/zh-hans/等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path, include</span><br><span class="line">from django.conf.urls.i18n import i18n_patterns</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;i18n&#x2F;&#39;, include(&#39;django.conf.urls.i18n&#39;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns +&#x3D; i18n_patterns(</span><br><span class="line">    path(&#39;admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    path(&#39;&#39;, include(&#39;myapp.urls&#39;)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-在-py-html和-txt文件中标记需要翻译的字符串"><a href="#3-在-py-html和-txt文件中标记需要翻译的字符串" class="headerlink" title="3.在.py, .html和.txt文件中标记需要翻译的字符串"></a>3.在.py, .html和.txt文件中标记需要翻译的字符串</h3><p>&emsp;&emsp;Django支持在python文件，html和txt文本文件中标记需要翻译的字符串。在python文件中使用<code>ugettext_lazy</code>方法或简写的<code>_</code>，在html和txt文件中使用<code>trans</code>和<code>blocktrans</code>标签，使用前还需要在文件开头加入<code>&#123;lload i18n %&#125;</code>。</br><br>&emsp;&emsp;例子中我们不需要使用模型，只需开发一个url，所以只需要一个视图(index)和模板(index.html).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># myapp&#x2F;urls.py</span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app_name &#x3D; &#39;myapp&#39;</span><br><span class="line">urlpatterns &#x3D; (</span><br><span class="line">    path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在视图中我们使用<code>ugettext_lazy</code>方法标记了一个需要翻译的字符串”Welcome to China”.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># myapp&#x2F;views.py</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.utils.translation import ugettext_lazy as _</span><br><span class="line"></span><br><span class="line"># Create your views here</span><br><span class="line">def index(request):</span><br><span class="line">    context &#x3D; &#123;&#39;msg&#39;: _(&quot;Welcome to China&quot;)&#125;</span><br><span class="line">    return render(request, &#39;myapp&#x2F;index.html&#39;, context)</span><br></pre></td></tr></table></figure>
<p>模板文件中最重要的一段代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;py-4 px-3 bg-light&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &#123;% get_current_language as LANGUAGE_CODE %&#125;</span><br><span class="line">        &lt;h4&gt;&#123;% trans &#39;Current language code&#39; %&#125;: &#123;&#123; LANGUAGE_CODE&#125;&#125;&lt;&#x2F;b&gt;&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;p&gt;&lt;small&gt;&#123;% trans &quot;Welcome to our page&quot; %&#125;&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;hr&#x2F;&gt;</span><br><span class="line">        &lt;p&gt;&#123;% blocktrans %&#125; &#123;&#123;msg&#125;&#125; &#123;% endblocktrans %&#125; &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>{lload i18n %}以后，你可以使用<code>get_current_language</code>标签获得当前语言，我们还在模板中分别使用<code>&#123;% trans 'string' %&#125;</code>和<code>&#123;% blocktrans&#125; &#123;%endblocktrans&#125;</code>标签来标记了两个需要翻译的字符串，一个是模板中已经存在的字符串，一个是视图函数转递过来的变量。</p>
<h3 id="4-生成-po和-mo编译消息文件"><a href="#4-生成-po和-mo编译消息文件" class="headerlink" title="4.生成.po和.mo编译消息文件"></a>4.生成.po和.mo编译消息文件</h3><p>最后一步，我们需要对前面标记的字符串进行手动翻译，并生成编译过后的消息文件供Django使用。新手最容易犯的错误就是以为<code>trans</code>标签能实现自动翻译。整个过程一共有3步，请各位仔细阅读：</p>
<h4 id="4-1-提取所有需要翻译的字符串"><a href="#4-1-提取所有需要翻译的字符串" class="headerlink" title="4.1 提取所有需要翻译的字符串"></a>4.1 提取所有需要翻译的字符串</h4><p>进入项目文件夹，使用<code>django-admin makemessages -l zh_HANS</code>命令提取所有前面标记需要翻译的字符串，该命令会自动生成一个名为<code>django.po</code>的文件，地址如下所示</p>
<h4 id="4-2-修改django-po文件，添加手动翻译的字符串"><a href="#4-2-修改django-po文件，添加手动翻译的字符串" class="headerlink" title="4.2 修改django.po文件，添加手动翻译的字符串"></a>4.2 修改<code>django.po</code>文件，添加手动翻译的字符串</h4><h4 id="4-3生成翻译编译文件"><a href="#4-3生成翻译编译文件" class="headerlink" title="4.3生成翻译编译文件"></a>4.3生成翻译编译文件</h4><p>运行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py compilemessages</span><br></pre></td></tr></table></figure>
<p>该命令会生成一个<code>django.mo</code>的文件，内容如下所示：这个就是Django最后需要调用的翻译文件，里面包含了翻译过后的字符串列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Report-Msgid-Bugs-To: </span><br><span class="line">PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE</span><br><span class="line">Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;</span><br><span class="line">Language-Team: LANGUAGE &lt;LL@li.org&gt;</span><br><span class="line">Language: </span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">Plural-Forms: nplurals&#x3D;1; plural&#x3D;0;</span><br><span class="line"> 当前语言代码 英语 隐私与Cookie 选择 简体中文 服务条款与协议 欢迎来到中国 欢迎来到我们主页</span><br></pre></td></tr></table></figure>
<h2 id="三-Docker部署Django"><a href="#三-Docker部署Django" class="headerlink" title="三. Docker部署Django"></a>三. Docker部署Django</h2><p>Django在生产环境的部署还是比较复杂的，令很多新手望而生畏，幸运的是使用Docker容器化技术可以大大简化我们Django在生产环境的部署并提升我们应用的可移植性。Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux机器上。本文将详细介绍如何使用docker-compose八步部署Django+Uwsgi+Nginx+MySQL+Redis</p>
<h3 id="1-Django-Uwsgi-Nginx-MySQL-Redis组合容器"><a href="#1-Django-Uwsgi-Nginx-MySQL-Redis组合容器" class="headerlink" title="1.Django+Uwsgi+Nginx+MySQL+Redis组合容器"></a>1.Django+Uwsgi+Nginx+MySQL+Redis组合容器</h3><ul>
<li>Django + Uwsgi容器：核心应用程序，处理动态请求</li>
<li>MySQL容器：数据库服务</li>
<li>Redis容器：缓存服务</li>
<li>Nginx容器：反向代理服务并处理静态资源请求</li>
</ul>
<p>这四个容器的依赖关系是：Django + Uwsgi容器依赖Redis容器和MySQL容器，Nginx容器依赖Django + Uwsgi容器。为了方便容器间的相互访问和通信，我们使用docker-compose时可以给每个容器取个别名，这样访问容器时就可以直接使用别名访问，而不使用Docker临时给容器分配的IP了</p>
<h3 id="2-Docker-compose部署Django项目布局树形图"><a href="#2-Docker-compose部署Django项目布局树形图" class="headerlink" title="2.Docker-compose部署Django项目布局树形图"></a>2.Docker-compose部署Django项目布局树形图</h3><p>我们新建了一个compose文件夹，专门存放用于构建其他容器镜像的Dockerfile及配置文件。compose文件夹与django项目的根目录myproject同级。这样做的好处是不同的django项目可以共享compose文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">myproject_docker  # 项目根目录</span><br><span class="line">|——— compose # 存放各项容器服务的Dockerfile和配置文件</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   │   ├── conf</span><br><span class="line">│   │   │   └── my.cnf # MySQL配置文件</span><br><span class="line">│   │   └── init</span><br><span class="line">│   │       └── init.sql # MySQL启动脚本</span><br><span class="line">│   ├── nginx</span><br><span class="line">│   │   ├── Dockerfile # 构建Nginx镜像所的Dockerfile</span><br><span class="line">│   │   ├── log # 挂载保存nginx容器内日志log目录</span><br><span class="line">│   │   ├── nginx.conf # Nginx配置文件</span><br><span class="line">│   │   └── ssl # 如果需要配置https需要用到</span><br><span class="line">│   ├── redis</span><br><span class="line">│   │   └── redis.conf # redis配置文件</span><br><span class="line">│   └── uwsgi # 挂载保存django+uwsgi容器内uwsgi日志</span><br><span class="line">├── docker-compose.yml # 核心编排文件</span><br><span class="line">└── myproject # 常规Django项目目录</span><br><span class="line">    ├── Dockerfile # 构建Django+Uwsgi镜像的Dockerfile</span><br><span class="line">    ├── apps # 存放Django项目的各个apps</span><br><span class="line">    ├── manage.py</span><br><span class="line">    ├── myproject # Django项目配置文件</span><br><span class="line">    │   ├── asgi.py</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── settings.py</span><br><span class="line">    │   ├── urls.py</span><br><span class="line">    │   └── wsgi.py</span><br><span class="line">    ├── pip.conf # 非必需。pypi源设置成国内，加速pip安装</span><br><span class="line">    ├── requirements.txt # Django项目依赖文件</span><br><span class="line">    ├── .env # 环境变量文件</span><br><span class="line">    ├── start.sh # 启动Django+Uwsgi容器后要执行的脚本</span><br><span class="line">    ├── media # 用户上传的媒体资源，如果没有需手动创建</span><br><span class="line">    ├── static #搜集项目的静态文件夹，如果没有需手动创建</span><br><span class="line">    └── uwsgi.ini # uwsgi配置文件</span><br></pre></td></tr></table></figure>
<h3 id="3-正式部署"><a href="#3-正式部署" class="headerlink" title="3.正式部署"></a>3.正式部署</h3><h4 id="3-1-编写docker-compose-yml文件"><a href="#3-1-编写docker-compose-yml文件" class="headerlink" title="3.1 编写docker-compose.yml文件"></a>3.1 编写docker-compose.yml文件</h4><p>修改过的docker-compose.yml的核心内容如下。我们定义了4个数据卷，用于挂载各个容器内动态生成的数据，比如MySQL的存储数据， redis生成的快照、django+uwsgi容器收集的静态文件以及用户上传的媒体资源。这样即使删除容器，容器内产生的数据也不会丢失。</br><br>我们还定义了三个网络，分别为<code>nginx_network</code>(用于nginx和web容器间的通信)，<code>db_network</code>(用于db和web容器间的通信)和<code>redis_network</code>(用于redis和web容器间的通信)。</br><br>整个编排里包含4项容器服务，别名分别为：<code>redis</code>、<code>db</code>、<code>nginx</code>和<code>web</code>，接下来我们将依次看看各个容器的Dockerfile和配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">volume: # 自定义数据卷</span><br><span class="line">  db_vol:# 定义数据卷同步存放容器内mysql数据</span><br><span class="line">  redis_vol: # 定义数据卷同步存放redis数据</span><br><span class="line">  media_vol: # 定义数据卷同步存放web项目用户上传到media文件夹的数据</span><br><span class="line">  static_vol: # 定义数据同步存放web项目static文件夹的数据</span><br><span class="line">  </span><br><span class="line">networks: # 自定义网络(默认桥接)，不使用links通信</span><br><span class="line">  nginx_network:</span><br><span class="line">    driver: bridge</span><br><span class="line">  db_network:</span><br><span class="line">    driver: bridge</span><br><span class="line">  redis_network:</span><br><span class="line">    driver: bridge</span><br><span class="line"></span><br><span class="line">serices:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    command: redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf # 容器启动后启动redis服务</span><br><span class="line">    networks:</span><br><span class="line">      - redis_network</span><br><span class="line">    volums:</span><br><span class="line">      - redis_vol: &#x2F;data # 通过挂载给redis数据备份</span><br><span class="line">      - .&#x2F;compose&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf # 挂载redis配置文件</span><br><span class="line">    ports:</span><br><span class="line">      -&quot;6379:6379</span><br><span class="line">    restart: always # always表示容器运行发生错误时一直重启</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: mysql</span><br><span class="line">  env_file:</span><br><span class="line">    - .&#x2F;myproject&#x2F;.env # 使用了环境变量文件</span><br><span class="line">  networks:</span><br><span class="line">    -db_network</span><br><span class="line">  volumes:</span><br><span class="line">    -db_vol:&#x2F;var&#x2F;lib&#x2F;mysql # 挂载数据库数据，可读可写</span><br><span class="line">    - .&#x2F;compose&#x2F;mysql&#x2F;conf&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;my.cnf # 挂载配置文件</span><br><span class="line">    - .&#x2F;compose&#x2F;mysql&#x2F;init: &#x2F;docker-entrypoint-initdb.d&#x2F; # 挂载数据初始化sql脚本</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;3306:3306&quot; # 与配置文件保持一致</span><br><span class="line">  restart:always</span><br><span class="line"> </span><br><span class="line">web:</span><br><span class="line">  build: .&#x2F;myproject</span><br><span class="line">  expose:</span><br><span class="line">    -&quot;8000&quot;</span><br><span class="line">  volums:</span><br><span class="line">    - .&#x2F;myproject:&#x2F;var&#x2F;www&#x2F;html&#x2F;myproject # 挂载项目代码</span><br><span class="line">    - static_vol:&#x2F;var&#x2F;www&#x2F;html&#x2F;myproject&#x2F;static # 以数据卷挂载容器内static文件</span><br><span class="line">    - media_vol:&#x2F;var&#x2F;www&#x2F;html&#x2F;myproject&#x2F;media #以数据卷挂载容器内用户上传媒体文件</span><br><span class="line">    - .&#x2F;compose&#x2F;uwsgi: &#x2F;tmp # 挂载uwsgi日志</span><br><span class="line">  networks:</span><br><span class="line">    - nginx_network</span><br><span class="line">    - db_network</span><br><span class="line">    - redis_network</span><br><span class="line">  depends_on:</span><br><span class="line">    - db</span><br><span class="line">    - redis</span><br><span class="line">  restart: always</span><br><span class="line">  tty: true</span><br><span class="line">  stdin_open: true</span><br><span class="line"></span><br><span class="line">nginx:</span><br><span class="line">  build: .&#x2F;compose&#x2F;nginx</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;80:80&quot;</span><br><span class="line">    - &quot;443:443&quot;</span><br><span class="line">  expose:</span><br><span class="line">    - &quot;80&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - .&#x2F;compose&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;nginx.conf # 挂载nginx配置文件</span><br><span class="line">    - .&#x2F;compose&#x2F;nginx&#x2F;ssl:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;ssl # 挂载ssl证书目录</span><br><span class="line">    - .&#x2F;compose&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx # 挂载日志</span><br><span class="line">    - static_vol:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static # 挂载静态文件</span><br><span class="line">    - media_vol:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;media # 挂载用户上传媒体文件</span><br><span class="line">  networks:</span><br><span class="line">    - nginx_network</span><br><span class="line">  depends_on:</span><br><span class="line">    - web</span><br><span class="line">  restart:always</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="3-2-编写Web-Django-Uwsgi-镜像和容器所需文件"><a href="#3-2-编写Web-Django-Uwsgi-镜像和容器所需文件" class="headerlink" title="3.2 编写Web(Django+Uwsgi)镜像和容器所需文件"></a>3.2 编写Web(Django+Uwsgi)镜像和容器所需文件</h4><p>构建Web镜像(Django+Uwsgi)的所使用的Dockerfile如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 建立 python 3.9环境</span><br><span class="line">FROM python:3.9</span><br><span class="line"></span><br><span class="line"># 安装netcat</span><br><span class="line">RUN apt-get update &amp;&amp; apt install -y netcat</span><br><span class="line"></span><br><span class="line"># 镜像作者</span><br><span class="line">MAINTAINER lzx</span><br><span class="line"></span><br><span class="line"># 设置python环境变量</span><br><span class="line">ENV PYTHONDONTWRITEBYTECODE 1</span><br><span class="line">ENV PYTHONUNBUFFERD 1</span><br><span class="line"></span><br><span class="line"># 可选: 设置镜像源为国内</span><br><span class="line">COPY pip.conf &#x2F;root&#x2F;.pip&#x2F;pip.conf</span><br><span class="line"></span><br><span class="line"># 容器内创建myproject文件夹</span><br><span class="line">ENV APP_HOME&#x3D;&#x2F;var&#x2F;www&#x2F;html&#x2F;myproject</span><br><span class="line">RUN mkdir -p $APP_HOME</span><br><span class="line">WORKDIR $APP_HOME</span><br><span class="line"></span><br><span class="line"># 将当前目录加入到工作目录中</span><br><span class="line">ADD . $APP_HOME</span><br><span class="line"></span><br><span class="line"># 更新pip版本</span><br><span class="line">RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python -m pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"># 安装项目依赖</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 移除\r in windows</span><br><span class="line">RUN sed -i &#39;s&#x2F;\r&#x2F;&#x2F;&#39; .&#x2F;start.sh</span><br><span class="line"></span><br><span class="line"># 给start.sh可执行权限</span><br><span class="line">RUN chmod +x .&#x2F;start.sh</span><br><span class="line"></span><br><span class="line"># 数据迁移，并使用uwsgi启动服务</span><br><span class="line">ENTRYPOINT &#x2F;bin&#x2F;bash .&#x2F;start.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 从第一行到最后一行分别表示：</span><br><span class="line"># 1.等待MySQL服务启动后再进行数据迁移，nc即netcat缩写</span><br><span class="line"># 2.收集静态文件到根目录static文件夹</span><br><span class="line"># 3.生成数据库可执行文件</span><br><span class="line"># 4.根据数据库可执行文件来修改数据库</span><br><span class="line"># 5.用uwsgi启动django服务</span><br><span class="line"># 6.tail空命令防止web容器执行脚本后退出</span><br><span class="line">while ! nc -z db 3306 ;do</span><br><span class="line">    echo &quot;Waiting for the MySQL Server&quot;</span><br><span class="line">    sleep 3</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">python manage.py collectstatic --noinput &amp;&amp;</span><br><span class="line">python manage.py makemigrations&amp;&amp;</span><br><span class="line">python manage.py migrate&amp;&amp;</span><br><span class="line">uwsgi --ini &#x2F;var&#x2F;www&#x2F;html&#x2F;myproject&#x2F;uwsgi.ini&amp;&amp;</span><br><span class="line">tail -f &#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">[uwsgi]</span><br><span class="line"></span><br><span class="line">project&#x3D;myproject</span><br><span class="line">uid&#x3D;www-data</span><br><span class="line">gid&#x3D;www-data</span><br><span class="line">base&#x3D;&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line"></span><br><span class="line">chdir&#x3D;%(base)&#x2F;%(project)</span><br><span class="line">module&#x3D;%(project).wsgi:application</span><br><span class="line">master&#x3D;True</span><br><span class="line">processes&#x3D;2</span><br><span class="line"></span><br><span class="line">socket&#x3D;0.0.0.0:8000</span><br><span class="line">chown-socket&#x3D;%(uid):www-data</span><br><span class="line">chmod-socket&#x3D;664</span><br><span class="line"></span><br><span class="line">vacuum&#x3D;True</span><br><span class="line">max-requests&#x3D;5000</span><br><span class="line"></span><br><span class="line">pidfile&#x3D;&#x2F;tmp&#x2F;%(project)-master.pid</span><br><span class="line">daemonize&#x3D;&#x2F;tmp&#x2F;%(project)-uwsgi.log</span><br><span class="line"></span><br><span class="line"># 设置一个请求的超时时间，如果一个请求超过了这个时间，则请求被丢弃</span><br><span class="line">harakiri &#x3D; 60</span><br><span class="line">post buffering &#x3D; 8192</span><br><span class="line">buffer-size &#x3D; 65535</span><br><span class="line"># 当一个请求被harakiri杀掉时，会输出一条日志</span><br><span class="line">harakiri-verbose &#x3D; true</span><br><span class="line"></span><br><span class="line"># 开启内存使用情况报告</span><br><span class="line">memory-report &#x3D; true</span><br><span class="line"></span><br><span class="line"># 设置平滑的重启(直到处理完接收到的请求)的长等待时间</span><br><span class="line">reload-merccy &#x3D; 10</span><br><span class="line"></span><br><span class="line"># 设置工作进度使用虚拟内存超过N MB就回收重启</span><br><span class="line">reload-on-as&#x3D;1024</span><br></pre></td></tr></table></figure>
<h4 id="3-3-编写Nginx镜像和容器所需文件"><a href="#3-3-编写Nginx镜像和容器所需文件" class="headerlink" title="3.3 编写Nginx镜像和容器所需文件"></a>3.3 编写Nginx镜像和容器所需文件</h4><p>构建Nginx镜像所需的Dockerfile如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># nginx镜像compose&#x2F;nginx&#x2F;Dockerfile</span><br><span class="line"></span><br><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line"># 删除原有配置文件，创建静态资源文件和ssl证书保存文件夹</span><br><span class="line">RUN rm &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf \</span><br><span class="line">&amp;&amp; mkdir -p &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static \</span><br><span class="line">&amp;&amp; mkdir -p &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;media \</span><br><span class="line">&amp;&amp; mkdir -p &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;ssl</span><br><span class="line"></span><br><span class="line"># 设置media文件夹用户和用户组为Linux默认www-data，并给予可读和可执行权限</span><br><span class="line"># 否则用户上传的图片无法正常显示</span><br><span class="line">RUN chown -R www-data:www-data &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;media \</span><br><span class="line">&amp;&amp; chmod -R 775 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;media</span><br><span class="line"></span><br><span class="line"># 添加配置文件</span><br><span class="line">ADD .&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br><span class="line"></span><br><span class="line"># 关闭守护模式</span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>
<p>Nginx的配置文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># nginx配置文件</span><br><span class="line"># compose&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line">upstream django&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server web:8000; # Docker-compose web服务端口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置http请求，80端口</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80; # 监听80端口</span><br><span class="line">    server_name 127.0.0.1; # 可以是Nginx容器所在ip地址或127.0.0.1，不能写宿主机外网ip地址</span><br><span class="line">    </span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 10M; # 限制用户上传文件大小</span><br><span class="line">    </span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access_log main;</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;static&#123;</span><br><span class="line">        alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static; # 静态资源路径</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;media&#123;</span><br><span class="line">        alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;media; # 媒体资源，用户上传文件路径</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params;</span><br><span class="line">        uwsgi_pass django;</span><br><span class="line">        uwsgi_read_timeout 600;</span><br><span class="line">        uwsgi_connect_timeout 600;</span><br><span class="line">        uwsgi_send_timeout 600;</span><br><span class="line">        </span><br><span class="line">        proxy_set_header X-Formwarded-For &amp;proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        # proxy_pass http:&#x2F;&#x2F;django; # 使用uwsgi通信，而不是http，所以不使用proxy_pass</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-编写Db-MySQL-容器配置文件"><a href="#3-4-编写Db-MySQL-容器配置文件" class="headerlink" title="3.4 编写Db(MySQL)容器配置文件"></a>3.4 编写Db(MySQL)容器配置文件</h4><p>启动MySQL容器我们直接使用官方镜像即可，不过我们需要给MySQL增加配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># compose&#x2F;mysql&#x2F;conf&#x2F;my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">user&#x3D;mysql</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">secure-file-priv&#x3D;NULL</span><br><span class="line">default-authentication-plugin&#x3D;mysql_native_password</span><br><span class="line"></span><br><span class="line">port &#x3D; 3306 # 端口与docker-compose里映射端口保持一致</span><br><span class="line">#bind-address&#x3D;localhost # 一定要注释掉，mysql所在容器和Django所在容器不同ip</span><br><span class="line"></span><br><span class="line">basedir &#x3D;&#x2F;usr</span><br><span class="line">datadir &#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">tmpdir &#x3D; &#x2F;tmp</span><br><span class="line">pid-file &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">port&#x3D;3306</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们还需要设置MySQL服务启动时需要执行的脚本命令，注意这里的用户名和password必须和myproject目录下<code>.env</code>文件中的环境变量保持一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># compose&#x2F;mysql&#x2F;init&#x2F;init.sql</span><br><span class="line">Alter user &#39;dbuser&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</span><br><span class="line">GRANT ALL PRIVILEGES ON myproject.* TO &#39;dbuser&#39;@&#39;%&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">MYSQL_ROOT_PASSWORD&#x3D;123456</span><br><span class="line">MYSQL_USER&#x3D;dbuser</span><br><span class="line">MYSQL_DATABASE&#x3D;myproject</span><br><span class="line">MYSQL_PASSWORD&#x3D;password</span><br></pre></td></tr></table></figure>
<h4 id="3-5-编写Redis容器配置文件"><a href="#3-5-编写Redis容器配置文件" class="headerlink" title="3.5 编写Redis容器配置文件"></a>3.5 编写Redis容器配置文件</h4><p>启动redis容器我们直接使用官方镜像即可，不过我们需要给redis增加配置文件，大部分情况下采用默认配置就好了，这里我们只做出了如下几条核心改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># compose&#x2F;redis&#x2F;redis.conf</span><br><span class="line"># Redis 5 配置文件下载地址</span><br><span class="line"></span><br><span class="line"># 请注释掉下面一行，这样其他机器或容器也可访问</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 取消下行注释，给redis设置登录密码，这个密码django settings.py会用到</span><br><span class="line">requirepass yourpassword</span><br></pre></td></tr></table></figure>
<h4 id="3-6-修改Django项目settings-py"><a href="#3-6-修改Django项目settings-py" class="headerlink" title="3.6 修改Django项目settings.py"></a>3.6 修改Django项目settings.py</h4><p>在我们准备好docker-compose.yml并编排好各容器的Dockerfile及配置文件后，不要急于使用Docker-compose命令构建镜像和启动容器。此时要先修改Django的<code>settings.py</code>，提供Mysql和redis服务的配置信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 生产环境设置Debug&#x3D;False</span><br><span class="line">Debug &#x3D; False</span><br><span class="line"></span><br><span class="line"># 设置ALLOWED HOSTS</span><br><span class="line">ALLOWED_HOSTS &#x3D; [&#39;your_server_IP&#39;, &#39;your_domain_name&#39;]</span><br><span class="line"></span><br><span class="line"># 设置STATIC ROOT和STATIC URL</span><br><span class="line">STATIC_ROOT &#x3D; os.path.join(BASE_DIR, &#39;static&#39;)</span><br><span class="line">STATIC_URL &#x3D; &quot;&#x2F;media&#x2F;&quot;</span><br><span class="line"></span><br><span class="line"># 设置数据库，这里用户名和密码必须和docker-compose.yml里mysql环境变量保持一致</span><br><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;:&#123;</span><br><span class="line">        &#39;ENGINE&#39;: &#39;django.db.bakends.mysql&#39;,</span><br><span class="line">        &#39;NAME&#39;: &#39;myproject&#39;, # 数据库名</span><br><span class="line">        &#39;USER&#39;: &#39;dbuser&#39;, # 你设置的用户名</span><br><span class="line">        &#39;PASSWORD&#39;: &#39;password&#39;,</span><br><span class="line">        &#39;HOST&#39;: &#39;db&#39;,</span><br><span class="line">        &#39;PORT&#39;: &#39;3306&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 设置redis缓存，这里密码为redis.conf里设置的密码</span><br><span class="line">CACHES &#x3D; &#123;</span><br><span class="line">    &quot;default&quot;:&#123;</span><br><span class="line">        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,</span><br><span class="line">        &quot;LOCATION&quot;: &quot;redis:&#x2F;&#x2F;redis:6379&#x2F;1&quot;,</span><br><span class="line">        &quot;OPTIONS&quot;:&#123;</span><br><span class="line">            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultCient&quot;,</span><br><span class="line">            &quot;PASSWORD&quot;: &quot;yourpassword&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-7-使用docker-compose构建镜像并启动容器组服务"><a href="#3-7-使用docker-compose构建镜像并启动容器组服务" class="headerlink" title="3.7 使用docker-compose构建镜像并启动容器组服务"></a>3.7 使用docker-compose构建镜像并启动容器组服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入docker-compose.yml所在文件夹，输入以下命令构建镜像</span><br><span class="line">sudo docker-compose build</span><br><span class="line"># 查看已生成的镜像</span><br><span class="line">sudo docker images</span><br><span class="line"># 启动容器组服务</span><br><span class="line">sudo docker-compose up</span><br></pre></td></tr></table></figure>
<h4 id="3-8-排错"><a href="#3-8-排错" class="headerlink" title="3.8 排错"></a>3.8 排错</h4><h5 id="Nginx容器排错"><a href="#Nginx容器排错" class="headerlink" title="Nginx容器排错"></a>Nginx容器排错</h5><p>容器已经启动运行，网站打不开，最有用的是查看Nginx的错误日志error.log，由于我们对Nginx的log进行了挂载，你可以在宿主机的/compose/nginx/log目录里直接查看相关日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入nginx日志目录，一个access.log,一个error.log</span><br><span class="line">cd compose&#x2F;nginx&#x2F;log</span><br><span class="line">cat error.log</span><br></pre></td></tr></table></figure>
<p>绝大部分网站打不开，Nginx日志显示<code>nginx:connect() failed(111:Connection refused) while connecting to upstream</code>或Nginx 502 gateway的错误都不是因为nginx自身的原因导致的，而是Web容器中Django程序有问题或者uwsgi配置文件有问题。</br><br>在进入Web容器排错前，你首先要检查下Nginx转发请求的方式(proxy_pass和uwsgi_pass)以及转发端口与uwsgi的监听方式以及端口是否一致。</br><br>uWSGI和Nginx之间有3种通信方式：unix socket, TCP socket和http，如果Nginx以proxy_pass方式转发请求，uwsgi需要使用http协议进行通信。如果Nginx以<code>uwsgi_pass</code>转发请求，uwsgi建议配置socket进行通信</p>
<h5 id="Web容器排错"><a href="#Web容器排错" class="headerlink" title="Web容器排错"></a>Web容器排错</h5><p>Web容器也就是Django+UWSGI所在的容器。如果Nginx配置没问题，应该进入web容器查看运行脚本命令时有没有报错，并检查uwsgi的运行日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看web容器的日志</span><br><span class="line">dicker-compose logs web</span><br><span class="line"># 进入web容器执行启动命令，查看有无报错</span><br><span class="line">docker-compose exec web &#x2F;bin&#x2F;bash start.sh</span><br><span class="line"># 或者进入web容器内</span><br><span class="line">docker-compose exec web &#x2F;bin&#x2F;bash</span><br><span class="line"># 进入web容器，查看uwsgi是否正常启动</span><br><span class="line">ps aux | grep uwsgi</span><br><span class="line"># 进入uwsgi日志所在目录，查看Django项目是否有报错</span><br><span class="line">cd &#x2F;tmp</span><br></pre></td></tr></table></figure>
<p>有时web容器会出现不能连接到数据库的报错，这时需要检查<code>settings.py</code>中的数据库配置信息是否正确，并检查web容器和db容器是否通过<code>db_network</code>正常通信</p>
<h5 id="数据库db容器排错"><a href="#数据库db容器排错" class="headerlink" title="数据库db容器排错"></a>数据库db容器排错</h5><p>我们还需要经常进入数据库容器查看数据表是否已生成并删除一些数据，这时可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 进入db容器</span><br><span class="line">docker-compose exec db &#x2F;bin&#x2F;bash</span><br><span class="line"># 登录</span><br><span class="line">mysql -u username -p;</span><br><span class="line"># 选择数据库</span><br><span class="line">USE dbname;</span><br><span class="line"># 显示数据库</span><br><span class="line">SHOW tables;</span><br><span class="line"># 清空数据表</span><br><span class="line">DELETE from tablename;</span><br><span class="line"># 删除数据表</span><br><span class="line">DROP TABLE tablename;</span><br></pre></td></tr></table></figure>
<h2 id="四-Django性能优化大全"><a href="#四-Django性能优化大全" class="headerlink" title="四.Django性能优化大全"></a>四.Django性能优化大全</h2><p>&emsp;&emsp;如果你的Python程序或Django项目运行速度慢，先别急着怪Django。其实程序运行效率是可以通过提升硬件水平、架构和数据库优化和改进算法来大大提升的。这部分将列举一些主要的Django性能优化手段，完全可以让你的Django程序跑的飞快。</br><br>&emsp;&emsp;过度性能优化是没有必要甚至是有害的。因为花大力气带来的毫秒级的响应提升你的用户可能根本感知不到，毕竟开发人员的时间也很宝贵。</p>
<h3 id="1-性能优化指标"><a href="#1-性能优化指标" class="headerlink" title="1.性能优化指标"></a>1.性能优化指标</h3><p>在对一个Web项目进行性能优化时，我们通常需要考虑如下几个指标：</p>
<ul>
<li>响应时间</li>
<li>最大并发连接数</li>
<li>代码的行数</li>
<li>函数调用次数</li>
<li>内存占用情况</li>
<li>CPU占比</li>
</ul>
<p>&emsp;&emsp;其中响应时间(服务器从接收用户请求、处理该请求并返回结果所需的总时间)通常是最重要的性能指标，因为过长的响应时间会让用户厌倦等待，转投其他网站或APP。当你的用户数量变得非常庞大，如何提高最大并发连接数，减少内存消耗也将变得非常重要。</br><br>&emsp;&emsp;在开发环境中，我们一般建议使用<code>django-debug-toolbar</code>和<code>django-silk</code>来进行性能监测分析。它们提供了每次用户请求的响应时间，并告诉你程序执行过程哪个环节(比如SQL查询)最消耗时间。</br><br>&emsp;&emsp;对于中大型网站或Web APP而言，最影响网站性能的就是数据库查询部分了。一是反复从数据库读写数据很消耗时间和计算资源。二是当返回的查询数据集queryset非常大时还会占据很多内存。我们先从这部分优化做起。</p>
<h3 id="2-数据库查询优化"><a href="#2-数据库查询优化" class="headerlink" title="2.数据库查询优化"></a>2.数据库查询优化</h3><h4 id="利用Queryset的惰性和缓存，避免重复查询"><a href="#利用Queryset的惰性和缓存，避免重复查询" class="headerlink" title="利用Queryset的惰性和缓存，避免重复查询"></a>利用Queryset的惰性和缓存，避免重复查询</h4><p>充分利用Django的QuerySet的惰性和自带缓存特性，可以帮助我们减少数据库查询次数。比如下例中例1要比例2好。因为你在打印文章标题后，Django不仅执行了数据库查询，还把查询到的<code>article_list</code>放在了缓存里，下次可以在其他地方复用，而例2就不行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 例1-利用了缓存特性</span><br><span class="line">article_list &#x3D; Article.objects.filter(title_contain&#x3D;&quot;django&quot;)</span><br><span class="line">for article in article_list:</span><br><span class="line">    print(article.title)</span><br><span class="line">    </span><br><span class="line"># 例2</span><br><span class="line">for article in Article.objects.filter(title_contains&#x3D;&quot;django&quot;):</span><br><span class="line">    print(article.title)</span><br></pre></td></tr></table></figure>
<p>但有时我们只希望了解查询的结果是否存在或查询结果的数量，这时可以使用<code>exists()</code>和<code>count()</code>方法，如下所示。这样做就不会浪费资源查询一个用不到的数据集，还可以节省内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 例3：</span><br><span class="line">article_list &#x3D; Article.objects.filter(title_contains&#x3D;&quot;django&quot;)</span><br><span class="line">if article_list.exists():</span><br><span class="line">    print(&quot;Records found.&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;No records&quot;)</span><br><span class="line">    </span><br><span class="line"># 例4：</span><br><span class="line">count &#x3D; Article.objects.filter(title_contains&#x3D;&quot;django&quot;).count()</span><br></pre></td></tr></table></figure>
<h4 id="一次查询所有需要的关联模型数据"><a href="#一次查询所有需要的关联模型数据" class="headerlink" title="一次查询所有需要的关联模型数据"></a>一次查询所有需要的关联模型数据</h4><p>假设我们有一个文章(Article)模型，其与类别(Category)是单对多的关系(ForeignKey)，与标签(Tag)是多对多的关系(ManyToMany)。我们需要编写一个<code>article_list</code>的函数视图，以列表形式显示文章清单及每篇文章的类型和标签，你的模板文件可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for article in articles %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; article.title&#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; article.category.name &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &#123;% for tag in article.tags.all%&#125;</span><br><span class="line">            &#123;&#123; tag.name &#125;&#125;,</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>在模板里每进行一次for循环获取关联对象category和tag的信息，Django就要单独进行一次数据库查询，造成了极大资源浪费。我们完全可以使用<code>select_related</code>方法和<code>prefetch_related</code>方法一次性从数据库获取单对多和多对多关联模型数据，这样在模板中遍历时Django也不会执行数据库查询了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 仅获取文章数据 -Bad</span><br><span class="line">def article_list(request):</span><br><span class="line">    articles &#x3D; Article.objects.all()</span><br><span class="line">    return render(request, &#39;blog&#x2F;article_list.html&#39;, &#123;&#39;articles&#39;: articles,&#125;)</span><br><span class="line"></span><br><span class="line"># 一次性提取关联模型数据 -Good</span><br><span class="line">def article_list(request):</span><br><span class="line">    articles &#x3D; Article.objects.all().select_related(&#39;category&#39;).prefecth_related(&#39;tags&#39;)</span><br><span class="line">    return render(request, &#39;blog&#x2F;article_list.html&#39;, &#123;&#39;articles&#39;: article,&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="仅查询需要用到的数据"><a href="#仅查询需要用到的数据" class="headerlink" title="仅查询需要用到的数据"></a>仅查询需要用到的数据</h4><p>&emsp;&emsp;默认情况下Django会从数据库中提取所有字段，但是当数据表有很多列很多行的时候，告诉Django提取哪些特定的字段就非常有意义了。假如我们的数据库中有100万篇文章，需要循环打印每篇文章的标题。如果按例4操作，我们会将每篇文章对象的全部信息都提取出来载入到内存中，不仅花费更多时间查询，还会占用大量内存，而最后只用了一个title字段，这是完全没有必要的。我们可以使用<code>values</code>和<code>value_list</code>方法按需提取数据，比如只获取文章的id和title，节省查询时间和查询内存。</p>
<h4 id="使用分页，限制最大页数"><a href="#使用分页，限制最大页数" class="headerlink" title="使用分页，限制最大页数"></a>使用分页，限制最大页数</h4><p>上面的方法可以做进一步的优化，比如使用分页仅展示用户所需要的数据，而不是一下子展示所有数据。同时使用分页时也最好控制最大页数，比如当你的数据库有100万篇文章时，每页即使展示100页，也需要1万页展示给你的用户，这是完全没有必要的。你可以完全只展示前200页的数据，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LIMIT &#x3D; 100 * 200</span><br><span class="line"></span><br><span class="line">data &#x3D; Articles.objects().all()[:(LIMIT+1)]</span><br><span class="line">if len(data) &gt; LIMIT:</span><br><span class="line">    raise ExceededLimit(LIMIT)</span><br><span class="line">    </span><br><span class="line">return data</span><br></pre></td></tr></table></figure>
<h4 id="数据库设置优化"><a href="#数据库设置优化" class="headerlink" title="数据库设置优化"></a>数据库设置优化</h4><p>如果你使用单个数据库，你可以采用如下手段进行优化：</p>
<ul>
<li>建立模型时能用<code>CharField</code>确定长度的字段尽量不用<code>TextField</code>，可节省存储空间。</li>
<li>可以给搜索频率高的字段属性，在定义模型时使用索引(<code>db_index=True</code>)</li>
<li>持久化数据库连接</li>
</ul>
<blockquote>
<p>The document says that using <code>db_index=True</code> on model fields is used to speed up the lookups with slightly disadvantages with storages and memory</p>
</blockquote>
<p>没有持久化连接，Django每个请求都会与数据库创建一个连接，直到请求结束，关闭连接。如果数据库不在本地，每次建立和关闭连接也需要花费一些时间。设置持久化连接时间，仅需要添加<code>CONN_MAX_AGE</code>参数到你的数据库设置中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;:&#123;</span><br><span class="line">        &#39;ENGINE&#39;: &#39;django.db.backends.postgresql_psycopg2&#39;,</span><br><span class="line">        &#39;NAME&#39;: &#39;postgres&#39;,</span><br><span class="line">        &#39;CONN_MAX_AGE&#39;: 60,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然CONN_MAX_AGE也不宜设置过大，因为每个数据库并发连接数有上限，比如mysql默认的最大并发连接数是100个。如果CONN_MAX_AGE设置的过大，会导致mysql数据库连接数飙升很快达到上限。当并发请求数量很高时，CONN_MAX_AGE应该设低点；当并发请求数不高时，这个值可以设置的长一点。</br><br>当用户非常多，数据量非常大时，你可以考虑读写分离、主从复制、分表分库的多数据库服务器架构。这种架构上的布局是对所有Web开发语言适用的。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存是一类可以更快的读取数据的介质统称，也指其它可以加快数据读取的存储方式。一般用来存储临时数据，常用介质是读取速度很快的内存。一般来说从数据库多词把所需要的数据提取出来，要比从内存或者硬盘等一次读出来付出的成本大很多。对于中大型网站而言，使用缓存减少对数据库的访问次数是提升网站性能的关键之一。</p>
<h5 id="视图缓存"><a href="#视图缓存" class="headerlink" title="视图缓存"></a>视图缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.views.decorators.cache import cache_page</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@cache_page(60*15)</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h5 id="使用-cached-property装饰器缓存计算属性"><a href="#使用-cached-property装饰器缓存计算属性" class="headerlink" title="使用@cached_property装饰器缓存计算属性"></a>使用@cached_property装饰器缓存计算属性</h5><p>对于不经常变动的计算属性，可以使用<code>@cached_property</code>装饰器缓存结果。</p>
<h5 id="缓存临时性数据比如sessions"><a href="#缓存临时性数据比如sessions" class="headerlink" title="缓存临时性数据比如sessions"></a>缓存临时性数据比如sessions</h5><p>Django的session默认是存在数据库中的，这样的话每一个请求Django都要使用sql查询会话数据，然后获得用户对象的信息，对于临时性的数据比如sessions和messages，最好将它们放在缓存中，也可以减少SQL查询次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SESSION_ENGINE &#x3D; &#39;django.contrib.sessions.backends.cache&#39;</span><br></pre></td></tr></table></figure>
<h5 id="模板缓存"><a href="#模板缓存" class="headerlink" title="模板缓存"></a>模板缓存</h5><p>默认情况下Django每处理一个请求都会使用模板加载器，都会去文件系统里搜索模板，然后渲染这些模板。你可以通过使用<code>cached.loader</code>开启模板缓存加载。这时Django只会查找并且解析你的模板一次，可以大大提升模板渲染效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES &#x3D; [&#123;</span><br><span class="line">    &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">    &#39;DIRS&#39;: [BASE_DIR &#x2F; &#39;templates&#39;],</span><br><span class="line">    &#39;OPTIONS&#39;:&#123;</span><br><span class="line">        &#39;loaders&#39;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &#39;django.template.loaders.cached.Loader&#39;,[</span><br><span class="line">            &#39;django.template.loaders.filesystem.Loader&#39;,</span><br><span class="line">            &#39;django.template.loaders.app_directories.Loader&#39;,</span><br><span class="line">            &#39;path.to.custom.Loader&#39;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>另外模板文件中建议使用with标签缓存视图传来的数据，便于下一次时使用，对于公用的html片段，也建议使用缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load cache %&#125;</span><br><span class="line">&#123;% cache 500 sidebar request.user.username %&#125;</span><br><span class="line">  .. sidebar for loggerd in user ..</span><br><span class="line">&#123;% cache % &#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>压缩HTML、CSS和JavaScript等静态文件可以节省带宽和传输时间。Django自带的压缩工具有GzipMiddleware中间件和spaceless模板Tag。使用Python压缩静态文件会影响性能，一个更好的方法是通过Apache、Nginx服务器来对输出内容进行压缩。例如Nginx服务器支持gzip压缩，同时可以设置expires选项设置静态文件的缓存时间。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Django高级使用：一"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/21/Django%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%B8%80/"
    >Django高级使用：一</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/11/21/Django%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%B8%80/" class="article-date">
  <time datetime="2022-11-21T13:08:52.000Z" itemprop="datePublished">2022-11-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Django高级使用：一"><a href="#Django高级使用：一" class="headerlink" title="Django高级使用：一"></a>Django高级使用：一</h1><h2 id="一-Queryset特性及高级查询技巧"><a href="#一-Queryset特性及高级查询技巧" class="headerlink" title="一.Queryset特性及高级查询技巧"></a>一.Queryset特性及高级查询技巧</h2><blockquote>
<p>前言：对中大型网站或Web app而言，最影响网站性能的就是数据库查询部分了。一是因为反复从数据库中读写数据很消耗时间和计算资源。二是当返回的查询数据集queryset非常大时还会占据很多的内存。本章将介绍Django下数据库接口QuerySet特性和使用技巧。</p>
</blockquote>
<h3 id="1-QuerySet"><a href="#1-QuerySet" class="headerlink" title="1.QuerySet"></a>1.QuerySet</h3><p>&emsp;&emsp;QuerySet是Django提供的强大的数据库接口(API)，通过它，我们才得以使用<code>filter</code>,<code>exclude</code>, <code>get</code>等方法进行数据库查询，而不需要使用原始的SQL语句与数据库进行交互。从数据库中取出来的结果一般是一个集合，这个集合就被称作是queryset</p>
<h3 id="2-QuerySet的惰性"><a href="#2-QuerySet的惰性" class="headerlink" title="2.QuerySet的惰性"></a>2.QuerySet的惰性</h3><p>&emsp;&emsp;Django的QuerySet是惰性的，下例中的<code>article_list</code>试图从数据库查询一个标题含有Django字段的全部文章列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article_list &#x3D; Article.objects.filter(title_contains&#x3D;&quot;django&quot;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是在定义<code>article_list</code>的时候，数据库没有执行任何查询操作。只有当我们需要对<code>article_list</code>做进一步运算时，Django才会执行相应的数据库查询。</br><br>&emsp;&emsp;这样的惰性是为了减少针对数据库的无效错误，比如查询了结果而不用是对计算资源很大的浪费。</p>
<h3 id="3-QuerySet自带缓存"><a href="#3-QuerySet自带缓存" class="headerlink" title="3.QuerySet自带缓存"></a>3.QuerySet自带缓存</h3><p>&emsp;&emsp;当遍历<code>article_list</code>时，所有匹配的记录会从数据库中获取。这些结果会载入内存并保存在queryset的内置cache中，这样如果需要再次遍历或读取这个<code>article_list</code>，Django无需进行重复查询操作，这样减少了对数据库的查询操作，可以大大节省时间</p>
<h3 id="4-统计查询结果数量优选count方法"><a href="#4-统计查询结果数量优选count方法" class="headerlink" title="4.统计查询结果数量优选count方法"></a>4.统计查询结果数量优选count方法</h3><p>len()与count()均能统计查询结果的数量。一般来说count更快，因为它时从数据库层面直接获取查询结果的数量，而非返回整个数据集。而len()导致了queryset的执行，需要整个queryset载入内存后才能统计其长度。当然如果queryset已经在缓存里了，使用len更快，因为无需再次和数据库打交道。</p>
<h3 id="5-批量创建或更新数据请用bulk-create或bulk-update"><a href="#5-批量创建或更新数据请用bulk-create或bulk-update" class="headerlink" title="5.批量创建或更新数据请用bulk_create或bulk_update"></a>5.批量创建或更新数据请用bulk_create或bulk_update</h3><p>&emsp;&emsp;在Django中向数据库中插入或更新多条数据时，使用save或create方法保存一条就会执行一次SQL语句。而Django自带的<code>bulk_create</code>和<code>bulk_update</code>方法可以一次SQL添加或更新多条数据，效率会高很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 内存生成多个对象实例</span><br><span class="line">articles  &#x3D; [Article(title&#x3D;&quot;title1&quot;, body&#x3D;&quot;body1&quot;), Article(title&#x3D;&quot;title2&quot;, body&#x3D;&quot;body2&quot;), Article(title&#x3D;&quot;title3&quot;, body&#x3D;&quot;body3&quot;)]</span><br><span class="line"></span><br><span class="line"># 执行一次SQL插入数据</span><br><span class="line">Article.objects.bulk_create(articles)</span><br></pre></td></tr></table></figure>
<h3 id="6-专业地使用explain方法"><a href="#6-专业地使用explain方法" class="headerlink" title="6.专业地使用explain方法"></a>6.专业地使用explain方法</h3><p>Django 2.1中QuerySet新增了explain方法，可以统计一个查询所消耗的时间，这可以帮助程序员分析和优化查询结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(Blog.objects.filter(title&#x3D;&#39;My Blog&#39;).explain(verbose&#x3D;True))</span><br><span class="line"></span><br><span class="line">#output</span><br><span class="line">Seq Scan on public.blog  (cost&#x3D;0.00..35.50 rows&#x3D;10 width&#x3D;12) (actual time&#x3D;0.004..0.004 rows&#x3D;10 loops&#x3D;1)</span><br><span class="line">  Output: id, title</span><br><span class="line">  Filter: (blog.title &#x3D; &#39;My Blog&#39;::bpchar)</span><br><span class="line">Planning time: 0.064 ms</span><br><span class="line">Execution time: 0.058 ms</span><br></pre></td></tr></table></figure>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>Django QuerySet的惰性和缓存特性对于减少数据库访问次数非常有用。实际开发时，需要根据不同的应用场景选择合适的方法来减少数据库的访问，减少查询结果占用的内存空间从而提升网站的性能。</p>
<h2 id="二-Django多种缓存配置方式"><a href="#二-Django多种缓存配置方式" class="headerlink" title="二.Django多种缓存配置方式"></a>二.Django多种缓存配置方式</h2><blockquote>
<p>缓存(Cache)对于创建一个高性能的网站和提升用户体验来说是至关重要的。这一部分我们将介绍缓存Cache应用场景及工作原理，并详细介绍如何在Django中设置缓存Cache并使用它们。</p>
</blockquote>
<h3 id="1-缓存Cache"><a href="#1-缓存Cache" class="headerlink" title="1.缓存Cache"></a>1.缓存Cache</h3><p>&emsp;&emsp;对于中大型网站而言，使用缓存减少对数据库的访问次数是提升网站性能的关键之一。</br><br>&emsp;&emsp;Django使用缓存Cache的原因：<br>当用户请求到达Django的视图后，视图会从数据库中读取数据传递给模板进行渲染，返回给用户看到的网页。但如果用户每次请求都从数据库读取数据并进行渲染，将极大降低性能，不仅服务器压力大，而且客户端也无法及时获得响应。如果能将<b>数据库中读取的数据</b>或<b>动态生成网页</b>放到速度更快的缓存中，每次有请求过来，先检查缓存中是否有对应的资源。如果有，直接从缓存中取出来返回响应，节省读取数据和渲染数据的时间，不仅能大大提高系统性能，还能提高用户体验。</p>
<h3 id="2-Django缓存设置"><a href="#2-Django缓存设置" class="headerlink" title="2.Django缓存设置"></a>2.Django缓存设置</h3><p>Django中提供了多种缓存方式，如果要使用缓存，需要在<code>settings.py</code>文件中进行设置，然后应用。根据缓存介质的不同，需要设置不同的缓存后台Backend。在生产环境中最常使用的缓存是Memcached和Redis。在开发环境中可以使用本地内存缓存进行测试。</p>
<h4 id="2-1-Memcached缓存"><a href="#2-1-Memcached缓存" class="headerlink" title="2.1 Memcached缓存"></a>2.1 Memcached缓存</h4><p>Memcached是一个高性能的分布式内存对象缓存系统。是Django原生支持的最快最有效的缓存系统。Memcached的优点是速度快、属于分布式缓存，支持同时在多台服务器上运行，缺点是不支持数据持久化，服务器重启之后缓存数据就没了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 本地缓存，使用localhost</span><br><span class="line">CACHES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.core.cache.backends.memcached.MemcachedCache&#39;,</span><br><span class="line">        &#39;LOCATION&#39;: &#39;127.0.0.1:11211&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用unix soket通信</span><br><span class="line">CACHES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.core.cache.backends.memcached.MemcachedCache&#39;,</span><br><span class="line">        &#39;LOCATION&#39;: &#39;unix:&#x2F;tmp&#x2F;memcached.sock&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"># 分布式缓存，多台服务器，支持配置权重。</span><br><span class="line">CACHES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.core.cache.backends.memcached.MemcachedCache&#39;,</span><br><span class="line">        &#39;LOCATION&#39;: [</span><br><span class="line">            &#39;172.19.26.240:11211&#39;,</span><br><span class="line">            &#39;172.19.26.242:11211&#39;,</span><br><span class="line">        ]</span><br><span class="line">        # 我们也可以给缓存机器加权重，权重高的承担更多的请求，如下：</span><br><span class="line">        &#39;LOCATION&#39;: [</span><br><span class="line">            (&#39;172.19.26.240:11211&#39;,5),</span><br><span class="line">            (&#39;172.19.26.242:11211&#39;,1),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-Redis缓存"><a href="#2-2-Redis缓存" class="headerlink" title="2.2 Redis缓存"></a>2.2 Redis缓存</h4><p>Redis 是当今速度最快的内存型非关系型（NoSQL）型数据库。Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等多种数据结构的存储。与memcached相比，Redis不仅支持支持缓存数据在硬盘上的持久化，还支持master-slave模式的数据备份，有明显的优点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHES &#x3D; &#123;</span><br><span class="line">    </span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django_redis.cache.RedisCache&#39;,</span><br><span class="line">        &#39;LOCATION&#39;: &#39;redis:&#x2F;&#x2F;your_host_ip:6379&#39;, # redis所在服务器或容器ip地址</span><br><span class="line">        &quot;OPTIONS&quot;: &#123;</span><br><span class="line">            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,</span><br><span class="line">             &quot;PASSWORD&quot;: &quot;your_pwd&quot;, # 你设置的密码</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以在<code>settings.py</code>设置缓存默认过期时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REDIS_TIMEOUT&#x3D;24*60*60</span><br><span class="line">CUBES_REDIS_TIMEOUT&#x3D;60*30</span><br><span class="line">NEVER_REDIS_TIMEOUT&#x3D;365*24*60*60</span><br></pre></td></tr></table></figure>
<h3 id="3-Django权限分配"><a href="#3-Django权限分配" class="headerlink" title="3.Django权限分配"></a>3.Django权限分配</h3><h4 id="3-1-新增自定义权限"><a href="#3-1-新增自定义权限" class="headerlink" title="3.1 新增自定义权限"></a>3.1 新增自定义权限</h4><p>有时django自带的四种权限(增、删、改、查)满足不了设计的目的，这时候需要自定义权限，实现方式有以下两种：</p>
<h5 id="1-在Model的meta属性中添加权限"><a href="#1-在Model的meta属性中添加权限" class="headerlink" title="1-在Model的meta属性中添加权限"></a>1-在Model的meta属性中添加权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Article(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    class Meta:</span><br><span class="line">        permission &#x3D; (</span><br><span class="line">            (&#39;publish_artcile&#39;, &quot;Can publish aryicle&quot;)</span><br><span class="line">            (&#39;comment_article&#39;, &quot;Can comment article&quot;)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h5 id="2-使用ContentType程序化创建权限"><a href="#2-使用ContentType程序化创建权限" class="headerlink" title="2-使用ContentType程序化创建权限"></a>2-使用ContentType程序化创建权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from blog.model import Article</span><br><span class="line">from django.contrib.auth.models import Permission</span><br><span class="line">from django.contrib.contentypes.models import ContentType</span><br><span class="line"></span><br><span class="line">content_type &#x3D; ContentType.objects.get_for_model(article)</span><br><span class="line">permission1 &#x3D; Permission.objects.create(</span><br><span class="line">    codename &#x3D; &quot;publish_article&quot;,</span><br><span class="line">    name&#x3D; &#39;CAn publish articles&#39;,</span><br><span class="line">    content_type &#x3D; content_type,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">permission2 &#x3D; Permission.objects.create(</span><br><span class="line">    codename &#x3D; &#39;comment_article&#39;,</span><br><span class="line">    name &#x3D; &#39;Can comment article&#39;</span><br><span class="line">    content_type &#x3D; content_type,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="3-2-注意权限的缓存机制"><a href="#3-2-注意权限的缓存机制" class="headerlink" title="3.2 注意权限的缓存机制"></a>3.2 注意权限的缓存机制</h4><p>Django会缓存每个用户对象，包括其权限<code>user_permissions</code>。当我们在代码中手动改变一个用户的权限后，必须重新获取该用户对象，才能获取最新的权限</p>
<h4 id="3-3-用户权限的验证"><a href="#3-3-用户权限的验证" class="headerlink" title="3.3 用户权限的验证"></a>3.3 用户权限的验证</h4><p>我们在分配好权限后，还需要在视图<code>views.py</code>和模板里验证用户是否具有相应的权限。</br><br>在视图中一个很好的加权限的方法是使用<code>@permission_required</code>这个装饰器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission_required(perm, login_url&#x3D;None, raise_exception&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>如果在这里指定了<code>login_url</code>，用户被要求先进行登录，如果设置了<code>raise_exception=True</code>，会直接返回403无权限的错误。使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.decorators import permission_required</span><br><span class="line"></span><br><span class="line">@permission_required(&#39;polls.can_vote&#39;)</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如果使用基于类的视图， 而不是函数视图，需要混入<code>PermissionRequiredMixin</code>这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth.mixins import PermissionRequiredMixxin</span><br><span class="line"></span><br><span class="line">class MyView(PermissionRequiredMixin, View):</span><br><span class="line">    permission_required &#x3D; &#39;polls.can_vote&#39;</span><br><span class="line">    # Or multiple of permissions:</span><br><span class="line">    permission_required &#x3D; (&#39;polls.can_open&#39;, &#39;polls.can_edit&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-用户组"><a href="#3-4-用户组" class="headerlink" title="3.4 用户组"></a>3.4 用户组</h4><p>&emsp;&emsp;用户组(Group)和User是多对多关系。其作用在权限控制时可以批量对用户的权限进行管理和分配。当一个用户加入到一个Group中后，该User就拥有了该Group分配的所有权限。例如，如果一个用户组<code>editors</code>有权限<code>change_article</code>，那么所有属于editors组的用户都会拥有这个权限。</br><br>&emsp;&emsp;将用户添加到用户组或者给用户组添加权限，一般建议直接通过django admin进行。如果希望手动给group添加或删除权限，可以使用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mygroup.permissions &#x3D; [permission_list]</span><br><span class="line">mygroup.permissions.add(permission1, permission2, ...)</span><br><span class="line">mygroup&#x2F;permissions.remove(permission1, permission2, ...)</span><br><span class="line">mygroup.permissions.clear()</span><br></pre></td></tr></table></figure>
<h3 id="4-Django中间件原理及示例"><a href="#4-Django中间件原理及示例" class="headerlink" title="4.Django中间件原理及示例"></a>4.Django中间件原理及示例</h3><blockquote>
<p>中间件(middleware)允许您在一个浏览器请求在到达Django视图之前处理它，以及在视图返回的响应到达浏览器之前处理这个响应。</p>
</blockquote>
<p>中间件(middleware)是一个镶嵌到Django的request(请求)/request(响应)处理机制中的一个钩子(hooks)框架，它是一个可以修改Django全局输入或输出的一个底层插件系统。</br><br>中间件常用于权限校验，限制用户请求、打印日志、改变输出内容等多种应用场景，比如：</p>
<ul>
<li>禁止特定ip地址的用户或未登录的用户访问我们的View视图函数。</li>
<li>对同一ip地址单位时间内发送的请求数量做出限制</li>
<li>在View视图函数执行前传递额外的变量或参数。</li>
<li>在View视图函数执行前或执行后把特定信息打印到log日志</li>
<li>在View视图函数执行后对response数据进行修改后返回给用户。 <h4 id="4-1Django自带中间件"><a href="#4-1Django自带中间件" class="headerlink" title="4.1Django自带中间件"></a>4.1Django自带中间件</h4>django的<code>settings.py</code>里的<code>MIDDLEWARE</code>列表已经注册了一些Django自带的中间件，每个中间件都负责一些特定的功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    &#39;django.middleware.security.SecurityMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
每个中间件的功能如下：</li>
<li><code>SecurityMiddleware</code>：为request/response提供了几种安全改进</li>
<li><code>SessionMiddleware</code>：开启session会话支持</li>
<li><code>CommonMiddleware</code>：基于APPEND_SLASH和PREPEND_WWW的设置来重写URL，如果APPEND_SLASH设为True，并且初始URL 没有以斜线结尾以及在URLconf 中没找到对应定义，这时形成一个斜线结尾的新URL；</li>
<li><code>CsrfViewMiddleware</code>：添加跨站点请求伪造的保护，通过向POST表单添加一个隐藏的表单字段，并检查请求中是否有正确的值。</li>
<li><code>AuthenticationMiddleware</code>：在视图函数执行前向每个接收到的user对象添加HttpRequest属性，表示当前登录的用户，无它用不了request.user</li>
<li><code>MessageMiddleware</code>：开启基于Cookie和会话的消息支持。</li>
<li><code>XFrameOptionMiddleware</code>:对点击劫持的保护<h2 id="二-Django权限详解"><a href="#二-Django权限详解" class="headerlink" title="二.Django权限详解"></a>二.Django权限详解</h2><blockquote>
<p>前言：Django实际使用场景下，常常需要对用户的权限进行管理和控制。Django自带的权限机制(permissions)与用户组(group)可以让我们很方便地对用户权限进行管理。在这一部分将介绍使用<code>Django-guardian</code>实现对象级别的权限管理</p>
</blockquote>
<h3 id="1-Django-Admin中的权限分配"><a href="#1-Django-Admin中的权限分配" class="headerlink" title="1.Django Admin中的权限分配"></a>1.Django Admin中的权限分配</h3>&emsp;&emsp;Django中的用户权限分配，主要通过Django自带的Admin界面进行维护的。Django的权限permission本质是<code>django.contrib.auth</code>中的一个模型，其与User的<code>user_permissions</code>字段是多对多的关系。当我们在<code>INSTALLED_APP</code>里添加好auth应用之后，Django就会为每一个你安装的app中的模型(Model)自动创建4个可选的权限：view, add, change和delete。在Django Admin后台中我们可以将这些权限分配给不同的用户。<h4 id="1-1-查看用户的权限"><a href="#1-1-查看用户的权限" class="headerlink" title="1.1.查看用户的权限"></a>1.1.查看用户的权限</h4>&emsp;&emsp;权限名一般由app名(app label)，权限动作和模型名组成。以blog应用为例，Django为Article模型自动创建的4个可选权限名分别为：</li>
<li>查看文章(view)： blog.view_article</li>
<li>创建文章(add): blog.add_article</li>
<li>更改文章(change): blog.change_article</li>
<li>删除文章(delete): blog.delete_article<br>在前例中，我们已经通过Admin给用户A(user_A)分配了创建文章和修改文章的权限，现在通过以下命令来查询用户是否已经拥有相应权限：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_A.has_perm(&#39;blog.add_article&#39;)</span><br><span class="line">user_A.has_perm(&#39;blog.change_article&#39;)</span><br></pre></td></tr></table></figure>
两行代码都应该返回True。</br><br>&emsp;&emsp;如果我们要查看某个用户所在用户组的权限或某个用户的所有权限(包括从用户组获得的权限)，我们可以使用<code>get_group_permissions()</code>和<code>get_all_permissions()</code>方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_A.get_group_permissions()</span><br><span class="line">user_A.get_all_permissions()</span><br></pre></td></tr></table></figure>
<h4 id="2-新增自定义权限"><a href="#2-新增自定义权限" class="headerlink" title="2.新增自定义权限"></a>2.新增自定义权限</h4>有时django创建的4种可选权限满足不了我们的需要，这时需要进行自定义权限。<h5 id="2-1-方法1：在Model的meta属性中添加权限"><a href="#2-1-方法1：在Model的meta属性中添加权限" class="headerlink" title="2.1 方法1：在Model的meta属性中添加权限"></a>2.1 方法1：在Model的meta属性中添加权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Article(model.Model):</span><br><span class="line">    ...</span><br><span class="line">    class Meta:</span><br><span class="line">        permisions &#x3D; (</span><br><span class="line">            (&#39;publish_article&#39;, &quot;Can publish article&quot;),</span><br><span class="line">            (&#39;comment_article&#39;, &quot;Can comment article&quot;),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h5 id="2-2-方法2：使用ContentType程序化创建权限"><a href="#2-2-方法2：使用ContentType程序化创建权限" class="headerlink" title="2.2. 方法2：使用ContentType程序化创建权限"></a>2.2. 方法2：使用ContentType程序化创建权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from blog.models import Article</span><br><span class="line">from django.contrib.auth.models import Permission</span><br><span class="line">from django.contrib.contenttypes.models import ContentType</span><br><span class="line"></span><br><span class="line">content_type &#x3D; ContentType.objects.get_for_model(article)</span><br><span class="line">permission1 &#x3D; Permission.objetcs.create(</span><br><span class="line">    codename&#x3D;&#39;publish_article&#39;,</span><br><span class="line">    name &#x3D; &#39;Cna publish articles&#39;,</span><br><span class="line">    content_type&#x3D;content_type,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">permission1 &#x3D; Permission.objetcs.create(</span><br><span class="line">    codename&#x3D;&#39;comment_article&#39;,</span><br><span class="line">    name &#x3D; &#39;Cna comment articles&#39;,</span><br><span class="line">    content_type&#x3D;content_type,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
当使用<code>python manage.py migrate</code>命令后，Django Admin的<code>user permissions</code>栏又多了两个可选项。</br><br>当然了，还可以通过代码手动给用户分配权限<h5 id="1-使用user-permissions-add方法增加权限"><a href="#1-使用user-permissions-add方法增加权限" class="headerlink" title="(1)使用user_permissions.add方法增加权限"></a>(1)使用user_permissions.add方法增加权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myuser.user_permissions.add(permission1, permission2, ...)</span><br></pre></td></tr></table></figure>
<h5 id="2-通过用户组-group-给用户增加权限"><a href="#2-通过用户组-group-给用户增加权限" class="headerlink" title="(2)通过用户组(group)给用户增加权限"></a>(2)通过用户组(group)给用户增加权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mygroup.permissions.add(permission1, permission2, ...)</span><br></pre></td></tr></table></figure>
<h5 id="3-通过remove或者clear方法移除权限"><a href="#3-通过remove或者clear方法移除权限" class="headerlink" title="(3)通过remove或者clear方法移除权限"></a>(3)通过remove或者clear方法移除权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myuser.user_permissions.remove(permissions1, permission2, ...)</span><br><span class="line">myuser.user_permissions.clear()</span><br></pre></td></tr></table></figure>
<h5 id="2-3-注意权限的缓存机制"><a href="#2-3-注意权限的缓存机制" class="headerlink" title="2.3 注意权限的缓存机制"></a>2.3 注意权限的缓存机制</h5>Django会缓存每个用户对象，包括其权限<code>user_permissions</code>。当我们在代码中手动改变一个用户的权限后，你必须重新获取该用户对象，才能获取最新的权限，比如下例在代码中给用户手动增加了<code>change_blogpost</code>的权限，如果不重新载入用户，那么将显示用户还是没有<code>change_blogpost</code>的权限<h4 id="3-用户权限的验证"><a href="#3-用户权限的验证" class="headerlink" title="3.用户权限的验证"></a>3.用户权限的验证</h4><blockquote>
<p>我们需要在视图views.py和模板里验证用户是否具有相应的权限</p>
</blockquote>
<h5 id="3-1视图中验证"><a href="#3-1视图中验证" class="headerlink" title="3.1视图中验证"></a>3.1视图中验证</h5>在视图中我们当然可以使用<code>user.has_perm</code>方法对一个用户的权限进行直接验证。当然一个更好的方法是使用<code>@permission_required</code>这个装饰器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission_required(perm, login_url&#x3D;None, raise_exception&#x3D;False)</span><br></pre></td></tr></table></figure>
如果我们指定了<code>login_url</code>，用户会被要求先登录。如果你设置了<code>raise_exception=True</code>，会直接返回403无权限的错误。具体使用方法如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth.decorators import permission_required</span><br><span class="line"></span><br><span class="line">@permission_required(&#39;polls.can_vote&#39;)</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
当然了，如果我们使用基于类的视图(Class Based View)，而不是函数视图，则需要混入<code>PermissionRequiredMixin</code>这个类或使用<code>method_decorator</code>装饰器，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth.mixin import PermissionRequiredMixin</span><br><span class="line"></span><br><span class="line">class MyView(PermissionRequiredMixin, view):</span><br><span class="line">    permission_required &#x3D; &#39;polls.can_vote&#39;</span><br><span class="line"></span><br><span class="line">from django.utils.decorators import method_decorator</span><br><span class="line">from django.core.urlresolvers import reverse_lazy</span><br><span class="line">from django.contrib.auth.decorators import user_passes_test</span><br><span class="line"></span><br><span class="line">@method_decorator(user_passes_test(lambda u: Group.objects.get(name&#x3D;&#39;admin&#39;) in u.groups.all()), name&#x3D;&#39;dispatch&#39;)</span><br><span class="line">class ItemDelete(DeleteView):</span><br><span class="line">    model&#x3D;Item</span><br><span class="line">    success_url &#x3D; reverse_lazy(&#39;items:index&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="2-Django自带的权限机制的不足"><a href="#2-Django自带的权限机制的不足" class="headerlink" title="2.Django自带的权限机制的不足"></a>2.Django自带的权限机制的不足</h3><blockquote>
<p>Django自带的权限机制是针对模型的，如果一个用户对Article模型有change的权限。那么该用户获得对所有文章对象进行修改的权限。如果我们希望实现对单个文章对象的权限管理，我们需要借助第三方库<code>django-guardian</code></p>
</blockquote>
<h4 id="2-1-Django-guardian的使用"><a href="#2-1-Django-guardian的使用" class="headerlink" title="2.1 Django-guardian的使用"></a>2.1 Django-guardian的使用</h4>使用pip进行基础安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-guardian</span><br></pre></td></tr></table></figure>
安装完成后，我们可以将<code>django-guardian</code>加入到我们的项目中。首先在<code>settings</code>里将guardian加到<code>INSTALLED_APPS</code>，同时加入身份验证后端的<code>AUTHENTICATION_BAKENDS</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; (</span><br><span class="line">   # ...</span><br><span class="line">   &#39;guardian&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
以及<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AUTHENTICATION_BACKENDS &#x3D; (</span><br><span class="line">    &#39;django.contrib.auth.bakends.ModelBackend&#39;,</span><br><span class="line">    &#39;guardian.backends.ObjectPermissionBackend&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
一旦我们将<code>django-guardian</code>配置进项目，调用migrate命令会生成一个匿名用户的实例，在数据库中也会创建相应的条目。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.user.is_anonymous &#x3D; True</span><br></pre></td></tr></table></figure>
<h4 id="2-2-权限分配"><a href="#2-2-权限分配" class="headerlink" title="2.2 权限分配"></a>2.2 权限分配</h4>如下task模型，我们自定义了一条<code>assign_task</code>的权限：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Task(model.Model):</span><br><span class="line">    summary &#x3D; model.CharField(max_length&#x3D;32)</span><br><span class="line">    content &#x3D; model.TextField()</span><br><span class="line">    reported_by &#x3D; models.ForeignKey(User, on_delete&#x3D;models.CASCADE)</span><br><span class="line">    created_at &#x3D; models.DateTimeField(auto_now_add&#x3D;True)</span><br><span class="line">    </span><br><span class="line">    class Meta:</span><br><span class="line">        permissions &#x3D; (</span><br><span class="line">            (&#39;assign_task&#39;, &#39;Assign task&#39;),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
为用户分配权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">&gt;&gt;&gt; from django.contrib.auth.models import User</span><br><span class="line">&gt;&gt;&gt; boss &#x3D; User.objects.create(username&#x3D;&#39;boss&#39;)</span><br><span class="line">&gt;&gt;&gt; joe &#x3D; User.objects.create(username&#x3D;&#39;joe&#39;)</span><br><span class="line">&gt;&gt;&gt; task &#x3D; Task.objects.create(summary&#x3D;&#39;Some job&#39;, content&#x3D;&#39;&#39;, reported_by&#x3D;boss)</span><br><span class="line">&gt;&gt;&gt; joe.has_perm(&#39;assign_task&#39;, task)</span><br><span class="line"></span><br><span class="line"># 使用guardian的assign_perm方法新增tasks对象的权限</span><br><span class="line">&gt;&gt;&gt; from guardian.shortcuts import assign_perm</span><br><span class="line">&gt;&gt;&gt; assign_perm(&#39;assign_task&#39;, joe, task)</span><br><span class="line">&gt;&gt;&gt; joe.has_perm(&#39;assign_task&#39;, task)</span><br></pre></td></tr></table></figure>
为用户组分配权限，同样使用<code>assign_perm</code>方法即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.contrib.auth.models import Group</span><br><span class="line">&gt;&gt;&gt; group &#x3D; Group.objects.create(name&#x3D;&#39;employees&#39;)</span><br><span class="line">&gt;&gt;&gt; assign_perm(&#39;change_task&#39;, group, task)</span><br><span class="line">&gt;&gt;&gt; joe.has_perm(&#39;change_task&#39;, task)</span><br><span class="line"># well, joe is not yet within an employee&#39;s group</span><br><span class="line">&gt;&gt;&gt; joe.groups.add(group)</span><br><span class="line">&gt;&gt;&gt; joe.has_perm(&#39;change_task&#39;, task)</span><br></pre></td></tr></table></figure>
删除权限：使用<code>remove_perm</code>方法即可删除一个用户或用户组的权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from guardian.shortcuts import remove_perm</span><br><span class="line">&gt;&gt;&gt; remove_perm(&#39;change_site&#39;, joe, site)</span><br><span class="line">&gt;&gt;&gt; joe&#x3D;User.objects.get(username&#x3D;&#39;joe&#39;)</span><br><span class="line">&gt;&gt;&gt; joe.has_perm(&#39;change_site&#39;, site)</span><br></pre></td></tr></table></figure>
权限验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 分配对象权限前</span><br><span class="line">&gt;&gt;&gt; site &#x3D; Site.objects.get_current()</span><br><span class="line">&gt;&gt;&gt; joe.has_perm(&#39;sites.change_site&#39;, site)</span><br><span class="line"></span><br><span class="line"># 分配对象权限后</span><br><span class="line">&gt;&gt;&gt; from guardian.shortcuts import assign_perm</span><br><span class="line">&gt;&gt;&gt; assign_perm(&#39;sites.change_site&#39;, joe, site)</span><br><span class="line">&lt;UserObjectPermission: example.com | joe | change_site&gt;</span><br></pre></td></tr></table></figure>
GET_OBJECTS_FOR_USER方法,该方法可以获取用户具有权限操作的对象列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from guardian.shortcuts import get_objects_for_user</span><br><span class="line"></span><br><span class="line">def user_dashboard(request, template_name&#x3D;&#39;projects&#x2F;dashboard.html&#39;):</span><br><span class="line">    projects &#x3D; get_objects_for_user(request.user, &#39;projects.view_project&#39;)</span><br></pre></td></tr></table></figure>
OBJECTPERMISSIONCHECKER,该方法可以缓存用户对一个对象的全部权限，减少数据库查询次数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from guardian.core import ObjectPermissionChecker</span><br><span class="line">&gt;&gt;&gt; checker &#x3D; ObjectPermissionChecker(joe) # 检查joe的对象权限并缓存</span><br><span class="line">&gt;&gt;&gt; checker.has_perm(&#39;change_site&#39;, site)</span><br><span class="line"># 在缓存中查询，无需再次读取数据库</span><br><span class="line">&gt;&gt;&gt; checker.has_perm(&#39;add_site&#39;, site)</span><br></pre></td></tr></table></figure>
使用标准的<code>permission_required</code>的装饰器不能用来检查对象权限，guardian提供了自己的装饰器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from guardian.decorators import permission_required_or_403</span><br><span class="line">&gt;&gt;&gt; from django.http import HttpResponse</span><br><span class="line">&gt;&gt;&gt; @permission_required_or_403(&#39;auth.change_group&#39;,</span><br><span class="line">&gt;&gt;&gt;     (Group, &#39;name&#39;, &#39;group_name&#39;))</span><br><span class="line">&gt;&gt;&gt; def edit_group(request, group_name):</span><br><span class="line">&gt;&gt;&gt;     return HttpResponse(&#39;some form&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="三-中间件原理及示例"><a href="#三-中间件原理及示例" class="headerlink" title="三.中间件原理及示例"></a>三.中间件原理及示例</h3><blockquote>
<p>前言：中间件(middleware)允许在一个浏览器的请求在到达Django视图之前处理它，以及在视图返回的响应到达浏览器之前处理这个响应。这部分分析Django中间件的工作原理和应用场景，介绍如何自定义中间件并提供一些示例。</p>
</blockquote>
<h4 id="1-中间件及其应用场景"><a href="#1-中间件及其应用场景" class="headerlink" title="1.中间件及其应用场景"></a>1.中间件及其应用场景</h4><blockquote>
<p>中间件(middleware)是一个镶嵌到Django的request(请求)/response(响应)处理机制中的一个钩子(hooks)框架，它是一个可以修改Django全局输入或输出的一个底层插件系统。</br><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;–Django官网中对于中间件的介绍</p>
</blockquote>
</li>
</ul>
<h5 id="1-1-Django的request-response处理机制"><a href="#1-1-Django的request-response处理机制" class="headerlink" title="1.1 Django的request/response处理机制"></a>1.1 Django的request/response处理机制</h5><p>&emsp;&emsp;HTTP Web服务器工作原理一般是接收用户发来的请求(request)，然后给出响应(response)。Django的工作原理一般是接收request请求及其参数，交由视图(View)处理。然后给出它的响应(response)：渲染过的html文件或者json格式的数据。在实际工作过程中，Django并不是接收到request对象之后就马上交给视图函数或者类处理，也不是在view执行后立马把response返回给用户。一个请求在到达视图View处理前需要先经过一层层的中间件处理，经过View处理后的响应也要经过一层层的中间件处理才能返回给用户。<br>&emsp;&emsp;中间件(Middleware)在整个Django的request/response处理机制中的角色如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest -&gt; Middleware -&gt; View -&gt; Middleware -&gt; HttpResponse</span><br></pre></td></tr></table></figure>
<p>中间件常用于权限校验，限制用户请求、打印日志、改变输出内容等多种应用场景，比如：</p>
<ul>
<li>禁止特定IP地址的用户或未登录的用户访问我们的View视图函数</li>
<li>对同一IP地址单位时间内发送的请求数量做出限制</li>
<li>在View视图函数执行前或执行后把特定信息打印到log日志</li>
<li>在View视图函数执行后对reponse数据进行修改后返回给用户</li>
</ul>
<p>注意：装饰器也常用于用户校验，但与装饰器不同，中间件对Django的输入或输出的改变是全局的。装饰器比如<code>@login_required</code>仅作用于单个视图函数。如果我们希望全站只有登录用户才能访问，中间件会是一个更好的选择。</p>
<h5 id="1-2-Django自带中间件"><a href="#1-2-Django自带中间件" class="headerlink" title="1.2 Django自带中间件"></a>1.2 Django自带中间件</h5><p>当创建一个新的Django项目时，<code>settings.py</code>里的<code>MIDDLEWARE</code>列表已经注册了一些Django自带的中间件，每个中间件都负责特定的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    &#39;django.middleware.security.SecurityMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionMiddleware&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>每个中间件的功能如下，我们都建议保留：</p>
<ul>
<li><code>SecurityMiddleware</code>：为request/response提供了几种安全改进。</li>
<li><code>SessionMiddleware</code>：开启session会话支持</li>
<li><code>CommonMiddleware</code>：基于APPEND_SLASH和PREPEND_WWW的设置来重写URL，如果APPEND_SLASH设为True，并且初始URL没有以斜线结尾以及在URLconf中没找到对应定义，这时形成一个斜线结尾的新URL；</li>
<li><code>CsrfViewMiddleware</code>：添加跨站点请求伪造的保护，通过向POST表单添加一个隐藏的表单字段，并检查请求中是否有正确的值。</li>
<li><code>AuthenticationMiddleware</code>：在视图函数执行前向每个接收到的user对象添加HttpRequest属性，表示当前登录的用户，无它登录不了<code>request.user</code>。</li>
<li><code>MessageMiddleware</code>：开启基于Cookie和会话的消息支持</li>
<li><code>XFrameOptionMiddleware</code>：对点击劫持的保护</li>
</ul>
<p>除此之外，Django还提供了压缩网站内容的<code>GZipMiddleware</code>，根据用户请求语言返回不同内容的<code>LocaleMiddleware</code>和给GET请求附加条件的<code>ConditionalGetMiddleware</code>。这些中间件都是可选的。</p>
<h4 id="2-自定义中间件"><a href="#2-自定义中间件" class="headerlink" title="2.自定义中间件"></a>2.自定义中间件</h4><p>自定义中间件我们首先需要在app所属目录下新建一个文件<code>middleware.py</code>，在文件中添加编写好的中间件代码。然后在项目<code>settings.py</code>中把它添加到<code>MIDDLEWARE</code>列表进行注册，添加时务必注意顺序。<br>Django提供了两种编写自定义中间件的方式：函数和类，基本框架如下所示：<br>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def simple_middleware(get_response):</span><br><span class="line">    # 一次性设置和初始化</span><br><span class="line">    def middleware(request):</span><br><span class="line">        # 请求在到达视图前的执行代码</span><br><span class="line">        response &#x3D; get_response(request)</span><br><span class="line">        # 请求在返回给客户端前执行的代码</span><br><span class="line">        return response</span><br><span class="line">    return middleware</span><br></pre></td></tr></table></figure>
<p>当请求从浏览器发送到服务器视图时，将执行<code>response=get_response(request)</code>该行之前的所有代码。当响应从服务器返回到浏览器时，将执行<code>response=get_response(request)</code>此行之后的所有内容。</br><br>分界线<code>response=get_response(request)</code>，它的功能将调用列表中的下一个中间件，如果这是最后一个中间件，则将调用该视图。</p>
<h5 id="2-1-示例1"><a href="#2-1-示例1" class="headerlink" title="2.1 示例1"></a>2.1 示例1</h5><p>我们现在以函数编写一个名为<code>timeit_middleware</code>的中间件，打印出执行每个请求所花费的时间，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timeit_middleware(get_response):</span><br><span class="line">    def middleware(request):</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        response &#x3D; get_response(request)</span><br><span class="line">        end &#x3D; time.time()</span><br><span class="line">        print(&#39;请求花费时间：&#123;&#125;&#39;.format(end-start))</span><br><span class="line">        return response</span><br><span class="line">    </span><br><span class="line">    return middleware</span><br></pre></td></tr></table></figure>
<p>在<code>settings.py</code>中注册该中间件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    &#39;blog.middleware.timeit_middleware&#39;, # add new</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>使用类的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class SimpleMiddleware:</span><br><span class="line">    def __init__(self, get_response):</span><br><span class="line">        # 一次性设置和初始化</span><br><span class="line">        self.get_response &#x3D; get_response(request)</span><br><span class="line">        </span><br><span class="line">    def __call__(self, request):</span><br><span class="line">        # 视图函数执行前的代码</span><br><span class="line">        response &#x3D; self.get_reponse(request)</span><br><span class="line">        # 视图函数执行侯的代码</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure>
<h5 id="2-2-示例2"><a href="#2-2-示例2" class="headerlink" title="2.2 示例2"></a>2.2 示例2</h5><p>现在用类编写一个名为<code>LoginRequiredMiddleware</code>的中间件，实现全站要求登录，但是登录页面和开放白名单上的urls除外，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import redirect</span><br><span class="line">form django.conf import settings</span><br><span class="line"></span><br><span class="line">class LoginRequiredMiddleware:</span><br><span class="line">    def __init__(self, get_response):</span><br><span class="line">        self.get_response &#x3D; get_response</span><br><span class="line">        self.login_url &#x3D; settings.LOGIN_URL</span><br><span class="line">        # 开放白名单</span><br><span class="line">        self.open_urls &#x3D; [self.login_url] + getattr(settings, &#39;OPEN_URLS&#39;, [])</span><br><span class="line">        </span><br><span class="line">    def __call__(self, request):</span><br><span class="line">        if not request.user.is_authenticated and request.path_info not in self.open_urls:</span><br><span class="line">           # 登录之后跳转回原页面</span><br><span class="line">           return redirect(self.login_url + &#39;?next&#x3D;&#39; + request.get_full_path())</span><br><span class="line">           </span><br><span class="line">          response &#x3D; self.get_response(request)</span><br><span class="line">          return response</span><br></pre></td></tr></table></figure>
<p>备注：<code>request.path_info</code>用于获得当前请求的相对路径，如<code>/articles</code>，而<code>request.get_full_path()</code>用于获取当前请求完整的相对路径，包括请求参数，如：<code>/articles/?page=2</code>。使用<code>request.get_full_path()</code>要记得加括号，否则返回的是uwsgi请求对象，而不是字符串。<br>在<code>settings.py</code>文件里需要做的修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    &#39;blog.middleware.LoginRequiredMiddleware&#39;,</span><br><span class="line">]</span><br><span class="line">LOGIN_URL &#x3D; &quot;&#x2F;admin&#x2F;login&#x2F;&quot;</span><br><span class="line">OPEN_URLS &#x3D; [&quot;&#x2F;admin&#x2F;&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="3-其他中间件钩子函数"><a href="#3-其他中间件钩子函数" class="headerlink" title="3.其他中间件钩子函数"></a>3.其他中间件钩子函数</h4><p>Django还提供了其他三个中间件钩子函数，分别在执行视图函数，处理异常和进行模板渲染时使用。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Django高级使用：二"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/21/Django%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%BA%8C/"
    >Django高级使用：二</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/11/21/Django%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%BA%8C/" class="article-date">
  <time datetime="2022-11-21T13:08:52.000Z" itemprop="datePublished">2022-11-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Django高级使用：二"><a href="#Django高级使用：二" class="headerlink" title="Django高级使用：二"></a>Django高级使用：二</h1><h2 id="一-Django全局上下文处理器"><a href="#一-Django全局上下文处理器" class="headerlink" title="一.Django全局上下文处理器"></a>一.Django全局上下文处理器</h2><blockquote>
<p>前言：Django的全局上下文处理器(COntext Processors)的作用就是向模板传递需要全局使用的变量。</p>
</blockquote>
<h3 id="1-全局上下文处理器-Context-Processors-应用场景"><a href="#1-全局上下文处理器-Context-Processors-应用场景" class="headerlink" title="1.全局上下文处理器(Context Processors)应用场景"></a>1.全局上下文处理器(Context Processors)应用场景</h3><p>&emsp;&emsp;当需要向所有模板传递一个可以被全局使用的变量时。我们在编写Django视图函数时，一般会在视图函数中以字典形式向模板中传递需要被调用或使用的变量并指定渲染模板。</br><br>&emsp;&emsp;如果每个视图函数分别去查询数据库，然后向每个模板传递这些变量，不仅造成代码冗余，而且会造成对数据库的重复查询，一个更好的解决方案就是使用自定义的上下文处理器(Context Processors)给模板传递全局变量，一次查询全局使用，完美解决上述问题。</p>
<h3 id="2-Django内置的全局上下文处理器"><a href="#2-Django内置的全局上下文处理器" class="headerlink" title="2.Django内置的全局上下文处理器"></a>2.Django内置的全局上下文处理器</h3><blockquote>
<p>思考：我们没有向某个模板中传递过权限perms对象，我们却可以在所有模板中随时调用它。同样可以在模板中全局使用的变量还有request和user对象。</p>
</blockquote>
<p>这是因为Django的<code>settings.py</code>里已经包含了<code>django.template.context_processors.request</code>和<code>django.contrib.auth.context_processors.auth</code>这两个全局上下文处理器。如果把他们移除，看看还能不能在模板中调用<code>user</code>和<code>perms</code>？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;</span><br><span class="line">        &#39;DIRS&#39;: [</span><br><span class="line">            os.path.join(BASE_DIR, &#39;templates&#39;)</span><br><span class="line">        ],</span><br><span class="line">        &#39;APP_DIRS&#39;: True</span><br><span class="line">        &#39;OPTIONS&#39;: &#123;</span><br><span class="line">            &#39;context_processors&#39;:[</span><br><span class="line">                # 以下包含了4个默认的全局上下文处理器</span><br><span class="line">                &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">                &#39;django.template.context_processors.request&#39;,</span><br><span class="line">                &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">                &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">                &#39;myapp.custom_context_processors.xxx&#39;, # 自定义全局上下文处理器</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Django一般包含了上述4个默认全局上下文处理器，它们作用如下所示：</p>
<ul>
<li>django.template.context_processors.debug:在模板里可以直接使用settings的DEBUG参数及强大的sql_queries：它本身是一个字典，其中包括当前执行页面执行SQL查询所需的时间</li>
<li>django.template.context_processors.request：在模板中可以直接使用request对象</li>
<li>django.contrib.auth.context_processors.auth：在模板里面可以直接使用user, perms对象</li>
<li>django.contrib.messages.context_processors.messages:在模板里面可以直接使用message对象</li>
</ul>
<p>另外Django还提供了几个全局上下文处理器：</p>
<ul>
<li>django.template.context_processors.i18n：在模板里面可以直接使用settings的LANGUAGES和LANGUAGE_CODE</li>
<li>django.template.context_processors.media：可以在模板里面使用settings的MEDIA_URL参数</li>
<li>django.template.context_processors.csrf:给模板标签 csrf_token提供值</li>
<li>django.template.context_processors.tz： 可以在模板里面使用TIME_ZONE参数</li>
</ul>
<h3 id="3-如何自定义全局上下文处理器"><a href="#3-如何自定义全局上下文处理器" class="headerlink" title="3.如何自定义全局上下文处理器"></a>3.如何自定义全局上下文处理器</h3><p>自定义的全局上下文处理器本质是个函数，使用它必须满足3个条件：</p>
<ul>
<li>1.传入参数必须有<code>request</code>对象</li>
<li>2.返回值必须是个字典</li>
<li>3.使用前需要在settings的<code>context_processors</code>里声明。<h4 id="3-1-如何使用全局上下文处理器"><a href="#3-1-如何使用全局上下文处理器" class="headerlink" title="3.1 如何使用全局上下文处理器"></a>3.1 如何使用全局上下文处理器</h4>现要向模板传递一个叫做<code>site_name</code>的全局变量以便在所有模板中都能使用<code>site_name</code>输出站点名称。现在blog(app)的目录下新建<code>context_processors.py</code>中，新增如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># blog&#x2F;context_processors.py</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line">def global_site_name(request):</span><br><span class="line">    return &#123;&#39;site_name&#39;, settings.SITE_NAME,&#125;</span><br></pre></td></tr></table></figure>
然后在<code>settings</code>文件里增加如下申明：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#39;context_processors&#39;: [ # 以下包含了4个默认的全局上下文处理器</span><br><span class="line">    &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">    &#39;django.template.context_processors.request&#39;,</span><br><span class="line">    &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">    &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">    &#39;blog.context_processors.global_site_name&#39;, # 自定义全局上下文处理器</span><br></pre></td></tr></table></figure>
<h3 id="全局变量与本地变量的优先级"><a href="#全局变量与本地变量的优先级" class="headerlink" title="全局变量与本地变量的优先级"></a>全局变量与本地变量的优先级</h3>全局上下文处理器提供的变量优先级高于单个视图函数给单个模板传递的变量。这意味着全局上下文处理器提供的变量可能会覆盖你视图函数中自定义的本地变量，因此具体使用时请注意避免本地变量名与全局上下文处理器提供的变量名称重复。这些变量名包括perms，user和debug等等。<br>如果我们要设计单个视图函数定义的变量名覆盖全局变量，请使用如下强制模式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.template import RequestContext</span><br><span class="line"></span><br><span class="line">high_priority_context &#x3D; RequestContext(request)</span><br><span class="line">high_priority_context.push(&#123;&quot;my_name&quot;: &quot;Adrian&quot;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="二-Django信号机制及示例"><a href="#二-Django信号机制及示例" class="headerlink" title="二.Django信号机制及示例"></a>二.Django信号机制及示例</h2><blockquote>
<p>前言：Django框架包含了一个信号机制，它允许若干个发送者(sender)通知一组接收者(receiver)某些特定操作或事件(events)已经发生了，接收者收到指令信号(signals)后再去执行特定的操作。这部分介绍Django信号的工作机制、应用场景、如何在项目中使用信号已经如何自定义信号。</p>
</blockquote>
<h3 id="1-信号的工作机制"><a href="#1-信号的工作机制" class="headerlink" title="1.信号的工作机制"></a>1.信号的工作机制</h3>Django中的信号工作机制依赖如下三个主要要素：</li>
<li>发送者(sender)：信号的发出方，可以是模型，也可以是视图。当某个操作发生时，发送者会发出信号。</li>
<li>信号(signal)：发送的信号本身</li>
<li>接收者(receiver)：信号的接收者，其本质是一个回调函数。将这个函数注册到信号上，当特定的事件发生时，发送者发送信号，回调函数就会被执行。<h3 id="2-信号的应用场景"><a href="#2-信号的应用场景" class="headerlink" title="2.信号的应用场景"></a>2.信号的应用场景</h3>信号主要用于Django项目内不同时间得联动，实现程序的解耦。发送通知也是一个信号常用的场景。<blockquote>
<p>注意：Django中信号监听函数不是异步执行，而是同步执行，所以需要异步执行耗时的任务时(比如发送邮件或写入文件)，不建议使用Django自带的信号。</p>
</blockquote>
<h3 id="3-使用举例"><a href="#3-使用举例" class="headerlink" title="3.使用举例"></a>3.使用举例</h3>假设我们的Profile模型，与User模型是一对一关系。我们希望创建User对象实例时能自动创建Profile对象实例，而更新User对象实例时不创建新的Profile对象实例。这时我们可以自定义<code>create_user_profile</code>和<code>save_user_profile</code>两个监听函数，同时监听sender(User模型)发出的<code>post_save</code>信号。由于<code>post_save</code>可同时用于模型的创建和更新，我们用<code>if created</code>这个判断来加以区别。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from django.db.models.signals import post_save</span><br><span class="line">from django.dispatch import receiver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Profile(models.Model):</span><br><span class="line">    user &#x3D; models.OneToOneField(User, on_delete&#x3D;models.CASCADE)</span><br><span class="line">    birth_date &#x3D; models.DateField(null&#x3D;True, bland&#x3D;True)</span><br><span class="line"></span><br><span class="line"># 监听User模型创建</span><br><span class="line">@receiver(post_save, sender&#x3D;User)</span><br><span class="line">def create_user_profile(sender, instance, created, **kwargs):</span><br><span class="line">    if created:</span><br><span class="line">        Profile.objects.create(user&#x3D;instance)</span><br><span class="line"></span><br><span class="line"># 监听User模型更新</span><br><span class="line">@receiver(post_save, sender&#x3D;User)</span><br><span class="line">def save_user_profile(sender,instance, **kwargs):</span><br><span class="line">    instance.profile.save()</span><br></pre></td></tr></table></figure>
我们再来看一个使用信号清除缓存的例子。当模型A被更新或被删除时，会分别发出<code>post_save</code>和<code>post_delete</code>的信号，监听这两个信号的receivers函数会自动清楚缓存里的A对象列表。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.core.cache import cache</span><br><span class="line">from django.db.models.signals import post_delete, post_save</span><br><span class="line">from django.dispatch import receiver</span><br><span class="line"></span><br><span class="line">@receiver(post_save, sender&#x3D;ModelA)</span><br><span class="line">def cache_post_save_handler(sender, **kwargs)：</span><br><span class="line">    cache.delete(&#39;cached_a_objetcs&#39;)</span><br><span class="line">    </span><br><span class="line">@receiver(post_delete, sneder&#x3D;ModelA)</span><br><span class="line">def cache_post_delete_handler(sender, **kwargs):</span><br><span class="line">    cache.delete(&#39;cached_a_objects&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="4-Django常用内置信号："><a href="#4-Django常用内置信号：" class="headerlink" title="4.Django常用内置信号："></a>4.Django常用内置信号：</h3>前面例子举例了<code>post_save</code>和<code>post_delete</code>信号。Django还内置了其他信号：</li>
<li>pre_save&amp;post_save：在模型调用save()方法之前或之后发送</li>
<li>pre_init&amp;post_init：在模型调用_init_方法之前或之后发送。</li>
<li>pre_delete &amp; post_delete：在模型调用delete()方法或查询集调用delete()方法之前或之后发送。</li>
<li>request_started &amp; request_finished：Django建立或关闭HTTP请求时发送。<h2 id="二-自定义Django-admin管理命令"><a href="#二-自定义Django-admin管理命令" class="headerlink" title="二.自定义Django-admin管理命令"></a>二.自定义Django-admin管理命令</h2><blockquote>
<p>前言：每次在启动Django服务之前，我们都会在终端运行<code>python mnaage.py xxx</code>的管理命令。其实我们还可以自定义管理命令，这对于执行独立的脚本或任务非常有用，比如清除缓存、导出用户邮件清单或发送邮件等等。</br><br>自定义的管理命令不仅可以通过<code>manage.py</code>运行，还可以通过Linux或Celery的crontab服务将其设成定时任务。这部分主要讲解如何自定义Django-admin命令，并提供一些演示案例。</br><br>自定义Django-admin命令一共分三步：创建文件夹布局、编写命令代码和测试使用。</p>
</blockquote>
<h3 id="1-创建文件夹布局"><a href="#1-创建文件夹布局" class="headerlink" title="1.创建文件夹布局"></a>1.创建文件夹布局</h3>自定义的Django-admin管理命令本质上是一个python脚本文件，它的存放路径必须遵循一定的规范，一般位于<code>app/management/commands</code>目录。整个文件夹的布局如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app01&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    management&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        commands&#x2F;</span><br><span class="line">            __init__.py</span><br><span class="line">            _private.py # 以下划线开头文件不能用作管理命令</span><br><span class="line">            my_commands.py # 这个就是自定义的管理命令脚本，文件名即为命令名</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure>
注意：</li>
<li><code>management</code>和<code>commands</code>每个目录下都必须有个<code>__init__.py</code>文件，表明这是一个python包。另外以下划线开头的文件名不能用作管理命令脚本。</li>
<li><code>management/commands</code>目录可以位于任何一个app的目录下，Django都能找到它。</li>
<li>一般建议每个python脚本文件对应一条管理命令<h3 id="2-编写命令代码"><a href="#2-编写命令代码" class="headerlink" title="2.编写命令代码"></a>2.编写命令代码</h3>每一个自定义的管理命令本质是一个<code>Command</code>类，它继承了Django的<code>Basecommand</code>或其子类，主要通过重写<code>handle()</code>方法实现自己的业务逻辑代码，而<code>add_argument()</code>则用于帮助处理命令行的参数，如果运行命令时不需要额外参数，可以不写这个方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from django.core.management.base import BaseCommand</span><br><span class="line"></span><br><span class="line">class Command(BaseCommand):</span><br><span class="line">    # 帮助文本，一般备注命令的用途及如何使用</span><br><span class="line">    help &#x3D; &#39;Some help texts&#39;</span><br><span class="line">    </span><br><span class="line">    # 处理命令行参数，可选</span><br><span class="line">    def add_argument(self, parser)：</span><br><span class="line">        pass</span><br><span class="line">        </span><br><span class="line">    # 核心业务逻辑</span><br><span class="line">    def handle(self, *args, **options):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<h3 id="3-实践"><a href="#3-实践" class="headerlink" title="3.实践"></a>3.实践</h3><blockquote>
<p>前言：我们现在来看一个最简单的例子，希望定义一个<code>heelo_world</code>的命令。这样当我们运行<code>python manage.py hello_world</code>命令时，控制台会打印出<code>Hello World!</code>的字样。在<code>app/management/commands</code>目录下新建<code>hello_world.py</code>，添加如下代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.core.management.base iport BaseCommand</span><br><span class="line"></span><br><span class="line">class Command(BaseCommand):</span><br><span class="line">    # 帮助文本，一般备注命令的用途及如何使用</span><br><span class="line">    help &#x3D; &quot;Print Hello World！&quot;</span><br><span class="line">    </span><br><span class="line">    # 核心业务逻辑</span><br><span class="line">    def handle(self, *args, **options):</span><br><span class="line">        # 注意：当我们使用管理命令并希望在控制台输出指定信息时，我们应该使用self.stdout和self.stderr方法，而不应该直接使用python的print方法。另外，我们不需要在消息的末尾加上换行符，它将被自动添加。</span><br><span class="line">        self.stdout.write(&#39;Hello World!&#39;)</span><br></pre></td></tr></table></figure>
&emsp;&emsp;现在我们来稍微增加点难度，来通过命令行给<code>hello_world</code>命令传递参数，以实现运行<code>python manage.py hello_world John</code>命令时，打印出<code>Hello World! John</code>。</br><br>&emsp;&emsp;现在我们修改原<code>hello_world.py</code>，添加<code>add_arguments</code>方法，该方法的作用是给自定义的handle方法添加一个或多个参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from django.core.managements.base import BaseCommand</span><br><span class="line"></span><br><span class="line">class Command(BaseCommand):</span><br><span class="line">    # 帮助文本，一般备注命令的用途及如何使用</span><br><span class="line">    help &#x3D; &quot;Print Hello World!&quot;</span><br><span class="line">    </span><br><span class="line">    # 给命令添加一个名为name的参数</span><br><span class="line">    def add_argument(self, parser):</span><br><span class="line">        parser.add_argument(&#39;name&#39;)</span><br><span class="line">        </span><br><span class="line">    # 核心业务逻辑，通过options字典接收name参数值，拼接字符串后输出</span><br><span class="line">    def handle(self, *args, **options):</span><br><span class="line">        msg &#x3D; &#39;Hello World !&#39; + options[&#39;name&#39;]</span><br><span class="line">        self.stdout.write(msg)</span><br></pre></td></tr></table></figure>
<h3 id="4-实际使用场景"><a href="#4-实际使用场景" class="headerlink" title="4.实际使用场景"></a>4.实际使用场景</h3><blockquote>
<p>前言：我们来看两个自定义管理命令的实际应用案例</p>
</blockquote>
<h4 id="4-1检查数据库连接是否已经就绪"><a href="#4-1检查数据库连接是否已经就绪" class="headerlink" title="4.1检查数据库连接是否已经就绪"></a>4.1检查数据库连接是否已经就绪</h4>无论使用常规方式还是Docker在生产环境部署Django项目，我们都需要确保数据库连接已经就绪后才进行数据库迁移(migrate)操作，否则Django应用程序一定会报错。</br><br>此时我们可以自定义一个<code>wair_for_db</code>的命令，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># app&#x2F;management&#x2F;commands&#x2F;wait_for_db.py</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">from django.db import connections</span><br><span class="line">from django.db.utils import OperationError</span><br><span class="line">from django.core.management import BaseCommand</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class Command(BaseCommand):</span><br><span class="line">    help &#x3D; &#39;Run data migrations util db is available.&#39;</span><br><span class="line">    </span><br><span class="line">    def handle(self, *args, **options):</span><br><span class="line">        self.stdout.write(&#39;Waiting for database...&#39;)</span><br><span class="line">        db_conn &#x3D; None</span><br><span class="line">        while not db_conn:</span><br><span class="line">            try:</span><br><span class="line">                # try to build connection</span><br><span class="line">                db_conn &#x3D; connections[&#39;default&#39;]</span><br><span class="line">            except OperationalError:</span><br><span class="line">                # 连接失败，就等待1s</span><br><span class="line">                self.stdout.write(&#39;Database unavilable, waiting 1 second...&#39;)</span><br><span class="line">                time.sleep(1)</span><br><span class="line">        </span><br><span class="line">        self.stdout.write(self.style.SUCCESS(&#39;Database available!&#39;))</span><br></pre></td></tr></table></figure>
定义好这个命令之后每次在运行<code>python manage.py migrate</code>命令前先运行<code>python manage.py wait_for_db</code>即可<h4 id="4-2-周期性发送邮件"><a href="#4-2-周期性发送邮件" class="headerlink" title="4.2 周期性发送邮件"></a>4.2 周期性发送邮件</h4><blockquote>
<p>应用场景：如果你是网站管理员，你肯定希望知道每天有多少新用户已注册，这时你可以自定义一条<code>mail_admin</code>的管理命令，将每天新注册用户数量以邮件形式发送给自己，如下所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># app&#x2F;management&#x2F;commands&#x2F;mail_admin.py</span><br><span class="line"></span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">from datetime import timedelta, time, datetime</span><br><span class="line">from django.core.mail import mail_admins</span><br><span class="line">from django.core.managements import BaseCommand</span><br><span class="line">from django.utils import timezone</span><br><span class="line">from django.contrib.auth import get_user_model</span><br><span class="line"></span><br><span class="line">User &#x3D; get_user_model()</span><br><span class="line"></span><br><span class="line">today &#x3D; timezone.now()</span><br><span class="line">yesterday &#x3D; today - timedelta(1)</span><br><span class="line"></span><br><span class="line">Class Command(BaseCommand):</span><br><span class="line">    # 获取过去一天注册的用户数量</span><br><span class="line">    user_count &#x3D; User.objects.filter(data_joined_range&#x3D;(yesterday, today)).count()</span><br><span class="line">    </span><br><span class="line">    # 发送给管理员</span><br><span class="line">    if user_count &gt;&#x3D; 1:</span><br><span class="line">        message &#x3D; &quot;You have got &#123;&#125; user(s) in the past 24 hours&quot;.format(user_count)</span><br><span class="line">        </span><br><span class="line">        subject &#x3D; (</span><br><span class="line">            f&quot;New user count for &#123;today.strftime(&quot;%Y-%m-%d&quot;)&#125;:&#123;user_count&#125;&quot;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        mail_admin(subject&#x3D;subject, message&#x3D;message, html_message&#x3D;None)</span><br><span class="line">        </span><br><span class="line">        self.stdout.write(&quot;Email was sent&quot;)</span><br><span class="line">    else:</span><br><span class="line">        self.stdout.write(&quot;No new users today&quot;)</span><br></pre></td></tr></table></figure>
其中，真正发送邮件成功需要设置Email后台及管理员，测试环境下可以使用如下简单配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EMAIL_BACKEND &#x3D; &quot;dkjango.core.mail.bakends.EmailBackend&quot;</span><br><span class="line">DEFAULT_FROM_EAIL &#x3D; &quot;noreply@example.com&quot;</span><br><span class="line">ADMINS &#x3D; [(&quot;大江狗&quot;, &quot;yunbo.shi@example.com&quot;),]</span><br></pre></td></tr></table></figure>
但是如果每天都要进入终端运行这个命令实在太麻烦了，我们完全可以使用Linux的crontab服务或Celery-Beat将其设置成周期性定时任务task，这时只需要调用Django的<code>call_command</code>方法即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># app&#x2F;tasks.py， 可以在任一app目录下新建task</span><br><span class="line">from celery import shared_task</span><br><span class="line">from django.core.management import call_command</span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def mail_admin():</span><br><span class="line">    call_command(&quot;mail_admin&quot;,)</span><br></pre></td></tr></table></figure>
<h2 id="三-Django项目中使用Celery执行异步和周期性任务"><a href="#三-Django项目中使用Celery执行异步和周期性任务" class="headerlink" title="三.Django项目中使用Celery执行异步和周期性任务"></a>三.Django项目中使用Celery执行异步和周期性任务</h2><blockquote>
<p>前言：Django Web项目中我们经常需要执行耗时的任务比如发送邮件、调用第三方接口、批量处理文件等等，将这些任务异步化放在后台运行可以有效缩短请求响应时间。另外服务器上经常会有定时任务的需求，比如清除缓存、备份数据库等工作。Celery是一个高效的异步任务队列/基于分布式消息传递的作业队列，可以轻松帮助我们在Django项目中设置执行异步和周期性任务。</p>
</blockquote>
<h3 id="1-Celery的工作原理"><a href="#1-Celery的工作原理" class="headerlink" title="1.Celery的工作原理"></a>1.Celery的工作原理</h3>Celery是一个高效的基于分布式消息传递的作业队列，它主要通过消息(messages)传递任务，通常使用一个叫Broker(中间人)来协调client(任务的发出者)和worker(任务的处理者)。clients发出消息到队列中，broker将队列中的消息派发给Celery worker来处理。Celery本身不提供消息服务，它支持的消息服务(Broker)有RabbitMQ和Redis，Redis一般多是Django项目中首选的缓存后台。<h3 id="2-安装项目依赖文件"><a href="#2-安装项目依赖文件" class="headerlink" title="2.安装项目依赖文件"></a>2.安装项目依赖文件</h3>本项目使用了最新Django和Celery版本。因为本项目使用Redis做消息队列的broker，所以还需要安装redis。如果你需要另外设置定时或周期性任务，还需要安装<code>django-celery-beat</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># pip 安装首选</span><br><span class="line">Django&#x3D;&#x3D;3.2</span><br><span class="line">celery&#x3D;&#x3D;5.0.5</span><br><span class="line">redis&#x3D;&#x3D;3.5.3</span><br><span class="line"></span><br><span class="line"># 可选,windows下运行celery 4以后版本，还需要额外安装eventlet库</span><br><span class="line">eventlet</span><br><span class="line"></span><br><span class="line"># 推荐安装，需要设置定时或周期任务时安装，推荐安装</span><br><span class="line">django-celery-results&#x3D;&#x3D;2.0.1</span><br><span class="line"></span><br><span class="line"># 视情况需要，需要监控celery运行定时任务时安装</span><br><span class="line">folower&#x3D;&#x3D;0.9.7</span><br></pre></td></tr></table></figure>
<h3 id="3-Celery配置"><a href="#3-Celery配置" class="headerlink" title="3.Celery配置"></a>3.Celery配置</h3>在正式使用<code>celery</code>和<code>django-celery-beat</code>之前，需要做基础的配置工作。加入Django项目文件夹布局如下所示，我们首先需要在myproject/myproject目录下新增<code>celery.py</code>并修改<code>__init__.py</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- myproject&#x2F;</span><br><span class="line">  - manage.py</span><br><span class="line">  - project&#x2F;</span><br><span class="line">    - __init__.py # 修改这个文件</span><br><span class="line">    - celery.py # 新增这个文件</span><br><span class="line">    - asgi.py</span><br><span class="line">    - settings.py</span><br><span class="line">    - urls.py</span><br><span class="line">    - wsgi.py</span><br></pre></td></tr></table></figure>
新建<code>celery.py</code>，添加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line"># 设置环境变量</span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;myproject.settings&#39;)</span><br><span class="line"></span><br><span class="line"># 实例化</span><br><span class="line">app &#x3D; Celery(&#39;myproject&#39;)</span><br><span class="line"></span><br><span class="line"># namespace &#x3D;&#39;CELERY&#39;作用是允许在Django配置文件中对Celery进行配置</span><br><span class="line"># 但所有Celery配置项必须以CELERY开头，防止冲突</span><br><span class="line">app.config_from_object(&#39;django.conf:settings&#39;, namespace&#x3D;&#39;CELERY&#39;)</span><br><span class="line"></span><br><span class="line"># 自动的从Django的已注册app中发现任务</span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br><span class="line"># 一个测试任务</span><br><span class="line">@app.task(bind&#x3D;True)</span><br><span class="line">def debug_task(self):</span><br><span class="line">    print(f&#39;Request: &#123;self.request!r&#125;&#39;)</span><br></pre></td></tr></table></figure>
修改<strong>init</strong>.py，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from .celery import app as celery_app</span><br><span class="line">__all__ &#x3D; (&#39;celery_app&#39;,)</span><br></pre></td></tr></table></figure>
接下来修改Django项目的<code>settings.py</code>，添加Celery有关配置选项，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 最重要的配置，设置消息broker，格式为：db:&#x2F;&#x2F;user:password@host:port&#x2F;dbname</span><br><span class="line"># 如果redis安装在本机，使用localhost</span><br><span class="line"># 如果docker部署的redis,使用redis:&#x2F;&#x2F;redis:6379</span><br><span class="line">CELERY_BROKER_URL &#x3D; &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;0&quot;</span><br><span class="line"></span><br><span class="line"># celery时区设置，建议与Django settings中TIME_ZONE同样时区，防止时差</span><br><span class="line"># Django设置时区需同时设置USE_TZ&#x3D;True和TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">CELERY_TIMEZONE &#x3D; TIME_ZONE</span><br></pre></td></tr></table></figure>
其他Celery常用配置选项包括：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 为Django_celery_results存储Celery任务执行结果设置后台</span><br><span class="line"># 格式为： db+scheme:&#x2F;&#x2F;user:paasword@host:port&#x2F;dbname</span><br><span class="line"># 支持数据库django-db和缓存django-cache存储任务状态及结果</span><br><span class="line">CELERY_RESULT_BACKEND &#x3D; &quot;django-db&quot;</span><br><span class="line"># celery内容等消息的格式设置，默认为json</span><br><span class="line">CELERY_ACCEPT_CONTENT &#x3D; [&#39;application&#x2F;json&#39;,]</span><br><span class="line">CELERY_TASK_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">CELERY_RESULT_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line"></span><br><span class="line"># 为任务设置超时时间，单位秒。超时即终止，执行下个任务</span><br><span class="line">CELERT_TASK_TIME_LIMIT &#x3D; 5</span><br><span class="line"></span><br><span class="line"># 为存储结果设置过期日期，默认1天过期。如果beat开启,Celery每天会自动清除</span><br><span class="line"># 设为0，则存储结果用不过期</span><br><span class="line">CELERY_RESULT_EXPIRES &#x3D; xx</span><br><span class="line"></span><br><span class="line"># 任务限流</span><br><span class="line">CELERY_TASK_ANNOTATIONS &#x3D; &#123;&#39;tasks.add&#39;:&#123;&#39;rate_limit&#39;: &#39;10&#x2F;s&#39;&#125;&#125;</span><br><span class="line"></span><br><span class="line"># worker并发数量，一般默认CPU核数，可以不设置</span><br><span class="line">CELERY_WORKER_CONCURRENCY &#x3D; 2</span><br><span class="line"></span><br><span class="line"># 每个worker执行了多少任务就会死掉，默认是无限的</span><br><span class="line">CELERY_WORKER_MAX_TASKS_PER_CHILD &#x3D; 200</span><br></pre></td></tr></table></figure>
注意：</li>
<li>在Django中正式编写和执行自己的异步任务前，一定要先测试redis和celery是否安装好并配置成功</li>
<li>一个无限期阻塞的任务会使得工作单元无法再做其他事情，建议给任务设置超时时间<h3 id="4-测试Celery是否工作正常"><a href="#4-测试Celery是否工作正常" class="headerlink" title="4.测试Celery是否工作正常"></a>4.测试Celery是否工作正常</h3>&emsp;&emsp;首先需要启动redis服务</br><br>&emsp;&emsp;启动redis服务后，要先进入项目所在文件夹运行<code>python manage.py runserver</code>命令启动Django服务器(无需创建任何app)，然后再打开一个终端terminal窗口输入celery命令，启动worker<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Linux下测试，启动Celery</span><br><span class="line">Celery -A myproject worker -l info</span><br><span class="line"></span><br><span class="line"># windows下测试，启动Celery</span><br><span class="line">Celery -A myproject worker -l info -P eventlet</span><br><span class="line"></span><br><span class="line"># 如果Windows下Celery不工作，输入如下命令</span><br><span class="line">Celery -A myproject worker -l info --pool&#x3D;solo</span><br></pre></td></tr></table></figure>
<h3 id="5-编写任务"><a href="#5-编写任务" class="headerlink" title="5.编写任务"></a>5.编写任务</h3>Celery配置完成后，可以编写任务了。Django项目中所有需要Celery执行的异步或周期性任务都放在tasks.py文件里，该文件可以位于project目录下，也可以位于各个app的目录下，专属于某个Celery实例化项目的task可以使用<code>@app.task</code>装饰器定义，各个app目录下可以复用的task建议使用<code>@shared_task</code>定义<br>示例如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># myproject&#x2F;tasks.py</span><br><span class="line"># 专属于myproject项目的任务</span><br><span class="line">app &#x3D; Celery(&#39;myproject&#39;)</span><br><span class="line">@app.task</span><br><span class="line">def test():</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line"># app&#x2F;tasks.py,可以复用的task</span><br><span class="line">from celery import shared_task</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def add(x, y):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure>
上面我们定义了一个名为<code>add</code>的任务，它接收两个参数，并返回计算结果。为了模拟耗时任务，我们中途让其sleep 2s。现在已经定义了一个耗时任务，我们希望在Django的视图或其他地方中以异步方式调用执行它，做法如下面所示：<br>注意：</li>
<li>使用celery定义任务时，避免在一个任务中调用另一个异步任务，容易造成阻塞。</li>
<li>当我们使用<code>@app.task</code>装饰器定义我们的异步任务时，那么这个任务依赖于根据项目名myproject生成的Celery实例。然而我们在进行Django开发时为了保证每个app的可重用性。我们经常会在每个app文件夹下编写异步任务，这些任务并不依赖于具体的Django项目名。使用<code>@shared_app</code>装饰器能让我们避免对某个项目名对应Celery实例的依赖，使app的可移植性更强<h3 id="6-异步调用任务"><a href="#6-异步调用任务" class="headerlink" title="6.异步调用任务"></a>6.异步调用任务</h3>Celery提供了2种以异步方式调用任务的方法，<code>delay</code>和<code>apply_async</code>方法，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 方法一： delay方法</span><br><span class="line">task_name.delay(args1, args2, kwargs&#x3D;value_1, kwargs2&#x3D;value_2)</span><br><span class="line"></span><br><span class="line"># 方法二： apply_async方法，与delay类似，但支持更多的参数</span><br><span class="line">task.apply_async(args&#x3D;[arg1, arg2], kwargs&#x3D;&#123;key:value, key:value&#125;)</span><br></pre></td></tr></table></figure>
接下来我们来看一个具体的例子，我们编写了一个Django视图函数，使用<code>delay</code>方法调用<code>add</code>任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># app&#x2F;views.py</span><br><span class="line">from .tasks import add</span><br><span class="line"></span><br><span class="line">def test_celery(request):</span><br><span class="line">    add.delay(3, 5)</span><br><span class="line">    return HttpResponse(&#39;Celery works&#39;)</span><br><span class="line">    </span><br><span class="line"># app&#x2F;urls.py</span><br><span class="line">uslpatterns &#x3D; [</span><br><span class="line">    re_path(r&#39;^test&#x2F;$&#39;, views.test_celery, name&#x3D;&quot;test_celery&quot;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
我们现在再次使用<code>apply_async</code>方法调用<code>add</code>任务，不过还要打印初任务的id(task.id)和状态status。Celery会为每个加入到队列中的任务分配独一无二的uuid，可以通过<code>task.status</code>获取状态和<code>task.result</code>获取结果。注意：<code>apply_async</code>传递参数的方式与delay方法略有不同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># app&#x2F;views.py</span><br><span class="line">from .tasks import add</span><br><span class="line"></span><br><span class="line">def test_celery(request):</span><br><span class="line">    result &#x3D; add.apply_async(args&#x3D;[3,5])</span><br><span class="line">    return HttpResponse(result.task_id + &#39; : &#39; + result.status)</span><br></pre></td></tr></table></figure>
除了在Django admin后台中查看任务状态和结果，你还可以在视图中通过<code>AsyncResult</code>方法获取任务执行状态和结果，它需要接收一个任务的task_id(通常为uuid格式)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from celery.result imprt AsyncResult</span><br><span class="line"># 调用异步任务</span><br><span class="line">async_task &#x3D; add.apply_async(args&#x3D;[3, 5])</span><br><span class="line"># 获取任务状态及结果</span><br><span class="line">AsyncResult(async_task.task_id).status</span><br><span class="line">AsyncResult(async_task.task_id).result</span><br></pre></td></tr></table></figure>
<h3 id="7-设置定时和周期性任务"><a href="#7-设置定时和周期性任务" class="headerlink" title="7.设置定时和周期性任务"></a>7.设置定时和周期性任务</h3>借助于装<code>django-celery-beat</code>后，可以将任一Celery任务设置为定时任务或周期性任务，使用它你只需要通过pip安装它，并加入INSTALLED_APPS里去。</br><figure class="highlight plain"><figcaption><span>admin后台添加</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 7.1 配置文件添加任务</span><br><span class="line">同一任务可以设置成不同的调用周期，给它们不同的任务名就好了</span><br></pre></td></tr></table></figure>
from datetime import timedelta<br>CELERY_BEAT_SCHEDULE = {<br>  “add-every-30s”:{<pre><code>  &quot;task&quot;: &quot;app.tasks.add&quot;,
  &quot;schedule&quot;: 30.0, # 每30s执行一次
  &#39;args&#39;: (3, 8)
</code></pre>
  },<br>  “add-every-day”:{<pre><code>  &quot;task&quot;: &quot;app.tasks.add&quot;,
  &#39;schedule&#39;: timedelta(hours=1), #每1小时执行1次
  &#39;args&#39;: (3,8)
</code></pre>
  }<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 7.2 通过Crontab设置定时任务</span><br><span class="line">如果你希望在特定的时间(某月某周或某天)执行一个任务，你可以通过crontab设置定时任务，如下例所示：</span><br></pre></td></tr></table></figure>
CELERY_BEAT_SCHEDULE = {<h1 id="每周一早上7点半执行"><a href="#每周一早上7点半执行" class="headerlink" title="每周一早上7点半执行"></a>每周一早上7点半执行</h1>  ‘add-every-monday-morning’:{<pre><code>  &#39;task&#39;: &#39;app.tasks.add&#39;,
  &#39;schedule&#39;: crontab(hour=7, minute=30,day_of_week=1),
  &#39;args&#39;: (7, 8)
</code></pre>
  }<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 8.启动任务调度器beat</span><br><span class="line">前面我们只是添加了定时或周期性任务，我们还需要启动任务调度器beat分发定时和周期任务给Celery的worker</span><br><span class="line">#### 8.1启动任务调度器beat</span><br><span class="line">多开几个终端，一个用来启动任务调度器beat，另一个启动celery worker，任务就可以在后台执行了</span><br></pre></td></tr></table></figure>
<h1 id="开启任务调度器"><a href="#开启任务调度器" class="headerlink" title="开启任务调度器"></a>开启任务调度器</h1>Celery -A myproject beat</li>
</ul>
<h1 id="Linux下开启Celery-worker"><a href="#Linux下开启Celery-worker" class="headerlink" title="Linux下开启Celery worker"></a>Linux下开启Celery worker</h1><p>Celery -A myproject worker -l info</p>
<h1 id="windows下开启Celery-worker"><a href="#windows下开启Celery-worker" class="headerlink" title="windows下开启Celery worker"></a>windows下开启Celery worker</h1><p>Celery -A myproject worker -l info -P eventlet</p>
<h1 id="windows下如果报Pid错误"><a href="#windows下如果报Pid错误" class="headerlink" title="windows下如果报Pid错误"></a>windows下如果报Pid错误</h1><p>Celery -A myproject worker -l info –pool=solo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 8.2 Flower监控任务执行状态</span><br><span class="line">除了&#96;&#96;&#96;django_celery_results&#96;&#96;&#96;，你可以使用&#96;&#96;&#96;flower&#96;&#96;&#96;监控后台执行任务状态。它提供了一个可视化的界面，在测试环境中非常有用</span><br></pre></td></tr></table></figure>
<p>pip install flower</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装好后，你有如下两种方式启动服务器。启动服务器后，打开&#96;&#96;&#96;http:&#x2F;&#x2F;localhost:5555&#96;&#96;&#96;即可查看监控情况</span><br></pre></td></tr></table></figure>
<h1 id="从terminal终端启动，proj为项目名"><a href="#从terminal终端启动，proj为项目名" class="headerlink" title="从terminal终端启动，proj为项目名"></a>从terminal终端启动，proj为项目名</h1><p>$ flower -A proj –port=5555</p>
<h1 id="从celery启动"><a href="#从celery启动" class="headerlink" title="从celery启动"></a>从celery启动</h1><h1 id="celery-flower-A-proj-–address-127-0-0-1-–port-5555"><a href="#celery-flower-A-proj-–address-127-0-0-1-–port-5555" class="headerlink" title="celery flower -A proj –address=127.0.0.1 –port=5555"></a>celery flower -A proj –address=127.0.0.1 –port=5555</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 9.Celery高级用法与注意事项</span><br><span class="line">#### 9.1给任务设置最大重试次数</span><br><span class="line">定义任务时可以通过&#96;&#96;&#96;max_retries&#96;&#96;&#96;设置最大重试次数，并调用&#96;&#96;&#96;self.retry&#96;&#96;&#96;方法调用。因为要调用&#96;&#96;&#96;self&#96;&#96;&#96;这个参数，定时任务必须设置&#96;&#96;&#96;bind&#x3D;True&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<p>@shared_task(bind=True, max_retries=3)<br>def send_batch_notification(self):<br>    try:<br>        something_raising()<br>        raise Excepton(‘Can’t send email.’)<br>    except Exception as exec:<br>        self.retry(exc=exc, countdown=5)<br>    send_email(<br>        subject=’Batch email notifications’,<br>        message=’Test mail’,<br>        from_email=’no-reply@example.com’,<br>        recipient_list=[‘john@example.com’]<br>    )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 9.2 不同任务交由不同Queue处理</span><br><span class="line">不同任务所需要的时间和资源不一样。为了防止一些非常占用资源或耗时的任务阻塞任务队列导致一些简单的任务也无法执行，可以将不同的任务交由不同的Queue处理。下例定义了两个Queue队列，default执行普通任务，heavy_tasks执行重型任务。</span><br></pre></td></tr></table></figure>
<p>CELERY_TASK_DEFAULT_QUEUE = ‘default’<br>CELERY_TASK_DEFAULT_ROUTING_KEY = ‘default’<br>CELERY_QUEUES = (<br>    Queue(‘default’, Exchage(‘default’), routing_key=’default’)<br>    Queue(‘heavy_tasks’, Exchage(‘heavy_tasks’), routing_key=’heavy_tasks’)<br>)<br>CELERY_TASK_ROUTES = {<br>    ‘mysqpp.tasks.havy_tasks’: ‘heavy_tasks’<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 9.3 Django的模型对象不应该作为参数传递</span><br><span class="line">Django的模型对象不应该作为参数传递给任务，几乎总时在任务运行时从数据库获取对象是最好的，因为老的数据会导致竞态条件。假象有这样一个场景，你有一篇文章，以及自动展开文章中缩写的任务：</span><br></pre></td></tr></table></figure>
<p>class Article(models.Model):<br>    title = models.Charfield()<br>    body = models.Textfield()</p>
<p>@app.task<br>def expend_abbreviations(article):<br>    article.body.replace(‘Old text’, ‘New text’)<br>    article.save()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，作者创建一篇文章并保存，这时作者点击一个按钮初始化一个缩写展开任务：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>article = Article.objects.get(id=102)<br>expand_abbreviations.delay(article)</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在，队列非常忙，所以任务在2分钟内都不会运行。与此同时，另一个作者修改了这篇文章，当这个任务最终运行，因为老版本的文章作为参数传递给了这个任务，所以这篇文章会回滚到老的版本。修复这个竞态条件很简单，只要参数传递文章的id即可，此时可以在任务中重新获取这篇文章：</span><br></pre></td></tr></table></figure>
<p>@app.task<br>def expand_abbreviation(article_id):<br>    article = Article.objects.get(id=article_id)<br>    article.body.replace(‘MyCorp’, ‘My Corporation’)<br>    article.save()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 9.4 使用on_commit函数处理事务</span><br><span class="line">再看另外一个celery中处理事务的例子。这是在数据库中创建一个文章对象的Django视图，此时传递主键给任务，它使用&#96;&#96;&#96;commit_on_success&#96;&#96;&#96;装饰器，当视图返回时该事务会被提交，当视图抛出异常时会进行回滚。</span><br></pre></td></tr></table></figure>
<p>from django.db import transaction</p>
<p>@transaction.commit_on_success<br>def create_article(request):<br>    article = Article.objects.create()<br>    expand_abbreviation.delay(article.pk)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果在事务提交之前已经开始执行会产生一个竞态条件；数据库对象还不存在。解决方案时使用&#96;&#96;&#96;on_commit&#96;&#96;&#96;回调函数来在所有事务提交成功后启动任务。</span><br></pre></td></tr></table></figure>
<p>from django.db.transaction import on_commit</p>
<p>def create_article(request):<br>    article = Artile.objects.create()<br>    on_commit(lambda: expand_abbreiation.delay(article.pk))<br>```</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Python web开发工具"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/12/Python%20web%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"
    >Python Web开发工具</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/11/12/Python%20web%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2022-11-12T11:56:52.000Z" itemprop="datePublished">2022-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Python-Web开发工具"><a href="#Python-Web开发工具" class="headerlink" title="Python Web开发工具"></a>Python Web开发工具</h1><h2 id="一-Python多进程知识点讲解"><a href="#一-Python多进程知识点讲解" class="headerlink" title="一.Python多进程知识点讲解"></a>一.Python多进程知识点讲解</h2><p>调用python的multiprocessing模块，分析如下的一段代码：</p>
<h4 id="1-multiprocessing模块讲解"><a href="#1-multiprocessing模块讲解" class="headerlink" title="1.multiprocessing模块讲解"></a>1.multiprocessing模块讲解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def long_time_task(i):</span><br><span class="line">    print(&#39;子进程：&#123;&#125;-任务&#123;&#125;&#39;.format(os.getpid(), i))</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;结果：&#123;&#125;&quot;.format(8*20))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&quot;当前母进程：&#123;&#125;&quot;.format(os.getpid()))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    p1 &#x3D; Process(target&#x3D;long_time_task, args&#x3D;(1,))</span><br><span class="line">    p2 &#x3D; Process(target&#x3D;long_time_task, args&#x3D;(2,))</span><br><span class="line">    print(&quot;等待所有子进程完成。&quot;)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&quot;总共用时&#123;&#125;秒&quot;.format(end-start))</span><br></pre></td></tr></table></figure>
<p>执行这段python代码，控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前母进程：17304</span><br><span class="line">等待所有子进程完成。</span><br><span class="line">子进程：7132-任务1</span><br><span class="line">子进程：10288-任务2</span><br><span class="line">结果：160</span><br><span class="line">结果：160</span><br><span class="line">总共用时2.1409997940063477秒</span><br></pre></td></tr></table></figure>
<p>多进程下，本耗时4s左右的任务，耗时变为了2s，时间减少了一半，可见并发执行的时间明显比顺序执行要快很多。从代码来看，尽管我们只创建了两个进程，可实际运行中却饱含1个母进程和2个子进程。</p>
<blockquote>
<p>1.新创建的进程与进程的切换都是要耗资源的，所以平时工作中进程数不能开太大。</br><br>2.同时可以运行的进程数一般受制于CPU的核数。</br><br>3.除了使用Process方法，我们还可以使用Pool类创建多进程。</p>
</blockquote>
<h4 id="2-进程池Pool"><a href="#2-进程池Pool" class="headerlink" title="2.进程池Pool"></a>2.进程池Pool</h4><blockquote>
<p>&emsp;&emsp;前言：很多时候系统都需要创建多个进程以提高CPU的利用率，当数量较少时，可以手动生成一个个<code>Process</code>实例。当进程数量较多时，也许可以利用循环，但这仍需要程序员手动管理系统中并发进程的数量。</p>
</blockquote>
<p>&emsp;&emsp;进程池Pool的功效就是可以通过传递参数限制并发进程的数量，默认值为CPU的核数。</br><br>&emsp;&emsp;Pool类可以提供指定数量的进程供用户调用，当有新的请求提交到Pool时，如果进程池还没有满，就会创建一个新的进程来执行请求。如果池满，请求就会告知先等待，直到池中有进程结束，才会创建新的进程来执行这些请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool, cpu_count</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def long_time_task(i):</span><br><span class="line">    print(&#39;子进程：&#123;&#125;-任务&#123;&#125;&#39;.format(os.getpid(), i))</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;结果：&#123;&#125;&quot;.format(8*20))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&quot;CPU内核数：&#123;&#125;&quot;.format(cpu_count()))</span><br><span class="line">    print(&quot;当前母进程是“&#123;&#125;&quot;.format(os.getpid()))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    p &#x3D; Pool(8)</span><br><span class="line">    for i in range(9):</span><br><span class="line">        p.apply_async(long_time_task, (i,))</span><br><span class="line">    print(&quot;等待所有子进程完成。&quot;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&quot;总共用时&#123;&#125;秒&quot;.format(end-start))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.对Pool对象调用join()方法会等待所有的子进程执行完毕<br>2.调用join()之前必须先调用close()和terminate()方法，让其不再接收新的Process了。</p>
</blockquote>
<h2 id="二-Python爬虫下一代网络请求库httpx和parsel解析库测评"><a href="#二-Python爬虫下一代网络请求库httpx和parsel解析库测评" class="headerlink" title="二. Python爬虫下一代网络请求库httpx和parsel解析库测评"></a>二. Python爬虫下一代网络请求库httpx和parsel解析库测评</h2><blockquote>
<p>&emsp;&emsp;前言：httpx号称下一代的新一代的网络请求库，不仅支持requests库的所有操作，还能发送异步请求。parsel最初集成在著名Python爬虫框架Scrapy中，后独立出来成立一个单独的模块，支持XPath选择器，CSS选择器和正则表达式等多种解析提取方式。</p>
</blockquote>
<h3 id="1-案例分析：爬取链家网上的二手房在售房产信息为例"><a href="#1-案例分析：爬取链家网上的二手房在售房产信息为例" class="headerlink" title="1.案例分析：爬取链家网上的二手房在售房产信息为例"></a>1.案例分析：爬取链家网上的二手房在售房产信息为例</h3><h4 id="1-1-Python爬虫之Beautifulsoup模块用法详解"><a href="#1-1-Python爬虫之Beautifulsoup模块用法详解" class="headerlink" title="1.1 Python爬虫之Beautifulsoup模块用法详解"></a>1.1 Python爬虫之Beautifulsoup模块用法详解</h4><blockquote>
<p>&emsp;&emsp;beautifulsoup是一个可以从HTML或XML文件中提取出数据的python库。它能够通过转换器实现惯用的文档导航，查找、修改文档的方式。简而言之，beautifulsoup是一个解析器，可以特定的解析出内容，省去了我们书写正则表达式的麻烦。<br>项目代码如下：</p>
</blockquote>
<h2 id="三-Nginx配置详解"><a href="#三-Nginx配置详解" class="headerlink" title="三.Nginx配置详解"></a>三.Nginx配置详解</h2><p>一个Nginx配置文件通常包含以下3个模块：</p>
<ul>
<li>全局块：比如工作进程数，定义日志路径。</li>
<li>Events块：设置处理轮询事件模型，每个工作进程最大连接数以及http层的keep-alive超时时间。</li>
<li>htto块：路由匹配，静态文件服务器、反向代理、负载均衡等。<br>其中http块又可以进一步分为3块，http全局快的配置对所有站点生效，server块配置仅对单个站点生效，而location块的配置仅对单个页面或url生效。<br>Nginx配置文件示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># 全局块</span><br><span class="line">user www-data;</span><br><span class="line">work_processes 2; ##默认1，一般建议设置为cpu核数的1-2倍</span><br><span class="line">error_log logs&#x2F;errors.log; ## 错误日志路径</span><br><span class="line">pid log&#x2F;nginx.pid; ## 进程id</span><br><span class="line"></span><br><span class="line"># events块</span><br><span class="line">events&#123;</span><br><span class="line">    # 使用epoll的I&#x2F;O模型处理轮询事件</span><br><span class="line">    use epoll;</span><br><span class="line">    </span><br><span class="line">    # 工作进程的最大连接数，默认为1024个</span><br><span class="line">    worker_connections 2048;</span><br><span class="line">    </span><br><span class="line">    # http层的server-alive超时时间</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line">    </span><br><span class="line">    # 客户端请求头部的缓冲区大小</span><br><span class="line">    client_header_buffer_size 2k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # http全局块</span><br><span class="line">    include mime.types; # 导入文件扩展名与文件类型映射表</span><br><span class="line">    default_type application&#x2F;octet-stream; #默认文件类型</span><br><span class="line">    </span><br><span class="line">    # 日志格式及access日志路径</span><br><span class="line">    log_format   main &#39;$remote_addr - $remote_user [$time_local]  $status &#39;</span><br><span class="line">    &#39;&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">    </span><br><span class="line">    access_log logs&#x2F;access.log main;</span><br><span class="line">    </span><br><span class="line">    #允许sendfile方式传输文件，默认为off</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on; # sendfile开启时才开启</span><br><span class="line">    </span><br><span class="line">    # http server块</span><br><span class="line">    # 简单反向代理</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name domain2.com www.domain.com;</span><br><span class="line">        access_log logs&#x2F;domain2.access.log main;</span><br><span class="line">        </span><br><span class="line">        转发动态请求到web应用服务器</span><br><span class="line">        location &#x2F;&#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000</span><br><span class="line">            deny 192.24.40.8 # 拒绝的ip</span><br><span class="line">            allow 192.24.40.6 # 允许的ip</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 错误页面</span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html</span><br><span class="line">        location  &#x2F;50x.html&#123;</span><br><span class="line">            root html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # 负载均衡</span><br><span class="line">    upstream backend_server&#123;</span><br><span class="line">        server 192.168.0.1:8000 weight&#x3D;5;</span><br><span class="line">        server 192.168.0.2:8000 weight&#x3D;1;</span><br><span class="line">        server 192.168.0.3:8000;</span><br><span class="line">        server 192.168.0.4:8001 backup; # 热备</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name big.server.com;</span><br><span class="line">        access_log logs&#x2F;big.server.access.log main;</span><br><span class="line">        </span><br><span class="line">        charset utf-8;</span><br><span class="line">        client_max_body_size 10M; # 限制用户上传的文件大小，默认1M</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            # 通过proxy_pass转发请求到一组通过upstream定义的一组应用服务器</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend_server;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-Niginx-Location配置"><a href="#1-Niginx-Location配置" class="headerlink" title="1.Niginx Location配置"></a>1.Niginx Location配置</h3><table>
<thead>
<tr>
<th>匹配符</th>
<th align="center">匹配规则</th>
<th align="right">优先级</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td align="center">精确匹配</td>
<td align="right">1</td>
</tr>
<tr>
<td>^~</td>
<td align="center">以某个字符串开头</td>
<td align="right">2</td>
</tr>
<tr>
<td>~</td>
<td align="center">区分大小写的正则匹配</td>
<td align="right">3</td>
</tr>
<tr>
<td>~*</td>
<td align="center">不区分大小写的正则匹配</td>
<td align="right">4</td>
</tr>
<tr>
<td>!~</td>
<td align="center">区分大小写的不匹配正则</td>
<td align="right">5</td>
</tr>
<tr>
<td>!~*</td>
<td align="center">区分大小写的不匹配正则</td>
<td align="right">6</td>
</tr>
<tr>
<td>/</td>
<td align="center">通用匹配，任何请求都会匹配到</td>
<td align="right">7</td>
</tr>
<tr>
<td>看如下的规则设置的例子，来加深理解:Nginx会执行优先级更高的匹配规则</td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 规则1：通用匹配</span><br><span class="line">location &#x2F;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 规则2：处理以&#x2F;static开头的url</span><br><span class="line">localtion ^&#x3D;&#x2F;static&#123;</span><br><span class="line">    alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static; #静态资源路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：上述例子中我们使用了<code>alias</code>别名设置了静态文件所在的目录。我们还可以用<code>root</code>指定静态文件目录：</p>
</blockquote>
</li>
<li><code>root</code>对路径的处理：root路径+location路径</li>
<li><code>alias</code>对路径的处理：使用alias路径替换location路径<br>如果用<code>root</code>设置静态资源路径，可以按如下代码进行设置。两者是等同的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">规则2：处理以&#x2F;static开头的url</span><br><span class="line">location ^~ &#x2F;static&#123;</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; #静态资源路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Location还支持正则匹配，比如下例可以禁止用户访问所有的图片格式文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 拒绝访问所有的图片格式文件</span><br><span class="line">location ~* .*\.(jpg|gif|png|jpeg)$&#123;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
请求转发与重定向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 转发动态请求</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localohost:8080;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># http请求重定向到https请求</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name domain.com;</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$server_name$server_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述的代码示例中，我们使用到了以$开头的变量，这些都是Nginx提供的全局变量，它们的具体含义如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$args, 请求中的参数</span><br><span class="line">$content_length, HTTP请求信息里的&quot;Content-length&quot;;</span><br><span class="line">$content-type, 请求信息里的&quot;COntent-Type&quot;;</span><br><span class="line">$document_root, 针对当前请求的根路径设置值</span><br><span class="line">&amp;document_uri，与&amp;uri相同</span><br><span class="line">&amp;host, 请求信息中的&quot;Host&quot;，如果请求中没有Host行，则等于设置的服务器名</span><br><span class="line">$limit_tare，对连接速率的限制</span><br><span class="line">$request_method，请求方法</span><br><span class="line">$remote_addr，客户端地址</span><br><span class="line">$remote_user，客户端用户名，认证用</span><br><span class="line">$request_filename，当前请求的文件路径名</span><br><span class="line">$request_body_file，当前请求的文件</span><br><span class="line">$request_uri，请求的uri，带查询字符串</span><br><span class="line">$query_string 与&amp;args相同；</span><br><span class="line">$scheme，所用的协议，比如是http还是https</span><br><span class="line">$server_protocol 请求的协议版本， &quot;HTTP&#x2F;1.0&quot;</span><br><span class="line">$server_addr， 服务器地址</span><br><span class="line">$server_name, 请求到达的服务器名</span><br><span class="line">$server_port，请求到达的服务器端口号</span><br><span class="line">$uri，请求的URI</span><br></pre></td></tr></table></figure>
这个例子中我们配置只允许用户通过POST方法访问，其他的方法则返回405。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($request_method !~ ^(GET|POST))&#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Nginx静态文件配置"><a href="#2-Nginx静态文件配置" class="headerlink" title="2.Nginx静态文件配置"></a>2.Nginx静态文件配置</h3>Nginx可以直接作为强大的静态文件服务器使用，支持对静态文件进行缓存还可以直接将Nginx作为文件下载服务器使用。<h5 id="2-1静态文件缓存"><a href="#2-1静态文件缓存" class="headerlink" title="2.1静态文件缓存"></a>2.1静态文件缓存</h5>缓存可以加快下次静态文件加载速度，很多与网站样式相关的文件比如css和js文件一般不怎么变化，缓存有效器可以通过<code>expires</code>选项设置得长一些<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用expires选项开启静态文件缓存，10天有效</span><br><span class="line">location ~^(images|javascript|js|css|flash|media|static)&#x2F;&#123;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;big.serrver.com&#x2F;static_files;</span><br><span class="line">    expires 10d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Nignx配置HTTPS"><a href="#3-Nignx配置HTTPS" class="headerlink" title="3.Nignx配置HTTPS"></a>3.Nignx配置HTTPS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 负载均衡，设置HTTPS</span><br><span class="line">upstream backend_server&#123;</span><br><span class="line">    server APP_SERVER_1_IP;</span><br><span class="line">    server APP_SERVER_2_IP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 禁止未绑定域名访问，比如通过ip地址访问</span><br><span class="line"># 444：该网页无法正常运作，并未发送任何数据</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HTTP请求重定向至HTTPS请求</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_name you_domain.com;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For &amp;proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header Host &amp;http_host;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;backend_server;</span><br><span class="line">    &#125;</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line">    server_name your_domain.com</span><br><span class="line">    </span><br><span class="line">    # ssl证书及密钥路径</span><br><span class="line">    ssl_certificate &#x2F;path&#x2F;to&#x2F;your&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;path&#x2F;to&#x2F;your&#x2F;privkey.pem;</span><br><span class="line">    </span><br><span class="line">    # ssl会话信息</span><br><span class="line">    client_max_body_size 75MB;</span><br><span class="line">    keepalive_timeout 10;</span><br><span class="line">    </span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;django;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Nginx日志配置"><a href="#4-Nginx日志配置" class="headerlink" title="4.Nginx日志配置"></a>4.Nginx日志配置</h3>Nginx的日志主要包括访问日志<code>access_log</code>和错误日志<code>error_log</code>，我们可以通过<code>logformat</code>定义日志格式。我们可以在全局块、Server块或Location块定义日志。比如在下例中定义了一个名为main的日志格式，所有站点的日志都会按照这个格式进行记录:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 日志格式及access日志路径</span><br><span class="line">    log_format main &#39;$remote_addr - $remote_user [$time_local] $status&#39;</span><br><span class="line">    &#39;&quot;request&quot; $body_bytes_sent &quot;$http_referer&quot;&#39;</span><br><span class="line">    &#39;&quot;http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">    access_log logs&#x2F;access.log main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>```access_log off```关闭一些不需要记录的访问。比如当一个站点没有设置favicon.ico时，```access_log```会记录大量favicon.ico 404信息，这是没有必要的，可以按如下方式关闭访问日志记录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">location &#x3D; &#x2F;favicon.ico &#123;</span><br><span class="line">    log_not_found off;</span><br><span class="line">    access_log; #不在access_log记录该项访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Nginx超时设置"><a href="#5-Nginx超时设置" class="headerlink" title="5.Nginx超时设置"></a>5.Nginx超时设置</h3>Nginx提供了很多超时设置选项，目的是保护服务器资源，CPU，内存并控制连接数。可以根据实际项目需求在全局块、Server块和Location块进行配置。<h5 id="请求超时设置"><a href="#请求超时设置" class="headerlink" title="请求超时设置"></a>请求超时设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 客户端链接保持会话超时时间，超过这个时间，服务器断开这个链接</span><br><span class="line">keepalive_timeout 60;</span><br><span class="line"></span><br><span class="line"># 设置请求头的时间</span><br><span class="line"># 如果超过这个时间没有发送任何数据，nginx将返回request time out的错误</span><br><span class="line">client_header_timeout 15;</span><br><span class="line"></span><br><span class="line"># 设置请求体的超时时间</span><br><span class="line"># 如果超过这个时间没有发送任何数据，nginx 将返回request time out的错误</span><br><span class="line">client+body_timeout 15;</span><br><span class="line"></span><br><span class="line"># 响应客户端超时时间</span><br><span class="line"># 如果超过这个时间，客户端没有任何活动，nginx关闭连接</span><br><span class="line">send_timeout 15;</span><br><span class="line"></span><br><span class="line"># 上传文件大小限制</span><br><span class="line">client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line"># 也是防止网络阻塞，不过要包含在keepalived参数才有效</span><br><span class="line">tcp_nodelay on;</span><br><span class="line"></span><br><span class="line"># 客户端请求头部的缓冲区大小，这个可以根据系统分页大小来设置</span><br><span class="line"># 一般一个请求头的大小不会超过1k</span><br><span class="line">client_header_buffer_size 2k;</span><br><span class="line"></span><br><span class="line"># 这个将为打开文件指定缓存，默认是没有启用的</span><br><span class="line"># max指定缓存梳理，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">open_file_cache max&#x3D;102400 insctive&#x3D;20s;</span><br><span class="line"></span><br><span class="line"># 这个是指多长时间检查一次缓存的有效信息</span><br><span class="line">open_file_cache_valid 30s;</span><br><span class="line"></span><br><span class="line"># 告诉nginx关闭不响应的客户端连接，这将会释放那个客户端占有的内存空间。</span><br><span class="line">reset_timeout_connection on;</span><br></pre></td></tr></table></figure>
<h5 id="Proxy反向代理超时设置"><a href="#Proxy反向代理超时设置" class="headerlink" title="Proxy反向代理超时设置"></a>Proxy反向代理超时设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 该指令设置与upstream服务的连接超时时间</span><br><span class="line">proxy_connect_timeout 60;</span><br><span class="line"></span><br><span class="line"># 该指令设置应用服务器的响应超时时间</span><br><span class="line">proxy_read_timeout 60</span><br><span class="line"></span><br><span class="line"># 设置了发送请求给upstream服务器的超时时间</span><br><span class="line">proxy_send_timeout 60;</span><br><span class="line"></span><br><span class="line"># max_fails设定Nginx与upstream服务器通信的尝试失败的次数</span><br><span class="line"># 在fail_timeout参数定义的时间段内，如果连接失败次数达到此值，nginx就认为服务不可用</span><br><span class="line">upstream big_server_com &#123;</span><br><span class="line">    server 192.168.0.1:8000 weight&#x3D;5, max_fails&#x3D;3, fail_timeout&#x3D;30s;</span><br><span class="line">    server 192.168.0.2:8000 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;</span><br><span class="line">    server 192.168.0.3:8000</span><br><span class="line">    server 192.168.0.4:8001 backup; #热备</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h5>Nginx提供了多种负载均衡算法，最常见的有5种，我们只需要修改对应的upstream模块即可。<h5 id="轮询-默认"><a href="#轮询-默认" class="headerlink" title="轮询(默认)"></a>轮询(默认)</h5>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 轮询，大家权重一样</span><br><span class="line">upstream backend_server&#123;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.2:8000;</span><br><span class="line">    server 192.168.0.3:8000 down; #不参与负载均衡</span><br><span class="line">    server 192.168.0.4:8001 backup; #热备</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#x2F; &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name big.server.com;</span><br><span class="line">    access_log logs&#x2F;big.server.access.log main;</span><br><span class="line">    </span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 10M; #限制用户上传文件大小，默认1M</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 使用proxy_pass转发请求通过upstream定义的一组应用服务器</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;backend_server;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Real_IP $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="权重-weight"><a href="#权重-weight" class="headerlink" title="权重(weight)"></a>权重(weight)</h5>通过weight指定轮询几率，访问比率与weight成正比，常用于后端服务器性能不均的情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weight越大，承担的任务越多</span><br><span class="line">upstream backend_server&#123;</span><br><span class="line">    server 192.168.0.1:8000 weight&#x3D;3;</span><br><span class="line">    server 192.168.0.2:8000 weight&#x3D;1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h5>每个请求按访问的ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决用户登录时的session问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 权重：weight越大，承担的任务越多</span><br><span class="line">upstream backend_server&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.2:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h5>按访问的url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Url Hash</span><br><span class="line">upstream backend_server&#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.2:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fair-第三方"><a href="#fair-第三方" class="headerlink" title="fair(第三方)"></a>fair(第三方)</h5>按后端服务器的响应时间来分配请求，响应时间短的有效分配。使用这个算法需要安装<code>nginx-upstream-fair</code>这个库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Fair</span><br><span class="line">upstream backend_server&#123;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.2:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-Nginx与uWSGI服务器的沟通"><a href="#6-Nginx与uWSGI服务器的沟通" class="headerlink" title="6.Nginx与uWSGI服务器的沟通"></a>6.Nginx与uWSGI服务器的沟通</h3><blockquote>
<p>在前面的分析中，Nginx都是使用<code>proxy_pass</code>转发的动态请求，<code>proxy_pass</code>使用普通的HTTP协议与应用服务器进行沟通。如果你部署的是Python Web应用(Django, Flask)，你的应用服务器(uwsgi, gunicorn)一般是遵守uwsgi协议的，对于这种情况，建议使用<code>uwsgi_pass</code>转发请求。</p>
</blockquote>
<h5 id="Python-Web应用部署负载均衡Nginx配置文件参考"><a href="#Python-Web应用部署负载均衡Nginx配置文件参考" class="headerlink" title="Python Web应用部署负载均衡Nginx配置文件参考"></a>Python Web应用部署负载均衡Nginx配置文件参考</h5>如果我们部署的是Django或者Flask Web应用，一个完整的Nginx配置文件如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># nginx配置文件: nginx.conf</span><br><span class="line"></span><br><span class="line"># 全局块</span><br><span class="line">user www-data;</span><br><span class="line">worker_processes 2; ## 默认1，一般建议设置成cpu核数的1-2倍</span><br><span class="line"></span><br><span class="line"># Events块</span><br><span class="line">events &#123;</span><br><span class="line">    # 使用epoll的I&#x2F;O模型处理轮询时间。</span><br><span class="line">    # 可以不设置，nginx会根据操作系统选择合适的模型。</span><br><span class="line">    use epoll;</span><br><span class="line">    </span><br><span class="line">    # 工作进程的最大连接数量，默认1024个</span><br><span class="line">    worker_connections 2048;</span><br><span class="line">    </span><br><span class="line">    # http层面的keep-alive超时时间</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # 开启gzip压缩功能</span><br><span class="line">    gzip on;</span><br><span class="line">    </span><br><span class="line">    # 设置允许压缩的页面最小字节数，这里表示如果文件小于10k,压缩没有意义</span><br><span class="line">    gzip_min_length 10k;</span><br><span class="line">    </span><br><span class="line">    # 设置压缩比率，最小为1，处理速度快，传输速度慢；</span><br><span class="line">    # 9为最大压缩比，处理速度慢，传输速度快; 推荐6</span><br><span class="line">    gzip_comp_level 6; </span><br><span class="line">    </span><br><span class="line">    # 设置压缩缓冲区大小，此处设置为16个8K内存作为压缩结果缓冲</span><br><span class="line">    gzip_buffers 16 8k;</span><br><span class="line">    </span><br><span class="line">     # 设置哪些文件需要压缩,一般文本，css和js建议压缩。图片视需要要锁。</span><br><span class="line">    gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript; </span><br><span class="line">    </span><br><span class="line">    upstream backend_server&#123;</span><br><span class="line">        server 192.168.0.1:8000; # 替换成应用服务器或容器实际IP及端口</span><br><span class="line">        server 192.168.0.2:8000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80; #监听80端口</span><br><span class="line">        server_name localhost; #可以是nginx容器所在ip地址或者127.0.0.1，不能写宿主机外网ip地址</span><br><span class="line">        </span><br><span class="line">        charset utf-8;</span><br><span class="line">        client_max_body_size 10M; #限制用户上传文件大小</span><br><span class="line">        </span><br><span class="line">        # 客户端请求头部的缓冲区大小</span><br><span class="line">        client_header_buffer_size 2k;</span><br><span class="line">        client_header_timeout 15;</span><br><span class="line">        client_body_timeout 15;</span><br><span class="line">        </span><br><span class="line">        access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;mysite1.access.log main;</span><br><span class="line">        error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;mysite1.error.log main;</span><br><span class="line">        </span><br><span class="line">        # 静态资源路径</span><br><span class="line">        location &#x2F;static&#123;</span><br><span class="line">            alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 媒体资源路径，用户上传文件路径</span><br><span class="line">        location &#x2F;media&#123;</span><br><span class="line">            alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;media;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            include &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params;</span><br><span class="line">            uwsgi_pass backend_server; # 使用uwsgi_pass， 而不是proxy_pass</span><br><span class="line">            uwsgi_read_timeout 600; # 指定接收uWSGI应答的超时时间</span><br><span class="line">            uwsgi_connect_timeout 600; # 指定连接到后端uWSGI的超时时间</span><br><span class="line">            uwsgi_send_timeout 600; #指定向uWSGI传送请求的超时时间</span><br><span class="line">            </span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP  $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果我们的Nginx与uwsgi在同一台服务器上，用不到负载均衡，你还可以通过本地机器的unix socker进行通信，这样速度更快，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params;</span><br><span class="line">    uswgi_pass unix:&#x2F;run&#x2F;uwsgi&#x2F;django_test1.sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意：取决于Nginx会采用哪种方式与uWSGI服务器进行通信(本地socket， 网络TCP socket和http协议)， uWSGI配置文件也会有所不同，这里以<code>uwsg.ini</code>为例展示了不同<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># uwsgi.ini配置文件</span><br><span class="line"></span><br><span class="line"># 对于uwsgi_pass转发的请求，使用本地unix socket通信</span><br><span class="line"># 仅适用于nginx和uwsgi在同一台服务器上的情形</span><br><span class="line">socket&#x3D;&#x2F;run&#x2F;uwsgi&#x2F;django_test1.sock</span><br><span class="line"></span><br><span class="line"># 对于uwsgi_pass转发的请求，使用TCP socket通信</span><br><span class="line">socket-0.0.0.0:8000</span><br><span class="line"></span><br><span class="line"># 对于proxy_pass HTTP转发的请求，使用http协议</span><br><span class="line">http-0.0.0.0:8000</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Poetry科学管理Python虚拟环境-Poetry"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/08/Poetry%E7%A7%91%E5%AD%A6%E7%AE%A1%E7%90%86Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-Poetry/"
    >Poetry科学管理Python虚拟环境-Poetry</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/11/08/Poetry%E7%A7%91%E5%AD%A6%E7%AE%A1%E7%90%86Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-Poetry/" class="article-date">
  <time datetime="2022-11-08T03:49:52.000Z" itemprop="datePublished">2022-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Poetry科学管理Python虚拟环境-Poetry"><a href="#Poetry科学管理Python虚拟环境-Poetry" class="headerlink" title="Poetry科学管理Python虚拟环境-Poetry"></a>Poetry科学管理Python虚拟环境-Poetry</h1><h2 id="1-Poetry简介"><a href="#1-Poetry简介" class="headerlink" title="1.Poetry简介"></a>1.Poetry简介</h2><blockquote>
<p>&emsp;&emsp;前言：最早使用的python虚拟环境管理方式是使用<code>pipenv</code>，来创建项目的特有python环境。但是，<code>pipenv</code>在实际使用时有：处理速度极慢，且在官方github上被提出了众多Bug，导致了一些不可描述的问题</br><br>&emsp;&emsp;虽然<code>pipenv</code>小火了一把，但由于被提出了糟糕的设计和使用体验。这篇文章介绍另一个python包管理工具<code>poetry</code>，使用它来创建我们的隔离环境。</br><br>&emsp;&emsp;<code>Poetry自带PYPI默认发布库</code>，可以直接将自己的包发布在pypi上。<code>poetry</code>的更新非常活跃。</p>
</blockquote>
<h2 id="2-安装与使用"><a href="#2-安装与使用" class="headerlink" title="2.安装与使用"></a>2.安装与使用</h2><p>windows 10系统使用如下命令即可进行一键安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;python-poetry&#x2F;poetry&#x2F;master&#x2F;get-poetry.py | python</span><br></pre></td></tr></table></figure>
<p>linux系统使用如下命令进行一键安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;python-poetry&#x2F;poetry&#x2F;master&#x2F;get-poetry.py | python</span><br></pre></td></tr></table></figure>
<p>使用如下命令验证安装是否成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry --version</span><br></pre></td></tr></table></figure>
<h2 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3.基本使用"></a>3.基本使用</h2><h5 id="3-1最新添加的poetry-new命令可用于一键创建项目目录"><a href="#3-1最新添加的poetry-new命令可用于一键创建项目目录" class="headerlink" title="3.1最新添加的poetry new命令可用于一键创建项目目录"></a>3.1最新添加的<code>poetry new</code>命令可用于一键创建项目目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry new newproject</span><br></pre></td></tr></table></figure>
<p>创建的项目目录包括：</p>
<ul>
<li>newproject</li>
<li>tests</li>
<li>pyproject.toml<br>项目包含主目录、测试目录，最重要的是pyproject.toml文件，它包含了环境的依赖和配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[tool.poetry]</span><br><span class="line">name &#x3D; &quot;newproject&quot; # 项目名</span><br><span class="line">version &#x3D; &quot;0.1.0&quot; # 项目版本</span><br><span class="line">description &#x3D; &quot;&quot; # 项目描述</span><br><span class="line">authors &#x3D; [&quot;&quot;] # 作者信息</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python &#x3D; &quot;^3.8&quot; # 依赖包</span><br><span class="line"></span><br><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line">pytest &#x3D; &quot;^5.2&quot; # 开发环境依赖包</span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires &#x3D; [&quot;poetry&gt;&#x3D;0.12&quot;]</span><br><span class="line">build-backend &#x3D; &quot;poetry.masonry.api&quot;</span><br></pre></td></tr></table></figure>
这时，仅仅是创建了项目目录，python环境并没有被创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config --list</span><br></pre></td></tr></table></figure>
使用该条命令来查看基础配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cache-dir &#x3D; &quot;C:\\Users\\Admin\\AppData\\Local\\pypoetry\\Cache&quot;</span><br><span class="line">experimental.new-installer &#x3D; true</span><br><span class="line">experimental.system-git-client &#x3D; false</span><br><span class="line">installer.max-workers &#x3D; null</span><br><span class="line">installer.no-binary &#x3D; null</span><br><span class="line">installer.parallel &#x3D; true</span><br><span class="line">virtualenvs.create &#x3D; true</span><br><span class="line">virtualenvs.in-project &#x3D; null</span><br><span class="line">virtualenvs.options.always-copy &#x3D; false</span><br><span class="line">virtualenvs.options.no-pip &#x3D; false</span><br><span class="line">virtualenvs.options.no-setuptools &#x3D; false</span><br><span class="line">virtualenvs.options.system-site-packages &#x3D; false</span><br><span class="line">virtualenvs.path &#x3D; &quot;&#123;cache-dir&#125;\\virtualenvs&quot;  # C:\Users\Admin\AppData\Local\pypoetry\Cache\virtualenvs</span><br><span class="line">virtualenvs.prefer-active-python &#x3D; false</span><br><span class="line">virtualenvs.prompt &#x3D; &quot;&#123;project_name&#125;-py&#123;python_version&#125;&quot;</span><br></pre></td></tr></table></figure></li>
<li>cache-dir：缓存目录(之后下载的包缓存，如果其他项目使用相同的包就不会重复下载)</li>
<li>repositories.foo.url：自定义存储库(使用pip时的安装源)</li>
<li>virtualenvs.create：是否创建虚拟环境，即当安装新包进入此项目时，是否为此项目创建独立的虚拟环境。</li>
<li>virtualenvs.in-project：虚拟环境是否在项目主目录内</li>
<li>virtualenvs.path：创建环境的路径<h5 id="3-2修改安装源"><a href="#3-2修改安装源" class="headerlink" title="3.2修改安装源"></a>3.2修改安装源</h5></li>
<li>poetry config repositories.tuna <a target="_blank" rel="noopener" href="https://pypi.tsinghua.edu.cn/simple">https://pypi.tsinghua.edu.cn/simple</a></li>
<li>上面的是安装源别名，可以随意修改</li>
<li>使用<code>poetry config repositories.tuna --unset</code>可以删除配置<h5 id="3-3-初始化项目"><a href="#3-3-初始化项目" class="headerlink" title="3.3 初始化项目"></a>3.3 初始化项目</h5>我们可以删除上述步骤中的<code>poetry.toml</code>文件，使用<code>poetry init</code>命令来初始化项目<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ poetry init</span><br><span class="line"></span><br><span class="line"># 这个命令会创建你的.toml文件</span><br><span class="line">This command will guide you through creating your pyproject.toml config.</span><br><span class="line"># 输入项目名称、版本、描述、作者、许可，选择python版本(默认为系统里的最新版本)</span><br><span class="line"></span><br><span class="line">Package name [syncer]: </span><br><span class="line">Version [0.1.0]: </span><br><span class="line">Description []: </span><br><span class="line">Author [twilight2017 &lt;liuzixuanp@163.com&gt;, n to skip]: </span><br><span class="line">License []: </span><br><span class="line">Compatible Python versions [^3.9]: </span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (yes&#x2F;no) [yes]</span><br><span class="line">You can specify a package in the following forms:</span><br><span class="line">  - A single name (requests): this will search for matches on PyPI</span><br><span class="line">  - A name and a constraint (requests@^2.23.0)</span><br><span class="line">  - A git url (git+https:&#x2F;&#x2F;github.com&#x2F;python-poetry&#x2F;poetry.git)</span><br><span class="line">  - A git url with a revision (git+https:&#x2F;&#x2F;github.com&#x2F;python-poetry&#x2F;poetry.git#develop)</span><br><span class="line">  - A file path (..&#x2F;my-package&#x2F;my-package.whl)</span><br><span class="line">  - A directory (..&#x2F;my-package&#x2F;)</span><br><span class="line">  - A url (https:&#x2F;&#x2F;example.com&#x2F;packages&#x2F;my-package-0.1.0.tar.gz)</span><br><span class="line"></span><br><span class="line">Package to add or search for (leave blank to skip):</span><br><span class="line"></span><br><span class="line"># 是否选择定义你的开发环境主依赖包</span><br><span class="line">Would you like to define your development dependencies interactively? (yes&#x2F;no) [yes]</span><br><span class="line">Package to add or search for (leave blank to skip):</span><br><span class="line"></span><br><span class="line">Generated file</span><br><span class="line"></span><br><span class="line">[tool.poetry]</span><br><span class="line">name &#x3D; &quot;syncer&quot;</span><br><span class="line">version &#x3D; &quot;0.1.0&quot;</span><br><span class="line">description &#x3D; &quot;&quot;</span><br><span class="line">authors &#x3D; [&quot;twilight2017 &lt;liuzixuanp@163.com&gt;&quot;]</span><br><span class="line">readme &#x3D; &quot;README.md&quot;</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python &#x3D; &quot;^3.9&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires &#x3D; [&quot;poetry-core&quot;]</span><br><span class="line">build-backend &#x3D; &quot;poetry.core.masonry.api&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you confirm generation? (yes&#x2F;no) [yes]</span><br></pre></td></tr></table></figure></li>
<li>签名的是一般项目的信息填写。当选择python版本时，必须确保当前系统内有此版本</li>
<li>接下来会让你定义主依赖包(main dependencies)，比如当前项目是拿django开发的，输入yes后可以输入django,他会将此依赖添加到[tool.poetry.dependencies]</li>
<li>然后是定义开发环境主要依赖，比如需要添加一些测试，如pytest，会将此包依赖添加到[tool.poetry.dev-denpendencies]<h2 id="4-创建环境"><a href="#4-创建环境" class="headerlink" title="4.创建环境"></a>4.创建环境</h2></li>
<li>做完项目初始化后，使用<code>poetry install</code>，即可以一键生成虚拟环境，执行该操作会在项目主目录下生成一个<code>.venv</code>文件夹，里面装的就是虚拟环境。</li>
<li>当项目完成时，可以使用<code>poetry install --no-dev</code>，来创建生产环境<h5 id="4-1-添加包"><a href="#4-1-添加包" class="headerlink" title="4.1 添加包"></a>4.1 添加包</h5></li>
<li><code>poetry add pkg_name</code>,例如： <code>poetry add flask</code><h5 id="4-2-查看项目依赖"><a href="#4-2-查看项目依赖" class="headerlink" title="4.2 查看项目依赖"></a>4.2 查看项目依赖</h5></li>
<li>使用<code>poetry show</code>可以查看当前项目已经安装的主要包(依赖)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ poetry show</span><br><span class="line">asgiref  3.5.2  ASGI specs, helper code, and adapters</span><br><span class="line">django   4.1.3  A high-level Python web framework that encourages rapid development and clean, pragmatic design.</span><br><span class="line">sqlparse 0.4.3  A non-validating SQL parser.</span><br><span class="line">tzdata   2022.6 Provider of IANA time zone data</span><br></pre></td></tr></table></figure></li>
<li>到这一步可能会发现，项目里多了一个<code>poetry.lock</code>文件，它会存储你的主要依赖所需要的依赖结构和一些包的hash值，以保证项目环境的一致性。<br>(1)当我们拿着<code>pyproject.toml</code>移植到另一台机器，没有带上<code>poetry.lock</code>文件时，执行<code>poetry install</code>，会根据主依赖下载最新的包版本。(2)当同时拿着<code>pyproject.toml</code>和<code>poetry.lock</code>移植到另一台机器，执行<code>poetry install</code>，会根据<code>poetry.lock</code>内的值，下载创建项目时的包版本，即使在开发过程中所依赖的包有更新，也不会导致项目冲突。</li>
<li>使用<code>poetry show -t</code>可以详细的看到，各主依赖的依赖关系</li>
<li>这样明确的依赖关系会使管理包非常的方便，不会出现卸载不干净的情况</li>
<li>使用<code>poetry remove pkg_name</code>卸载包时，会将此包的依赖一同卸载。</li>
</ul>
<p><b>干净、漂亮！</b></p>
<h2 id="5-运行python脚本"><a href="#5-运行python脚本" class="headerlink" title="5.运行python脚本"></a>5.运行python脚本</h2><ul>
<li>你并不需要激活环境来运行python脚本，使用<code>poetry run python xxxxx</code>即可运行自己的python文件，poetry会自动查找项目中的虚拟环境。</li>
<li>也可以使用<code>poetry shell</code>激活一个环境来运行我们的python脚本</li>
</ul>
<h2 id="6-自定义命令"><a href="#6-自定义命令" class="headerlink" title="6.自定义命令"></a>6.自定义命令</h2><ul>
<li>在<code>pyproject.toml</code>文件中可以添加自定义命令，从而通过<code>poetry run</code>来快速执行</li>
<li>如：添加一个flask的快速启动命令</li>
<li>命名格式为：<code>命令名称 = &quot;包名.模块名：模块中的函数或方法</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tool.poetry.scripts]</span><br><span class="line">my-flask &#x3D; &quot;newproject.app:main&quot;</span><br></pre></td></tr></table></figure>
对应项目启动入口点为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def Hello():</span><br><span class="line">    return &quot;start success&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<h2 id="7-环境管理"><a href="#7-环境管理" class="headerlink" title="7.环境管理"></a>7.环境管理</h2></li>
<li>默认情况下，poetry将尝试使用当前激活的python版本为当前项目创建虚拟环境<br>运行<code>poetry env info</code>可以显示当前的环境信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Virtualenv</span><br><span class="line">Python:         3.9.11</span><br><span class="line">Implementation: CPython</span><br><span class="line">Path:           D:\2021_practice\syncer\venv</span><br><span class="line">Executable:     D:\2021_practice\syncer\venv\Scripts\python.exe</span><br><span class="line">Valid:          True</span><br><span class="line"></span><br><span class="line">System</span><br><span class="line">Platform:   win32</span><br><span class="line">OS:         nt</span><br><span class="line">Python:     3.9.11</span><br><span class="line">Path:       C:\Users\Admin\AppData\Local\Programs\Python\Python39</span><br><span class="line">Executable: C:\Users\Admin\AppData\Local\Programs\Python\Python39\python.exe</span><br><span class="line"></span><br></pre></td></tr></table></figure>
如果想删除现有的虚拟环境，可以使用如下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env remove</span><br></pre></td></tr></table></figure>
将环境安装在项目目录时，直接删除<code>.venv</code>目录即可<h2 id="8-与poetry相关的其他一些命令"><a href="#8-与poetry相关的其他一些命令" class="headerlink" title="8.与poetry相关的其他一些命令"></a>8.与poetry相关的其他一些命令</h2></li>
<li><code>poetry self update</code>更新poetry到最新版本</li>
<li><code>poetry update pkg_name</code> 更新项目内的某个包</li>
<li><code>poetry publish</code>将包发布到pypi</li>
<li><code>poetry lock</code>锁定依赖项</li>
<li><code>poetry search pkg_name</code>在远程索引上搜索包</li>
<li><code>poetry check</code> 验证<code>pyproject.toml</code>文件的结构，并在出现任何错误时返回详细的报告<br>  filterset_fields = [‘title’, ‘status’]<br>```</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> twilight2017
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="瑟兰迪尔"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E8%AF%BB%E4%B9%A6">读书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/travels">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E9%9A%8F%E7%AC%94">随笔</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>